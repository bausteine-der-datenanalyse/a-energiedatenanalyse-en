{
  "hash": "da7808ac626fb26bc84260371bc08c22",
  "result": {
    "engine": "jupyter",
    "markdown": "# Energy Data Analysis\n\n# Background\nElectric power is generated in power plants and transported via the power grid to electricity consumers. Power generation and consumption must always be balanced. The share of weather-dependent renewable generation is increasing, but electricity cannot yet be stored economically on a large scale. In 2023, pumped-storage power plants in Germany, with a capacity of 37.4 GWh [@Heimerl-Kohler-2017-Pumpspeicher-in-Deutschland, p. 77], fed in 11.1 TWh of electricity, which corresponded to 2.4 percent of Germany's total electricity consumption of 458.3 TWh [@energy-charts-strom]. Power plant scheduling and storage sizing based on generation and consumption data is therefore a relevant application area for data analysis.  \nThe Federal Network Agency publishes, among other things, data on electricity generation, consumption, and wholesale prices on [https://www.smard.de/](https://www.smard.de/home/downloadcenter/download-marktdaten/). (Note: Power plant data is available for generation units with an installed generation capacity of at least 100 MW.)\n\n# Reading the data\nThe electricity market data from the Federal Network Agency must be manually downloaded from [https://www.smard.de/](https://www.smard.de/home/downloadcenter/download-marktdaten/). In this script, data for the year 2023 is used.\n\n::: {style=\"font-size: 90%;\"}\n| Data | File name |\n|---|---|\n| Installed generation capacity 2023 | Installierte_Erzeugungsleistung_202301010000_202401010000_Jahr.csv |\n| Realized electricity generation 2023 | Realisierte_Erzeugung_202301010000_202401010000_Viertelstunde.csv |\n| Realized electricity consumption 2023 | Realisierter_Stromverbrauch_202301010000_202401010000_Viertelstunde.csv |\n:::\n\n::: {#wrn-SMARD .callout-warning appearance=\"simple\" collapse=\"true\"}\n# Download SMARD data\n\n:::: {layout=\"[[50, 50], [50, 50], [1]]\"}\n\nWhen selecting the time period, click “Accept”.\n\nSelect data for installed capacity in the original resolution (annual basis).\n\n![&nbsp;](00-bilder/smard-accept.png){fig-alt=\"Screenshot of the data selection input mask.\"}\n\n![&nbsp;](00-bilder/smard-installed-capacity-de.png){fig-alt=\"Screenshot of the data selection input mask.\"}\n\nThe date format of the files depends on the language set on the website (German/English).\n::::\n:::\n\nThe semicolon-separated files are read as a DataFrame using the Python `pandas` module, which is imported with the alias `pd`. For this, the function `pd.read_csv()` is used. In this process:\n\n* The value, thousands, and decimal separators are specified.  \n  `sep = \";\", thousands = \".\", decimal = \",\"`\n\n* The columns with date and time information and the date format are defined.  \n  `parse_dates = [0, 1], date_format = \"%d.%m.%Y %H:%M\"`\n\n::: {.cell results='hold' execution_count=1}\n``` {.python .cell-code}\nimport pandas as pd\npd.set_option(\"display.precision\", 2) # number of decimal places\nimport numpy as np\nimport matplotlib.pyplot as plt\n\ninstalled_capacity_df = pd.read_csv(filepath_or_buffer = \\\n\"01-daten/Installierte_Erzeugungsleistung_202301010000_202401010000_Jahr.csv\", \\\nsep = \";\", thousands = \".\", decimal = \",\", \\\nparse_dates = [0, 1], date_format = \"%d.%m.%Y\")\n\ngeneration_df = pd.read_csv(filepath_or_buffer = \\\n\"01-daten/Realisierte_Erzeugung_202301010000_202401010000_Viertelstunde.csv\", \\\nsep = \";\", thousands = \".\", decimal = \",\", \\\nparse_dates = [0, 1], date_format = \"%d.%m.%Y %H:%M\")\n\nconsumption_df = pd.read_csv(filepath_or_buffer = \\\n\"01-daten/Realisierter_Stromverbrauch_202301010000_202401010000_Viertelstunde.csv\", \\\nsep = \";\", thousands = \".\", decimal = \",\", \\\nparse_dates = [0, 1], date_format = \"%d.%m.%Y %H:%M\")\n```\n:::\n\n\nTake a look at the string used to specify the date format: `\"%d.%m.%Y %H:%M\"`. Using the [documentation](https://docs.python.org/3/library/datetime.html#strftime-and-strptime-behavior), can you determine what format the dates in the file use? What would be the format for April 14, 2023, at a quarter past two in the afternoon?  \n\n<textarea id=\"date-format\" name=\"date-format\" rows=\"4\" cols=\"80\">You can enter your answer here. The solution is shown in the dropdown.</textarea>\n\n::: {#tip-datumsformat .callout-tip title=\"Date format solution\" collapse=\"true\"}\n<!-- The format is different in the English-language files! -->\n\n| Code | Meaning |\n|---|---|\n| %d. | Day as a two-digit integer with separator \".\" |\n| %m. | Month (possibly with leading zero) with separator \".\" |\n| %Y | Year as a four-digit integer with separator \" \" |\n| %H: | Hour as a two-digit integer with separator \":\" |\n| %M | Minute as a two-digit integer |\n\n**Solution**: 14.04.2023 14:15\n\n:::\n\n# Organizing Data\nBefore data analysis, it should be checked whether the data has been correctly loaded. This means, on the one hand, verifying if the data type of all columns has been correctly recognized. You can check whether the column types of a file have been correctly loaded in Python with the command `df.dtypes`. Here is the output of this command for the DataFrame `generation_df`.\n\n::: {.cell results='hold' execution_count=2}\n``` {.python .cell-code}\nprint(f\"Columns:\\n{generation_df.dtypes}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nColumns:\nDatum von                                            datetime64[ns]\nDatum bis                                            datetime64[ns]\nBiomasse [MWh] Originalauflösungen                          float64\nWasserkraft [MWh] Originalauflösungen                       float64\nWind Offshore [MWh] Originalauflösungen                     float64\nWind Onshore [MWh] Originalauflösungen                      float64\nPhotovoltaik [MWh] Originalauflösungen                      float64\nSonstige Erneuerbare [MWh] Originalauflösungen              float64\nKernenergie [MWh] Originalauflösungen                       float64\nBraunkohle [MWh] Originalauflösungen                        float64\nSteinkohle [MWh] Originalauflösungen                        float64\nErdgas [MWh] Originalauflösungen                            float64\nPumpspeicher [MWh] Originalauflösungen                      float64\nSonstige Konventionelle [MWh] Originalauflösungen           float64\ndtype: object\n```\n:::\n:::\n\n\n&nbsp;\n\nMany of the column names contain the string \" Originalauflösungen\" which can be removed for clarity (note the leading space). In this way, the unit indication [MWh] could also be removed if found distracting.\n\n::: {.cell results='hold' execution_count=3}\n``` {.python .cell-code}\n# Remove the string \" Originalauflösungen\"\ninstalled_capacity_df.columns = installed_capacity_df.columns.str.replace(pat = \" Originalauflösungen\", repl = \"\")\n\ngeneration_df.columns = generation_df.columns.str.replace(pat = \" Originalauflösungen\", repl = \"\")\nprint(f\"Columns:\\n{generation_df.dtypes}\")\n\nconsumption_df.columns = consumption_df.columns.str.replace(pat = \" Originalauflösungen\", repl = \"\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nColumns:\nDatum von                        datetime64[ns]\nDatum bis                        datetime64[ns]\nBiomasse [MWh]                          float64\nWasserkraft [MWh]                       float64\nWind Offshore [MWh]                     float64\nWind Onshore [MWh]                      float64\nPhotovoltaik [MWh]                      float64\nSonstige Erneuerbare [MWh]              float64\nKernenergie [MWh]                       float64\nBraunkohle [MWh]                        float64\nSteinkohle [MWh]                        float64\nErdgas [MWh]                            float64\nPumpspeicher [MWh]                      float64\nSonstige Konventionelle [MWh]           float64\ndtype: object\n```\n:::\n:::\n\n\n&nbsp;\n\nOn the other hand, the loaded data should be inspected to identify errors such as conversion problems with decimal and thousand separators, date formats, an unexpected number of missing values, or other anomalies. For this purpose, not only the first rows of the dataset but also slices from the middle and the end should be checked. The command `pd.concat([a, b, c])` is useful for this, where a list of index ranges can be passed (see the second and third tabs in the following panel).\n\n::: {.panel-tabset}\n\n## installed capacity\n\n::: {.cell results='hold' execution_count=4}\n``` {.python .cell-code}\n# The DataFrame installed_capacity_df has only 1 row\ninstalled_capacity_df\n```\n\n::: {.cell-output .cell-output-display execution_count=4}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>Datum von</th>\n      <th>Datum bis</th>\n      <th>Biomasse [MW]</th>\n      <th>Wasserkraft [MW]</th>\n      <th>Wind Offshore [MW]</th>\n      <th>Wind Onshore [MW]</th>\n      <th>Photovoltaik [MW]</th>\n      <th>Sonstige Erneuerbare [MW]</th>\n      <th>Kernenergie [MW]</th>\n      <th>Braunkohle [MW]</th>\n      <th>Steinkohle [MW]</th>\n      <th>Erdgas [MW]</th>\n      <th>Pumpspeicher [MW]</th>\n      <th>Sonstige Konventionelle [MW]</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>0</th>\n      <td>2023-01-01</td>\n      <td>2024-01-01</td>\n      <td>8467.0</td>\n      <td>5049.0</td>\n      <td>8129.0</td>\n      <td>57590.0</td>\n      <td>63066.0</td>\n      <td>440.0</td>\n      <td>4056.0</td>\n      <td>17692.0</td>\n      <td>18127.0</td>\n      <td>31808.0</td>\n      <td>9379.0</td>\n      <td>8958.0</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\n## realized generation\n\n::: {.cell results='hold' execution_count=5}\n``` {.python .cell-code}\npd.concat([generation_df.head(2), \\\ngeneration_df.iloc[len(generation_df)//2:(len(generation_df)//2+2)], \\\ngeneration_df.tail(2)])\n```\n\n::: {.cell-output .cell-output-display execution_count=5}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>Datum von</th>\n      <th>Datum bis</th>\n      <th>Biomasse [MWh]</th>\n      <th>Wasserkraft [MWh]</th>\n      <th>Wind Offshore [MWh]</th>\n      <th>Wind Onshore [MWh]</th>\n      <th>Photovoltaik [MWh]</th>\n      <th>Sonstige Erneuerbare [MWh]</th>\n      <th>Kernenergie [MWh]</th>\n      <th>Braunkohle [MWh]</th>\n      <th>Steinkohle [MWh]</th>\n      <th>Erdgas [MWh]</th>\n      <th>Pumpspeicher [MWh]</th>\n      <th>Sonstige Konventionelle [MWh]</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>0</th>\n      <td>2023-01-01 00:00:00</td>\n      <td>2023-01-01 00:15:00</td>\n      <td>1094.25</td>\n      <td>320.0</td>\n      <td>684.25</td>\n      <td>7145.75</td>\n      <td>0.50</td>\n      <td>32.25</td>\n      <td>615.25</td>\n      <td>962.75</td>\n      <td>517.00</td>\n      <td>429.75</td>\n      <td>13.50</td>\n      <td>307.25</td>\n    </tr>\n    <tr>\n      <th>1</th>\n      <td>2023-01-01 00:15:00</td>\n      <td>2023-01-01 00:30:00</td>\n      <td>1091.25</td>\n      <td>317.5</td>\n      <td>743.50</td>\n      <td>7158.25</td>\n      <td>0.25</td>\n      <td>32.25</td>\n      <td>614.75</td>\n      <td>963.25</td>\n      <td>518.00</td>\n      <td>429.50</td>\n      <td>9.75</td>\n      <td>307.25</td>\n    </tr>\n    <tr>\n      <th>17520</th>\n      <td>2023-07-02 13:00:00</td>\n      <td>2023-07-02 13:15:00</td>\n      <td>955.25</td>\n      <td>317.5</td>\n      <td>736.00</td>\n      <td>4228.50</td>\n      <td>6832.75</td>\n      <td>25.25</td>\n      <td>0.00</td>\n      <td>795.00</td>\n      <td>216.75</td>\n      <td>546.00</td>\n      <td>0.75</td>\n      <td>264.75</td>\n    </tr>\n    <tr>\n      <th>17521</th>\n      <td>2023-07-02 13:15:00</td>\n      <td>2023-07-02 13:30:00</td>\n      <td>956.75</td>\n      <td>321.5</td>\n      <td>693.75</td>\n      <td>3885.25</td>\n      <td>6961.25</td>\n      <td>25.25</td>\n      <td>0.00</td>\n      <td>791.00</td>\n      <td>215.00</td>\n      <td>545.00</td>\n      <td>0.00</td>\n      <td>266.00</td>\n    </tr>\n    <tr>\n      <th>35038</th>\n      <td>2023-12-31 23:30:00</td>\n      <td>2023-12-31 23:45:00</td>\n      <td>1053.25</td>\n      <td>412.5</td>\n      <td>1479.25</td>\n      <td>7544.25</td>\n      <td>0.50</td>\n      <td>24.00</td>\n      <td>0.00</td>\n      <td>845.25</td>\n      <td>444.50</td>\n      <td>683.00</td>\n      <td>122.75</td>\n      <td>348.50</td>\n    </tr>\n    <tr>\n      <th>35039</th>\n      <td>2023-12-31 23:45:00</td>\n      <td>2024-01-01 00:00:00</td>\n      <td>1051.50</td>\n      <td>404.0</td>\n      <td>1469.00</td>\n      <td>7480.50</td>\n      <td>0.50</td>\n      <td>24.00</td>\n      <td>0.00</td>\n      <td>840.75</td>\n      <td>442.25</td>\n      <td>679.00</td>\n      <td>58.25</td>\n      <td>348.00</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\n## realized consumption\n\n::: {.cell results='hold' execution_count=6}\n``` {.python .cell-code}\npd.concat([consumption_df.head(2), \\\nconsumption_df.iloc[len(consumption_df)//2:(len(consumption_df)//2+2)], \\\nconsumption_df.tail(2)])\n```\n\n::: {.cell-output .cell-output-display execution_count=6}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>Datum von</th>\n      <th>Datum bis</th>\n      <th>Gesamt (Netzlast) [MWh]</th>\n      <th>Residuallast [MWh]</th>\n      <th>Pumpspeicher [MWh]</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>0</th>\n      <td>2023-01-01 00:00:00</td>\n      <td>2023-01-01 00:15:00</td>\n      <td>9720.75</td>\n      <td>1890.25</td>\n      <td>424.75</td>\n    </tr>\n    <tr>\n      <th>1</th>\n      <td>2023-01-01 00:15:00</td>\n      <td>2023-01-01 00:30:00</td>\n      <td>9641.25</td>\n      <td>1739.25</td>\n      <td>443.50</td>\n    </tr>\n    <tr>\n      <th>17520</th>\n      <td>2023-07-02 13:00:00</td>\n      <td>2023-07-02 13:15:00</td>\n      <td>11564.00</td>\n      <td>-233.25</td>\n      <td>1147.75</td>\n    </tr>\n    <tr>\n      <th>17521</th>\n      <td>2023-07-02 13:15:00</td>\n      <td>2023-07-02 13:30:00</td>\n      <td>11536.25</td>\n      <td>-4.00</td>\n      <td>1223.25</td>\n    </tr>\n    <tr>\n      <th>35038</th>\n      <td>2023-12-31 23:30:00</td>\n      <td>2023-12-31 23:45:00</td>\n      <td>10495.75</td>\n      <td>1471.75</td>\n      <td>470.00</td>\n    </tr>\n    <tr>\n      <th>35039</th>\n      <td>2023-12-31 23:45:00</td>\n      <td>2024-01-01 00:00:00</td>\n      <td>10289.25</td>\n      <td>1339.25</td>\n      <td>528.00</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\n:::\n\n&nbsp;\n\nFinally, a plausibility check of the data is advisable. At the beginning, the total electricity consumption in Germany for 2023 was mentioned as 458.3 TWh. The electricity consumption and the sum of electricity generation should approximately correspond to this value.\n\n::: {.cell execution_count=7}\n``` {.python .cell-code}\n# exclude columns with datetime\nprint(\"Electricity consumption in million MWh:\\n\", \\\nconsumption_df.sum(numeric_only = True) // (1000 * 1000), sep = \"\")\n\nprint(\"\\nElectricity generation in million MWh\", \\\ngeneration_df.sum(numeric_only = True).sum() // (1000 * 1000))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nElectricity consumption in million MWh:\nGesamt (Netzlast) [MWh]    458.0\nResiduallast [MWh]         260.0\nPumpspeicher [MWh]          14.0\ndtype: float64\n\nElectricity generation in million MWh 448.0\n```\n:::\n:::\n\n\n&nbsp;\n\nIf all files have been correctly loaded, working copies can be created with the command `df.copy()`. This way, the raw data remains always available and can be reloaded if necessary, for example, after accidentally overwriting the working copies.\n\n::: {.cell results='hold' execution_count=8}\n``` {.python .cell-code}\ngeneration = generation_df.copy()\nconsumption = consumption_df.copy()\ninstalled_capacity = installed_capacity_df.copy()\n```\n:::\n\n\n# Descriptive Data Analysis\nWith methods of descriptive statistics, an overview of the datasets and the data can be obtained. This step is particularly useful for identifying possible errors and anomalies in the dataset. The findings obtained here can be explored in greater depth in the subsequent exploratory and inferential data analysis.\n\nAn initial overview of the data is provided by the method `pd.DataFrame.describe()`, which describes the distribution of the data. By using the argument `include = [np.number]`, the output can be restricted to columns with numerical data, meaning that columns with date information are excluded.\n\n::: {.cell results='hold' execution_count=9}\n``` {.python .cell-code}\nprint(f\"The DataFrame 'generation' has {generation.shape[0]} rows and {generation.shape[1]} columns.\\n\")\ngeneration.describe(include = [np.number])\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nThe DataFrame 'generation' has 35040 rows and 14 columns.\n\n```\n:::\n\n::: {.cell-output .cell-output-display execution_count=9}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>Biomasse [MWh]</th>\n      <th>Wasserkraft [MWh]</th>\n      <th>Wind Offshore [MWh]</th>\n      <th>Wind Onshore [MWh]</th>\n      <th>Photovoltaik [MWh]</th>\n      <th>Sonstige Erneuerbare [MWh]</th>\n      <th>Kernenergie [MWh]</th>\n      <th>Braunkohle [MWh]</th>\n      <th>Steinkohle [MWh]</th>\n      <th>Erdgas [MWh]</th>\n      <th>Pumpspeicher [MWh]</th>\n      <th>Sonstige Konventionelle [MWh]</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>count</th>\n      <td>35040.00</td>\n      <td>35040.00</td>\n      <td>35040.00</td>\n      <td>35040.00</td>\n      <td>35040.00</td>\n      <td>35040.00</td>\n      <td>35040.00</td>\n      <td>35040.00</td>\n      <td>35040.00</td>\n      <td>35040.00</td>\n      <td>35040.00</td>\n      <td>35040.00</td>\n    </tr>\n    <tr>\n      <th>mean</th>\n      <td>1079.50</td>\n      <td>411.50</td>\n      <td>671.23</td>\n      <td>3389.91</td>\n      <td>1590.11</td>\n      <td>33.32</td>\n      <td>192.37</td>\n      <td>2221.58</td>\n      <td>1134.42</td>\n      <td>1431.02</td>\n      <td>318.19</td>\n      <td>330.81</td>\n    </tr>\n    <tr>\n      <th>std</th>\n      <td>80.16</td>\n      <td>83.08</td>\n      <td>457.65</td>\n      <td>2627.46</td>\n      <td>2470.00</td>\n      <td>7.69</td>\n      <td>305.80</td>\n      <td>939.80</td>\n      <td>838.85</td>\n      <td>682.72</td>\n      <td>425.94</td>\n      <td>39.99</td>\n    </tr>\n    <tr>\n      <th>min</th>\n      <td>892.50</td>\n      <td>249.75</td>\n      <td>0.00</td>\n      <td>30.25</td>\n      <td>0.25</td>\n      <td>21.75</td>\n      <td>0.00</td>\n      <td>634.25</td>\n      <td>170.25</td>\n      <td>373.00</td>\n      <td>0.00</td>\n      <td>208.50</td>\n    </tr>\n    <tr>\n      <th>25%</th>\n      <td>1017.50</td>\n      <td>334.00</td>\n      <td>259.00</td>\n      <td>1237.25</td>\n      <td>0.50</td>\n      <td>25.50</td>\n      <td>0.00</td>\n      <td>1396.25</td>\n      <td>506.75</td>\n      <td>893.25</td>\n      <td>38.00</td>\n      <td>304.50</td>\n    </tr>\n    <tr>\n      <th>50%</th>\n      <td>1066.75</td>\n      <td>420.50</td>\n      <td>612.25</td>\n      <td>2657.00</td>\n      <td>24.88</td>\n      <td>32.50</td>\n      <td>0.00</td>\n      <td>2111.25</td>\n      <td>814.75</td>\n      <td>1300.00</td>\n      <td>110.75</td>\n      <td>337.00</td>\n    </tr>\n    <tr>\n      <th>75%</th>\n      <td>1133.25</td>\n      <td>481.00</td>\n      <td>1040.56</td>\n      <td>5017.19</td>\n      <td>2466.50</td>\n      <td>39.25</td>\n      <td>535.00</td>\n      <td>3000.31</td>\n      <td>1501.00</td>\n      <td>1810.75</td>\n      <td>443.00</td>\n      <td>356.00</td>\n    </tr>\n    <tr>\n      <th>max</th>\n      <td>1293.25</td>\n      <td>618.25</td>\n      <td>1910.00</td>\n      <td>12039.50</td>\n      <td>10361.25</td>\n      <td>51.25</td>\n      <td>771.00</td>\n      <td>4121.75</td>\n      <td>3814.00</td>\n      <td>4169.25</td>\n      <td>2399.00</td>\n      <td>512.50</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\n&nbsp;\n\nFrom the descriptive statistics of the data, it can be seen, for example, that onshore wind contributed the largest share to electricity generation. It is also noticeable that neither onshore wind nor photovoltaics have a minimum generation value of 0, whereas this is the case for offshore wind and nuclear energy.\n\n## Visualization\nAnalyzing the descriptive statistics for 12 different types of generation requires focus. Complex information should therefore be presented graphically.\n\nFor a quick overview, for example of the distribution of total generation capacity by generation type, a pie or donut chart is useful. However, as explained in the **Statistics Basics Module (Chapter 2: Single Variables)**, this type of chart has the drawback that with an increasing number of categories (or characteristics to be displayed), it quickly becomes cluttered and the angles become difficult to read accurately.\n\nIn the following donut chart created using the method `pd.DataFrame.plot.pie()`, two adjustments were made: first, the automatic annotation of the percentage values was enabled using the format string `autopct='%1.1f%%'`. Second, the order of the columns in the DataFrame was swapped because otherwise the percentage labels and the labels of smaller slices overlap. Additionally, the substring \" [MWh]\" was removed from the column names for the slice labels. While this improves the readability of the chart, this is not the main reason why the substring was removed.  \n**What do you think is the reason for this?**\n\n::: {#tip-DonutChart .callout-tip collapse=\"true\" title=\"Pie Chart Solution\"}\n\nA pie or donut chart represents proportions and is therefore dimensionless.\n\n:::\n\nYou can find the details of the plot creation in the second tab.\n\n::: {.panel-tabset}\n\n## Plotting with Pandas\n\n::: {.cell results='hold' execution_count=10}\n\n::: {.cell-output .cell-output-display}\n![Share of electricity generation](energiedatenanalyse_files/figure-pdf/cell-11-output-1.pdf){fig-align='center' fig-alt='A pie chart shows the shares of different generation types in electricity production. The pie segments are not sorted by size but arranged to avoid label overlap.'}\n:::\n:::\n\n\n## Code for Pandas\n\n::: {.cell results='hold' execution_count=11}\n``` {.python .cell-code}\n# plot the pie first try - Other Erneuerbare [MWh] overlaps with Kernenergie [MWh] and Pumpspeicher [MWh]\n# generation.sum(numeric_only = True).plot.pie(colormap = \"Blues\", startangle = 90, rotatelabels = True, explode = explosion)\n\n# rearrange columns, remove \" [MWh]\"\nplotting_data = generation.copy()\ncolumn_to_move = plotting_data.pop(\"Kernenergie [MWh]\")\nplotting_data.insert(4, \"Kernenergie [MWh]\", column_to_move)\n\ncolumn_to_move = plotting_data.pop(\"Pumpspeicher [MWh]\")\nplotting_data.insert(10, \"Pumpspeicher [MWh]\", column_to_move)\n\nplotting_data.columns = plotting_data.columns.str.replace(pat = \" [MWh]\", repl = \"\")\n\n# plot the pie\nax = plotting_data.sum(numeric_only = True).plot.pie(colormap = \"Blues\", startangle = 90, rotatelabels = False, autopct='%1.1f%%', pctdistance = 0.6, textprops = dict(size = 7, color = 'black'), wedgeprops = {\"linewidth\": 0.5, \"edgecolor\": \"white\"})\n\n# make a donut\ncircle = plt.Circle((0, 0), radius = 0.7, color = \"white\")\nax.add_patch(circle)\n\nplt.show()\n```\n:::\n\n\n:::\n\n### Aggregating Data\n\nDue to the numerous features, the descriptive and visual representation of generation capacity does not necessarily yield a clear conclusion. One way to better understand the data is to group similar features together. In the following, renewable and conventional (fossil-fuel based) generation types are aggregated to display their share values in a donut chart. Both groups are also shown in a bar chart. The `matplotlib.pyplot` module is used for the visualization. Details of the plot creation can be found in the second tab.\n\n::: {.panel-tabset}\n\n## Plotting with matplotlib\n\n::: {.cell results='hold' execution_count=12}\n\n::: {.cell-output .cell-output-display}\n![Absolute electricity generation and relative shares by generation type](energiedatenanalyse_files/figure-pdf/cell-13-output-1.pdf){fig-align='center' fig-alt='The graphic consists of three vertically stacked subplots. In the middle is a pie chart showing the shares of renewable energy generation (56%), conventional energy (40%), pumped storage (2.5%), and nuclear energy (1.5%). The pie segments are colored in shades of blue. Above is a horizontal bar chart showing absolute generation of renewable energies sorted ascending from bottom to top, starting with the lowest: Other Renewables, Hydropower, Offshore Wind, Biomass, Photovoltaics, Onshore Wind. Below is a horizontal bar chart showing absolute generation of conventional energy sorted ascending from bottom to top, starting with the lowest: Other Conventional, Hard Coal, Natural Gas, Lignite.'}\n:::\n:::\n\n\n## Code for matplotlib\n\n::: {.cell results='hold' execution_count=13}\n``` {.python .cell-code}\n# Define renewables and conventionals, sum each\n\n## Renewables\nplotting_data = generation.copy()\nplotting_data.drop(columns = ['Datum von', 'Datum bis', 'Biomasse [MWh]', 'Wasserkraft [MWh]', 'Wind Offshore [MWh]',\n'Wind Onshore [MWh]', 'Photovoltaik [MWh]',\n'Sonstige Erneuerbare [MWh]'], inplace = True)  # drop date columns; inplace=False returns a copy and does nothing without assignment\nrenewables = ['Biomasse [MWh]', 'Wasserkraft [MWh]', 'Wind Offshore [MWh]', 'Wind Onshore [MWh]', 'Photovoltaik [MWh]',\n'Sonstige Erneuerbare [MWh]']\nplotting_data[\"Erneuerbare\"] = generation[renewables].sum(axis = 'columns')\n\n## Conventionals\nplotting_data.drop(columns = ['Braunkohle [MWh]',  'Steinkohle [MWh]', 'Erdgas [MWh]', 'Sonstige Konventionelle [MWh]'], inplace = True)\nconventionals = ['Braunkohle [MWh]',  'Steinkohle [MWh]', 'Erdgas [MWh]', 'Sonstige Konventionelle [MWh]']\nplotting_data[\"Konventionelle\"] = generation[conventionals].sum(axis = 'columns')\n\n# rearrange columns, remove \" [MWh]\"\nplotting_data = plotting_data[['Erneuerbare', 'Pumpspeicher [MWh]', 'Konventionelle', 'Kernenergie [MWh]']]\nplotting_data.columns = plotting_data.columns.str.replace(pat = \" [MWh]\", repl = \"\")\n\n# for checking - axis=columns sums columns row-wise\n## print(renewables)\n## print(generation[renewables].sum(axis = 'columns'))\n## print(plotting_data.columns)\n## print(plotting_data[0:3])\n\n# create figure with three subplots\nplt.figure(figsize = (7.5, 7.5))\n\nnrows = 4\nncols = 2\nfont_size = 8\n\n# value for shared x-axis on barplots\nx_lim = generation.sum(numeric_only = True).max() * 1.1\n\n# array of colors\nmy_colors = plt.get_cmap('Blues')(np.linspace(0.2, 1, len(plotting_data.sum())))\n\n# plot the pie, use 4 out of 8 panels = middle 2 rows\nax = plt.subplot(nrows, ncols, (3, 6))\nplt.pie(x = plotting_data.sum(), colors = my_colors, startangle = 350, labels = list(plotting_data.columns), autopct='%1.1f%%', pctdistance = 0.5, textprops = dict(size = font_size + 1), wedgeprops = {\"linewidth\": 0.5, \"edgecolor\": \"white\"})\n\n# make a donut\ncircle = plt.Circle((0, 0), radius = 0.65, color = \"white\")\nax.add_patch(circle)\n\n# top row unstacked barplot \nplt.subplot(nrows, ncols, (1, 2))\ngeneration[renewables].sum().sort_values(ascending = False).plot.barh(fontsize = font_size, xlim = (0, x_lim), color = my_colors[0], edgecolor = 'darkgrey')\nplt.title(\"Renewables\", fontsize = font_size + 2)\n\n# bottom row unstacked barplot \nplt.subplot(nrows, ncols, (7, 8))\ngeneration[conventionals].sum().sort_values(ascending = False).plot.barh(fontsize = font_size, xlim = (0, x_lim), color = my_colors[2], edgecolor = 'darkgrey')\nplt.title(\"Conventionals\", fontsize = font_size + 2)\n\nplt.tight_layout()\nplt.show()\n```\n:::\n\n\n:::\n\n&nbsp;\nBy aggregating similar types of electricity generation, the donut chart has been reduced to four generation categories. The generation types with only small shares of total electricity generation, pumped storage and nuclear energy, therefore stand out clearly compared to the individual representation of all generation types. Based on this, it can be discussed whether the shown aggregation is appropriate. On one hand, nuclear energy could be assigned to the conventionals if this group is defined not by fossil fuel use but by the principle of thermal steam expansion. On the other hand, generation from pumped storage should be critically examined. This aspect is discussed in the following section.\n\n::: {#wrn-komplexe-grafiken .callout-warning appearance=\"simple\"}\n\n# Note  \nComplex graphics, like the one shown here, should generally be used sparingly because they can be difficult to understand and interpret. Therefore, the purpose of the graphic and the key conclusions should be clearly explained in the text.\n\nTip: Imagine you were showing the graphic spontaneously to a friend who hasn’t read your work. How would you explain the graphic to your friend? Write this explanation in your report.\n\n:::\n\n### Generation, Storage, Injection  \nPumped-storage power plants are energy storage systems that do not produce primary energy but store electricity generated by other producers and feed it back into the grid when needed. Which producers supplied electricity to fill the pumped storage is analyzed in [@sec-exploratory-data-analysis]. The realized grid feed-in of pumped-storage plants corresponds to the energy production of other power plants reduced by the losses incurred during charging and discharging (as well as any storage losses such as evaporation or seepage). The efficiency of pumped-storage power plants can be calculated using the available data for the year 2023.  \n**What was the efficiency of the pumped-storage power plants in 2023?**  \n\n::: {#tip-pumped-storage-efficiency .callout-tip title=\"Solution: Pumped Storage Efficiency\" collapse=\"true\"}\n\n::: {.cell results='hold' execution_count=14}\n``` {.python .cell-code}\nprint(f\"Total Generation Pumped Storage: {generation['Pumpspeicher [MWh]'].sum():,.2f}\\n\"\n      f\"Total Consumption Pumped Storage: {consumption['Pumpspeicher [MWh]'].sum():,.2f}\\n\"\n      f\"{41 * '='}\\n\"\n      f\"Efficiency in Percent: \\t\\t\\t{(generation['Pumpspeicher [MWh]'].sum() / consumption['Pumpspeicher [MWh]'].sum()) * 100:,.2f}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nTotal Generation Pumped Storage: 11,149,398.50\nTotal Consumption Pumped Storage: 14,095,632.75\n=========================================\nEfficiency in Percent: \t\t\t79.10\n```\n:::\n:::\n\n\n:::\n\nThe actually realized electricity generation is therefore the cumulative electricity generation of the pumped-storage power plants published by the Federal Network Agency, plus the storage losses. The Federal Network Agency includes this value in the electricity consumption dataset. The following code uses the \"walrus\" operator `:=`, which allows assignments within expressions (here within the print statement). This makes the code more concise (although readability decreases). Assignments made using the walrus operator must be enclosed in parentheses:\n\n::: {.cell results='hold' execution_count=15}\n``` {.python .cell-code}\nprint(f\"Storage losses:\\t\\t\\t{(storage_losses := (consumption[\"Pumpspeicher [MWh]\"].sum() - generation[\"Pumpspeicher [MWh]\"].sum()) / (1000 * 1000)):>6.2f} TWh\\n\"\n      f\"Cumulative electricity generation:\\t{(cumulative_generation := generation.sum(numeric_only=True).sum() // (1000 * 1000)):,.2f} TWh\\n\"\n      f\"Total:\\t\\t\\t\\t\\t\\t{storage_losses + cumulative_generation:,.2f} TWh\\n\\n\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nStorage losses:\t\t\t  2.95 TWh\nCumulative electricity generation:\t448.00 TWh\nTotal:\t\t\t\t\t\t450.95 TWh\n\n\n```\n:::\n:::\n\n\nThe difference between the actual realized and the electricity generation published by the Federal Network Agency amounts to just under 3 TWh, which is less than 1 percent of the total electricity generation. In other countries, the correct allocation of data is also materially significant. In Austria, pumped-storage power plants play an important role in the electricity mix.\n\n## Task: Descriptive Data Analysis {#sec-task-descriptive-data-analysis}\n\n::: {.border}\n\n![&nbsp;](00-bilder/Schlegeisspeicher_von_Friesenberghaus_von_Klaus_Kettner_CC_BY-SA_3.0.png){fig-align=\"center\" fig-alt=\"View of the Austrian alpine reservoir Schlegeisspeicher with dam.\" width=\"80%\"}\n\nView of the Schlegeisspeicher from Höhenweg. Photo by Klaus Kettner is licensed under [CC BY-SA 3.0](https://creativecommons.org/licenses/by-sa/3.0/deed.de) and available on [Wikimedia](https://commons.wikimedia.org/w/index.php?curid=20380105). The image was cropped and saved in PNG format. 2012.\n:::\n\n&nbsp;\n\nSimilar to the Federal Network Agency, the Austrian Power Grid AG (APG) publishes electricity market data at [https://markttransparenz.apg.at/](https://markttransparenz.apg.at/de/markt/Markttransparenz/erzeugung/Erzeugung-pro-Typ). Generation data for the year 2023 can be downloaded via this link.\n\nThe following file is attached to this script.\n\n::: {style=\"font-size: 90%;\"}\n| Data | Filename |\n|---|---|\n| Realized Electricity Generation 2023 | AGPT_2022-12-31T23_00_00Z_2023-12-31T23_00_00Z_15M_en_2024-06-10T09_32_38Z.csv |\n:::\n\n&nbsp;\n\n**Load the Austrian generation data and visualize the shares of generation types. What do you notice in the dataset?**\n\n::: {#wrn-electricity-market-austria .callout-warning appearance=\"simple\" collapse=\"true\"}\n# Download Austria Market Transparency Data\n\nAfter selecting the time period, click Export, then the Download button will appear.\n\n![&nbsp;](00-bilder/APG-erzeugungsdaten-2023-de.png){fig-alt=\"View of the input fields to download the Austrian electricity market data.\"}\n\n![&nbsp;](00-bilder/english/APG-generation-data-2023-en.png){fig-alt=\"View of the input fields to download the Austrian electricity market data in English.\"}\n\nThe date format of the files depends on the language setting on the website (German/English).\n\n:::\n\n&nbsp;\n\n::: {#tip-Austria title=\"Tip for Generation Data and Sample Solution\" .callout-tip collapse=\"true\"}\n\nThe Austrian dataset differs in that it reports power (capacity) instead of generated energy. (This does not affect the visualization of generation shares.) The dataset also differs in another aspect.\n\nTip: If not all columns appear in the output of the `.describe()` method, try printing the DataFrame in two or more parts. For example:\n\n::: {.cell execution_count=16}\n``` {.python .cell-code}\nprint(df.iloc[:, 0:5].describe(include=np.number))\nprint(df.iloc[:, 5:10].describe(include=np.number))\nprint(df.iloc[:, 10:15].describe(include=np.number))\n```\n:::\n\n\n:::: {.callout-tip title=\"Musterlösung Strommarktdaten Österreich\" collapse=\"true\"}\n\n::::: {.border}\n\n::: {.cell execution_count=17}\n``` {.python .cell-code}\nimport pandas as pd\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# Set decimal precision for display\npd.set_option(\"display.precision\", 2)\n\n# Load dataset into variable generation0\n\n# !\n# Adjust the file path to the correct location of the downloaded .csv file for your own use.\n# !\n\ngeneration0_austria_ms = pd.read_csv(\"01-daten/AGPT_2022-12-31T23_00_00Z_2023-12-31T23_00_00Z_15M_de_2024-06-10T09_32_38Z.csv\", \n                                     sep = \";\", thousands = \".\", decimal = \",\", parse_dates = [0, 1], date_format = \"%d.%m.%Y\")\n\nprint(generation0_austria_ms.head(10))\n\nprint(f\"The DataFrame generation0_austria_ms has {generation0_austria_ms.shape[0]} rows and {generation0_austria_ms.shape[1]} columns.\")\n\n# Brief summary statistics of dataset\nprint(generation0_austria_ms.describe(include=[np.number]))\n\n# If the dataset has many columns, some may be truncated in output.\n# Print descriptive stats in chunks if needed:\nprint(generation0_austria_ms.iloc[:, 0:5].describe(include=[np.number]))\nprint(generation0_austria_ms.iloc[:, 5:10].describe(include=[np.number]))\nprint(generation0_austria_ms.iloc[:, 10:15].describe(include=[np.number]))\n\n# Create a copy of the dataset\ngeneration_austria_ms_c = generation0_austria_ms.copy()\n\n# Drop columns with time data\ngeneration_austria_ms_c = generation_austria_ms_c.drop(columns=[\"Zeit von [CET/CEST]\", \"Zeit bis [CET/CEST]\"])\nprint(generation_austria_ms_c.head(5))\n\n# Remove the string \" [MW]\" from column names\ngeneration_austria_ms_c.columns = generation_austria_ms_c.columns.str.replace(pat=\" [MW]\", repl=\"\")\nprint(generation_austria_ms_c.head(5))\n\n# Plausibility check: the .csv file in Excel shows that the \"Pumpspeicher\" column contains both positive and negative values.\n# This is also visible in the .describe() output.\n# Check for negative values in generation columns:\ncheck_negative_values = (generation_austria_ms_c < 0).any().any()\nif check_negative_values:\n    print(\"ERROR: Negative values detected in generation data.\")\n\n# Set negative values in \"Pumpspeicher\" column to 0\ngeneration_austria_ms_c[\"Pumpspeicher\"] = generation_austria_ms_c[\"Pumpspeicher\"].clip(lower=0)\n\n# Remove columns with a sum of zero\n# Approach: drop any column where the sum of all values is zero\ncolumns_to_drop = [col for col in generation_austria_ms_c.columns if generation_austria_ms_c[col].sum() == 0]\ngeneration_austria_ms_c = generation_austria_ms_c.drop(columns=columns_to_drop)\nprint(generation_austria_ms_c.head(10))\n\n# To improve readability of very small pie chart segments, rearrange columns:\n# alternate between largest and smallest segment, second largest and second smallest, etc.\nsorted_columns = generation_austria_ms_c.sum().sort_values().index\n\nnew_order = []\nfor i in range(len(sorted_columns) // 2):\n    new_order.append(sorted_columns[i])\n    new_order.append(sorted_columns[-(i + 1)])\n\n# If odd number of columns, append the middle one last\nif len(sorted_columns) % 2 != 0:\n    new_order.append(sorted_columns[len(sorted_columns) // 2])\n\ngeneration_austria_ms_c = generation_austria_ms_c[new_order]\n\nplt.figure(figsize=(7, 7))\npie_plot = generation_austria_ms_c.sum(numeric_only=True).plot.pie(\n    colormap=\"Blues\",\n    startangle=90,\n    rotatelabels=False,\n    wedgeprops={\"linewidth\": 1, \"edgecolor\": \"white\"},\n    autopct='%1.1f%%',\n    pctdistance=0.6,\n    textprops=dict(size=7),\n)\n\n# Make a donut chart by adding a white circle at the center\ncircle = plt.Circle((0, 0), radius=0.7, color=\"white\")\npie_plot.add_patch(circle)\n\nplt.show()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n   Zeit von [CET/CEST]  Zeit bis [CET/CEST]  Wind [MW]  Solar [MW]  \\\n0  01.01.2023 00:00:00  01.01.2023 00:15:00     1000.0         0.0   \n1  01.01.2023 00:15:00  01.01.2023 00:30:00      964.0         0.0   \n2  01.01.2023 00:30:00  01.01.2023 00:45:00      956.0         0.0   \n3  01.01.2023 00:45:00  01.01.2023 01:00:00      992.0         0.0   \n4  01.01.2023 01:00:00  01.01.2023 01:15:00      880.0         0.0   \n5  01.01.2023 01:15:00  01.01.2023 01:30:00      888.0         0.0   \n6  01.01.2023 01:30:00  01.01.2023 01:45:00      948.0         0.0   \n7  01.01.2023 01:45:00  01.01.2023 02:00:00      968.0         0.0   \n8  01.01.2023 02:00:00  01.01.2023 02:15:00      956.0         0.0   \n9  01.01.2023 02:15:00  01.01.2023 02:30:00      952.0         0.0   \n\n   Biomasse [MW]  Gas [MW]  Kohle [MW]  Öl [MW]  Geothermie [MW]  \\\n0          240.0      27.6         0.0      0.0             0.07   \n1          240.0      27.6         0.0      0.0             0.07   \n2          240.0      28.0         0.0      0.0             0.07   \n3          240.0      27.6         0.0      0.0             0.07   \n4          240.0      27.6         0.0      0.0             0.07   \n5          240.0      28.4         0.0      0.0             0.07   \n6          240.0      28.8         0.0      0.0             0.07   \n7          240.0      28.0         0.0      0.0             0.07   \n8          240.0      28.8         0.0      0.0             0.07   \n9          240.0      28.4         0.0      0.0             0.07   \n\n   Pumpspeicher [MW]  Lauf- und Schwellwasser [MW]  Speicher [MW]  \\\n0            -1404.8                        2291.6           70.4   \n1            -1532.8                        2283.2           66.8   \n2            -1544.4                        2240.0          100.4   \n3            -1579.6                        2199.6           77.6   \n4            -1590.8                        2234.8           63.2   \n5            -1602.8                        2229.2           73.6   \n6            -1572.0                        2211.2           69.2   \n7            -1579.2                        2194.8           70.8   \n8            -1649.6                        2202.8           75.2   \n9            -1702.0                        2172.4           65.6   \n\n   Sonstige Erneuerbare [MW]  Müll [MW]  Andere [MW]  \n0                        0.0      100.0         22.0  \n1                        0.0      100.0         22.0  \n2                        0.0      100.0         22.0  \n3                        0.0      100.0         22.0  \n4                        0.0      100.0         22.0  \n5                        0.0      100.0         22.0  \n6                        0.0      100.0         22.0  \n7                        0.0      100.0         22.0  \n8                        0.0      100.0         22.0  \n9                        0.0      100.0         22.0  \nThe DataFrame generation0_austria_ms has 35040 rows and 15 columns.\n       Wind [MW]  Solar [MW]  Biomasse [MW]  Gas [MW]  Kohle [MW]  Öl [MW]  \\\ncount   35040.00    35040.00       35040.00  35040.00     35040.0  35040.0   \nmean      942.84      268.01         159.94    736.68         0.0      0.0   \nstd       884.56      421.28          64.30    799.65         0.0      0.0   \nmin         4.00        0.00          52.00      0.00         0.0      0.0   \n25%       204.00        0.00         100.00      0.40         0.0      0.0   \n50%       644.00       20.00         156.00    472.00         0.0      0.0   \n75%      1484.00      392.00         216.00   1273.60         0.0      0.0   \nmax      3400.00     2028.00         312.00   3599.60         0.0      0.0   \n\n       Geothermie [MW]  Pumpspeicher [MW]  Lauf- und Schwellwasser [MW]  \\\ncount         3.50e+04           35040.00                      35040.00   \nmean          7.20e-02             283.53                       3477.12   \nstd           1.39e-17            1101.68                       1032.45   \nmin           7.20e-02           -2082.80                       1375.60   \n25%           7.20e-02            -451.20                       2591.60   \n50%           7.20e-02             181.60                       3516.00   \n75%           7.20e-02            1010.40                       4131.20   \nmax           7.20e-02            3160.80                       6290.40   \n\n       Speicher [MW]  Sonstige Erneuerbare [MW]  Müll [MW]  Andere [MW]  \ncount       35040.00                    35040.0    35040.0      35040.0  \nmean          488.40                        0.0      100.0         22.0  \nstd           301.89                        0.0        0.0          0.0  \nmin            16.00                        0.0      100.0         22.0  \n25%           248.00                        0.0      100.0         22.0  \n50%           424.40                        0.0      100.0         22.0  \n75%           686.00                        0.0      100.0         22.0  \nmax          1434.40                        0.0      100.0         22.0  \n       Wind [MW]  Solar [MW]  Biomasse [MW]\ncount   35040.00    35040.00       35040.00\nmean      942.84      268.01         159.94\nstd       884.56      421.28          64.30\nmin         4.00        0.00          52.00\n25%       204.00        0.00         100.00\n50%       644.00       20.00         156.00\n75%      1484.00      392.00         216.00\nmax      3400.00     2028.00         312.00\n       Gas [MW]  Kohle [MW]  Öl [MW]  Geothermie [MW]  Pumpspeicher [MW]\ncount  35040.00     35040.0  35040.0         3.50e+04           35040.00\nmean     736.68         0.0      0.0         7.20e-02             283.53\nstd      799.65         0.0      0.0         1.39e-17            1101.68\nmin        0.00         0.0      0.0         7.20e-02           -2082.80\n25%        0.40         0.0      0.0         7.20e-02            -451.20\n50%      472.00         0.0      0.0         7.20e-02             181.60\n75%     1273.60         0.0      0.0         7.20e-02            1010.40\nmax     3599.60         0.0      0.0         7.20e-02            3160.80\n       Lauf- und Schwellwasser [MW]  Speicher [MW]  Sonstige Erneuerbare [MW]  \\\ncount                      35040.00       35040.00                    35040.0   \nmean                        3477.12         488.40                        0.0   \nstd                         1032.45         301.89                        0.0   \nmin                         1375.60          16.00                        0.0   \n25%                         2591.60         248.00                        0.0   \n50%                         3516.00         424.40                        0.0   \n75%                         4131.20         686.00                        0.0   \nmax                         6290.40        1434.40                        0.0   \n\n       Müll [MW]  Andere [MW]  \ncount    35040.0      35040.0  \nmean       100.0         22.0  \nstd          0.0          0.0  \nmin        100.0         22.0  \n25%        100.0         22.0  \n50%        100.0         22.0  \n75%        100.0         22.0  \nmax        100.0         22.0  \n   Wind [MW]  Solar [MW]  Biomasse [MW]  Gas [MW]  Kohle [MW]  Öl [MW]  \\\n0     1000.0         0.0          240.0      27.6         0.0      0.0   \n1      964.0         0.0          240.0      27.6         0.0      0.0   \n2      956.0         0.0          240.0      28.0         0.0      0.0   \n3      992.0         0.0          240.0      27.6         0.0      0.0   \n4      880.0         0.0          240.0      27.6         0.0      0.0   \n\n   Geothermie [MW]  Pumpspeicher [MW]  Lauf- und Schwellwasser [MW]  \\\n0             0.07            -1404.8                        2291.6   \n1             0.07            -1532.8                        2283.2   \n2             0.07            -1544.4                        2240.0   \n3             0.07            -1579.6                        2199.6   \n4             0.07            -1590.8                        2234.8   \n\n   Speicher [MW]  Sonstige Erneuerbare [MW]  Müll [MW]  Andere [MW]  \n0           70.4                        0.0      100.0         22.0  \n1           66.8                        0.0      100.0         22.0  \n2          100.4                        0.0      100.0         22.0  \n3           77.6                        0.0      100.0         22.0  \n4           63.2                        0.0      100.0         22.0  \n     Wind  Solar  Biomasse   Gas  Kohle   Öl  Geothermie  Pumpspeicher  \\\n0  1000.0    0.0     240.0  27.6    0.0  0.0        0.07       -1404.8   \n1   964.0    0.0     240.0  27.6    0.0  0.0        0.07       -1532.8   \n2   956.0    0.0     240.0  28.0    0.0  0.0        0.07       -1544.4   \n3   992.0    0.0     240.0  27.6    0.0  0.0        0.07       -1579.6   \n4   880.0    0.0     240.0  27.6    0.0  0.0        0.07       -1590.8   \n\n   Lauf- und Schwellwasser  Speicher  Sonstige Erneuerbare   Müll  Andere  \n0                   2291.6      70.4                   0.0  100.0    22.0  \n1                   2283.2      66.8                   0.0  100.0    22.0  \n2                   2240.0     100.4                   0.0  100.0    22.0  \n3                   2199.6      77.6                   0.0  100.0    22.0  \n4                   2234.8      63.2                   0.0  100.0    22.0  \nERROR: Negative values detected in generation data.\n     Wind  Solar  Biomasse   Gas  Geothermie  Pumpspeicher  \\\n0  1000.0    0.0     240.0  27.6        0.07           0.0   \n1   964.0    0.0     240.0  27.6        0.07           0.0   \n2   956.0    0.0     240.0  28.0        0.07           0.0   \n3   992.0    0.0     240.0  27.6        0.07           0.0   \n4   880.0    0.0     240.0  27.6        0.07           0.0   \n5   888.0    0.0     240.0  28.4        0.07           0.0   \n6   948.0    0.0     240.0  28.8        0.07           0.0   \n7   968.0    0.0     240.0  28.0        0.07           0.0   \n8   956.0    0.0     240.0  28.8        0.07           0.0   \n9   952.0    0.0     240.0  28.4        0.07           0.0   \n\n   Lauf- und Schwellwasser  Speicher   Müll  Andere  \n0                   2291.6      70.4  100.0    22.0  \n1                   2283.2      66.8  100.0    22.0  \n2                   2240.0     100.4  100.0    22.0  \n3                   2199.6      77.6  100.0    22.0  \n4                   2234.8      63.2  100.0    22.0  \n5                   2229.2      73.6  100.0    22.0  \n6                   2211.2      69.2  100.0    22.0  \n7                   2194.8      70.8  100.0    22.0  \n8                   2202.8      75.2  100.0    22.0  \n9                   2172.4      65.6  100.0    22.0  \n```\n:::\n\n::: {.cell-output .cell-output-display}\n![Share of electricity generation in Austria](energiedatenanalyse_files/figure-pdf/cell-18-output-2.pdf){fig-align='center' fig-alt='A pie chart showing shares of various generation types in electricity production. Segments are alternated by size (largest, smallest, second largest, second smallest, etc.).' fig-pos='H'}\n:::\n:::\n\n\nSample solution by Marc Sönnecken. For compatibility with this script, file paths and object names were adjusted. For accessibility, figure size and color palette were changed, a white inner circle added, and percentage labels repositioned.\n\n:::::\n::::\n:::\n\n# Exploratory Data Analysis {#sec-exploratory-data-analysis}\nExploratory data analysis means asking questions about the available data and answering them using data analysis methods. The insights gained in this way can help refine the questions or generate new ones. It is therefore an iterative process, aimed primarily at gaining a deeper understanding of the data. [@R-for-Data-Science, Kapitel 10 Exploratory data analysis]\n\n## Background: Marginal Electricity Analysis\nIn the present case, the exploratory examination of the dataset is guided by the question of which producers supplied electricity to *additionally* fill the pumped storage facilities beyond meeting the grid demand. The aim is to determine which electricity producers, at the times when the pumped storage plants were being filled, were capable of providing additional output. This additional electricity can be referred to briefly as marginal electricity.\n\n::: {#imp-MarginalElectricity .callout-important}\n\n# Marginal Electricity\nMarginal analysis examines the conditions prevailing when producing or consuming an *additional* unit. This differs from an average analysis, which examines the effect of a change in quantity across *all* units. Marginal electricity refers to an additional unit of electricity.\n\nFor example, suppose the current electricity generation is 100 units, consisting of 60 units of solar power and, because solar production is insufficient, an additional 40 units of coal power. In this case, each unit of electricity contains, on average, 0.4 parts coal power. Now, if an additional 20 units of electricity are demanded, these must be supplied through additional coal-fired generation. In the average view, the electricity mix now consists of 60 units of solar power and 40 + 20 = 60 units of coal power. This changes the average coal share in electricity production from 0.4 to 0.5.\n\nIn the marginal view, the coal share of the *additionally consumed* electricity is 20 out of 20 units, i.e., 1.\n\n:::\n\n## Background: Priority Feed-in of Renewable Energy\nIn Germany, since the year 2000, the Renewable Energy Sources Act has been in effect, originally introduced as the Act on the Priority of Renewable Energy Sources [Documentation and Information System for Parliamentary Materials](https://dip.bundestag.de/vorgang/gesetz-f%C3%BCr-den-vorrang-erneuerbarer-energien-erneuerbare-energien-gesetz-eeg-sowie/111957). This act stipulated in § 3 the priority feed-in of renewable energies:\n\n::: {.border layout=\"[[5, 90, 5], [1]]\"}\n\n&nbsp;\n\n**Obligation to Purchase and Remunerate**  \n(1) Grid operators are obliged to connect installations for the generation of electricity according to § 2 to their grid, to purchase all electricity offered from these installations with priority, and to remunerate the fed-in electricity in accordance with §§ 4 to 8.\n\n&nbsp;\n\n&nbsp;  \nAct on the Priority of Renewable Energy Sources (Renewable Energy Sources Act – EEG) as well as amendments to the Energy Industry Act and the Mineral Oil Tax Act. Federal Law Gazette Year 2000 Part I No. 13, issued in Bonn on March 31, 2000. [Federal Gazette](https://www.bgbl.de/xaver/bgbl/start.xav?startbk=Bundesanzeiger_BGBl&start=//*%5b@attr_id=%27bgbl100s0305.pdf%27%5d#__bgbl__%2F%2F*%5B%40attr_id%3D%27bgbl100s0305.pdf%27%5D__1718177313490)\n\n:::\n\n&nbsp;\n\nProducers classified as renewable energy have priority feed-in to the grid. According to the current version of the law, these are:\n\n::: {.border}\n\n  a) Hydropower, including wave, tidal, salinity gradient, and current energy,\n\n  b) Wind energy,\n\n  c) Solar radiation energy,\n\n  d) Geothermal energy,\n  \n  e) Energy from biomass, including biogas, biomethane, landfill gas, and sewage gas, as well as from the biodegradable fraction of waste from households and industry\n\nAct for the Expansion of Renewable Energy Sources (Renewable Energy Sources Act – EEG 2023). § 3 Definitions. <https://www.gesetze-im-internet.de/eeg_2014/__3.html>\n\n:::\n\n&nbsp;\n\nNon-renewable producers operate in load-following mode to cover the residual load, i.e., the grid load minus the renewable generation output. This means that two scenarios can be distinguished:\n\n1. **Surplus of renewable energy:** Electricity demand is fully met by renewable energy generation, and there is a generation surplus (or generators have been curtailed), which can serve additional electricity consumption.  \n\n2. **Electricity mix from renewable feed-in and load-following non-renewable producers:** Renewable energy sources feed in at full capacity, and the residual load and additional electricity consumption are met by non-renewable producers.\n\nWhich scenario applies in the power grid at a given moment can thus be determined by looking at the residual load.\n\n## Determine residual load and remaining load\nThe Federal Network Agency publishes, in its dataset on realized electricity consumption, the grid load, residual load, and electricity consumption by pumped storage power plants.\n\n::: {.cell execution_count=18}\n``` {.python .cell-code}\nprint(consumption.sum(numeric_only = True))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nGesamt (Netzlast) [MWh]    4.58e+08\nResiduallast [MWh]         2.60e+08\nPumpspeicher [MWh]         1.41e+07\ndtype: float64\n```\n:::\n:::\n\n\n::: {#imp-Residuallast .callout-important}\n## Residual Load\n\n\"Residual load [...] corresponds to the\ntotal realized electricity consumption, minus the feed-in from photovoltaic, onshore wind, and offshore wind plants.\" [SMARD.de User Manual (p. 53)](https://www.smard.de/resource/blob/212924/61a75e052eddb43a8d3cc4c6e1653fa3/smard-benutzerhandbuch-02-2024-data.pdf)\n\n:::\n\n&nbsp;\n\nThe residual load not covered by renewable energies is the difference between electricity consumption and generation from renewable sources. Consequently, this residual load is smaller than the residual load published by the Federal Network Agency. Both residual load and this remaining load can be calculated from the difference between grid load and the corresponding renewable electricity generation.\n\n::: {.cell execution_count=19}\n``` {.python .cell-code}\nrenewables = ['Biomasse [MWh]', 'Wasserkraft [MWh]', 'Wind Offshore [MWh]', 'Wind Onshore [MWh]', 'Photovoltaik [MWh]', 'Sonstige Erneuerbare [MWh]']\nPV_WindOnshore_WindOffshore = ['Wind Offshore [MWh]', 'Wind Onshore [MWh]', 'Photovoltaik [MWh]'] \n\nplotting_data = pd.DataFrame()\nplotting_data[\"Netzlast [MWh]\"] = consumption[\"Gesamt (Netzlast) [MWh]\"].copy() \nplotting_data[\"volatile EE [MWh]\"] = generation[PV_WindOnshore_WindOffshore].sum(axis=\"columns\").copy()\nplotting_data[\"Erneuerbare [MWh]\"] = generation[renewables].sum(axis=\"columns\").copy()\n\nplotting_data[\"Residuallast BNetzA [MWh]\"] = consumption[\"Residuallast [MWh]\"].copy()\nplotting_data[\"Residuallast [MWh]\"] = plotting_data[\"Netzlast [MWh]\"] - plotting_data[\"volatile EE [MWh]\"]\nplotting_data[\"Restlast [MWh]\"] = plotting_data[\"Netzlast [MWh]\"] - plotting_data[\"Erneuerbare [MWh]\"]\n\nplotting_data.head()\n```\n\n::: {.cell-output .cell-output-display execution_count=18}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>Netzlast [MWh]</th>\n      <th>volatile EE [MWh]</th>\n      <th>Erneuerbare [MWh]</th>\n      <th>Residuallast BNetzA [MWh]</th>\n      <th>Residuallast [MWh]</th>\n      <th>Restlast [MWh]</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>0</th>\n      <td>9720.75</td>\n      <td>7830.50</td>\n      <td>9277.00</td>\n      <td>1890.25</td>\n      <td>1890.25</td>\n      <td>443.75</td>\n    </tr>\n    <tr>\n      <th>1</th>\n      <td>9641.25</td>\n      <td>7902.00</td>\n      <td>9343.00</td>\n      <td>1739.25</td>\n      <td>1739.25</td>\n      <td>298.25</td>\n    </tr>\n    <tr>\n      <th>2</th>\n      <td>9609.50</td>\n      <td>8119.50</td>\n      <td>9559.50</td>\n      <td>1490.00</td>\n      <td>1490.00</td>\n      <td>50.00</td>\n    </tr>\n    <tr>\n      <th>3</th>\n      <td>9565.00</td>\n      <td>7919.00</td>\n      <td>9362.25</td>\n      <td>1646.00</td>\n      <td>1646.00</td>\n      <td>202.75</td>\n    </tr>\n    <tr>\n      <th>4</th>\n      <td>9473.50</td>\n      <td>8107.75</td>\n      <td>9540.50</td>\n      <td>1365.75</td>\n      <td>1365.75</td>\n      <td>-67.00</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\n&nbsp;\n\nThe residual load published by the Federal Network Agency `Residual Load BNetzA [MWh]` corresponds, based on the inspection of the first few rows, to the self-calculated residual load `Residual Load [MWh]`. Whether this holds true for the entire time series can be easily checked using the method `pd.Series.equals()`, which returns a boolean value, i.e., True or False.\n\n::: {.cell results='hold' execution_count=20}\n``` {.python .cell-code}\nplotting_data['Residuallast BNetzA [MWh]'].equals(plotting_data['Residuallast [MWh]'])\n```\n\n::: {.cell-output .cell-output-display execution_count=19}\n```\nTrue\n```\n:::\n:::\n\n\nThis allows the redundant column to be removed.\n\n::: {.cell results='hold' execution_count=21}\n``` {.python .cell-code}\nplotting_data.drop(['Residuallast BNetzA [MWh]'], axis='columns', inplace=True)\n```\n:::\n\n\n## Visualizing the Annual Cycle\nThe network load, renewable energy generation, as well as the residual and remaining load should be visualized over the course of a year. For better clarity, only every 100th value will be plotted.\n\n::: {.panel-tabset}\n\n## Network Load Throughout the Year\n\n\n::: {.cell results='hold' execution_count=23}\n\n::: {.cell-output .cell-output-display}\n![Network Load Throughout the Year](energiedatenanalyse_files/figure-pdf/cell-24-output-1.pdf){fig-align='center' fig-alt='Combined display in five stacked subplots: 1. network load, 2. cumulative generation from photovoltaics, onshore wind, and offshore wind, 3. cumulative renewable generation, 4. residual load, and 5. remaining load over the year.'}\n:::\n:::\n\n\n## Code for the Plot\n\n::: {.cell results='hold' execution_count=24}\n``` {.python .cell-code}\n# Find position and content for x-axis labels\nmonths = generation[\"Datum von\"].dt.month.unique().tolist() # gives numbers 1-12\n\n## using Pandas\nmonths_index = generation[~generation[\"Datum von\"].dt.month.duplicated()].index\nmonth_names = generation[\"Datum von\"].iloc[months_index].dt.strftime(\"%B\") \n\n## alternatively using a list operation\n# months_index = []\n# month_names = []\n\n# for i in months:\n#   months_index.append(generation.index[generation[\"Datum von\"].dt.month == i].min())\n#   month_names.append(generation[\"Datum von\"].iloc[months_index[i - 1]].strftime(\"%B\"))\n```\n:::\n\n\n::: {.cell results='hold' execution_count=25}\n``` {.python .cell-code}\n# plot every 100th value\nplotting_data[::100].plot(figsize = (9, 8), subplots = True, sharey = True, xlim = (plotting_data.index.min() - (len(plotting_data.index) / 100), plotting_data.index.max() * 1.01), rot = 45, grid = True)\nplt.ylim(top = 20000)\nplt.minorticks_off()\nplt.xticks(months_index, month_names);\n\nplt.show()\n```\n:::\n\n\n:::\n\nIt can be observed that the grid load consistently remains above 9,000 MWh. Furthermore, the grid load fluctuates strongly on a monthly basis, reaching values of up to 19,000 MWh. Each month sees performance near the absolute minimum and maximum. In summer, the grid load is generally somewhat lower than in winter.  \n\nThe electricity generation from renewable energy, shown in the second subplot (volatile RE [MWh]), is highly volatile. Periods of high production alternate with periods of low production, each lasting only a few days and at most two weeks. This is mainly due to electricity generation from photovoltaics and offshore/onshore wind, whose combined nationwide output in Germany often drops close to zero before reaching a (local) production maximum. In the third subplot (Renewables [MWh]), it can be seen that the additional feed-in from less volatile renewable sources such as biomass and hydropower is comparatively low. Therefore, while the total electricity generation summed across all renewable sources is never zero, it often reaches a low overall output. Nevertheless, there are also short periods of full renewable supply or surplus production, as can be seen from the annual curve of non-renewable residual load.  \n\nRegarding the question of the origin of the electricity stored in pumped-storage plants, the graphical representation already indicates that it was predominantly generated by non-renewable sources, as the residual load is rarely zero or negative.\n\nThe annual curve of the residual load mirrors the generation pattern of volatile renewable energy. This poses a challenge for conventional power plants. This aspect will be explored in more detail in the next section.  \n\nBut first, a small task:  \n**How would a doubling of renewable generation affect the residual load? Display the effect graphically in a comparable manner (e.g., by adding an extra column 'Grid Load - 2x RE').**\n\n::: {#tip-doubling-RE .callout-tip title=\"Sample Solution Doubling RE\" collapse=\"true\"}\n\n:::: {.panel-tabset}\n\n## Plot\n\n::: {.cell execution_count=26}\n\n::: {.cell-output .cell-output-display}\n![Example solution doubling Renewable Energy (RE)](energiedatenanalyse_files/figure-pdf/cell-27-output-1.pdf){fig-alt='Visualization of the grid load and the grid load minus the doubled cumulative renewable energy generation over the year. The grid load minus the doubled renewable generation approaches a symmetric distribution around zero. This means periods of renewable over- and underproduction roughly balance each other out.'}\n:::\n:::\n\n\n## Code\n\n::: {.cell execution_count=27}\n``` {.python .cell-code}\nplotting_data_2xRE = plotting_data.copy()\nplotting_data_2xRE[\"2x EE\"] = plotting_data_2xRE[\"Erneuerbare [MWh]\"] * 2\nplotting_data_2xRE[\"Netzlast - 2x EE\"] = plotting_data_2xRE[\"Netzlast [MWh]\"] - plotting_data_2xRE[\"2x EE\"]\nplotting_data_2xRE = plotting_data_2xRE[[\"Netzlast [MWh]\", \"Netzlast - 2x EE\"]]\n\n# plot every 100th value\nplotting_data_2xRE[::100].plot(figsize=(9, 6), subplots=True, sharey=True,\n                               xlim=(plotting_data_2xRE.index.min() - (len(plotting_data_2xRE.index)) / 100,\n                                     plotting_data_2xRE.index.max() * 1.01),\n                               rot=45, grid=True)\nplt.minorticks_off()\nplt.xticks(months_index, month_names)\n\nplt.show()\n```\n:::\n\n\n## Possible Interpretation\nThe grid load minus the doubled renewable power generation approaches a symmetric distribution around the zero line. This means that periods of renewable overproduction and underproduction roughly balance each other out.\n::::\n:::\n\n## Background: Base, Medium, and Peak Load\nNot all power plants are equally suitable for load-following operation due to technical or economic reasons. For example, coal-fired power plants are less flexibly controllable than gas-fired plants. Nuclear power plants are preferred for base load operation due to their high fixed and low variable costs. In the power grid, three operational profiles for power plants are distinguished: base load, medium load, and peak load.\n\n::: {#imp-Base-Medium-Peak-Load .callout-important}\n## Base, Medium, and Peak Load\n\n:::: {.border}\n  * Base load: The power continuously demanded throughout the year.  \n    Plant types: Lignite, Nuclear, Run-of-river hydro\n\n  * Medium load: Power demanded beyond the base load, planable on a daily and yearly basis.  \n    Plant types: Combined cycle gas plants, Hard coal\n\n  * Peak load: Power demanded beyond the medium load, only briefly or unexpectedly during the day or year.  \n    Plant types: Gas turbines, Pumped-storage hydro\n\nISPEX AG: [Base load](https://www.ispex.de/lexikon/grundlast/), [Medium load](https://www.ispex.de/lexikon/mittellast/), [Peak load](https://www.ispex.de/lexikon/spitzenlast/)\n\nGrünwald, Reinhard / Caviezel, Claudio 2017: Load-following capability of German nuclear power plants. Monitoring. Office for Technology Assessment at the German Bundestag (TAB). doi: [10.5445/IR/1000102277](https://publikationen.bibliothek.kit.edu/1000102277). Page 16.\n\n::::\n:::\n\nFor the question of which power plants supply the marginal power for filling the pumped-storage hydro plants, the distinction between base-load plants on the one hand, and medium- and peak-load plants on the other hand, is particularly relevant. Base-load plants operate at full capacity 24 hours a day. For example, in 2021, nuclear energy reached nearly continuous full-load operation with 8,070 annual full-load hours [statista](https://de.statista.com/statistik/daten/studie/37610/umfrage/jahresvolllaststunden-deutscher-kraftwerke-im-jahr-2009/). Plants running at full load can no longer respond to additional electricity demand. This is left to plants operating in medium and peak load.\n\nThus, by distinguishing between power plant types operating in base load and those in medium or peak load, one can narrow down which plant types supplied the electricity required to fill the pumped-storage plants.\n\nThe utilization of a power plant (or group of plants) can be quantified using its annual full-load hours.\n\n::: {#imp-Annual-Full-Load-Hours .callout-important}\n\n## Annual Full-Load Hours\n\nThe annual full-load hours indicate how many of the 8,760 hours in a year a power plant would need to operate at maximum capacity to produce its annual output. [statista](https://de.statista.com/statistik/daten/studie/37610/umfrage/jahresvolllaststunden-deutscher-kraftwerke-im-jahr-2009/)\n\n$$\nAnnual~Full\\text{-}Load~Hours~(h) = \\frac{Total~electricity~generated~in~MWh}{Installed~capacity~in~MW}\n$$\n\n:::\n\nThe annual full-load hours can be calculated as follows. Applying the `.sum` method to the dataset `installed_capacity` is not necessary since it contains only one row. However, the `.sum` method allows you to exclude date columns using the parameter `numeric_only = True`.\n\n::: {.cell execution_count=28}\n``` {.python .cell-code}\n# print(f\"{generation.sum(numeric_only=True)}\\n\")\n# print(installed_capacity.sum(numeric_only=True), \"\\n\")\n\n# For the division, indices need to be reset\nfull_load_hours_per_year = generation.sum(numeric_only=True).reset_index(drop=True).divide(installed_capacity.sum(numeric_only=True).reset_index(drop=True))\n\n# Reset index\nfull_load_hours_per_year.index = generation.sum(numeric_only=True).index.str.replace(pat=\" [MWh]\", repl=\" [h]\")\n\nprint(f\"\\n\\nFull load hours per year\\n\\n{full_load_hours_per_year.sort_values(ascending=False)}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n\n\nFull load hours per year\n\nBiomasse [h]                   4467.41\nBraunkohle [h]                 4399.96\nWind Offshore [h]              2893.34\nWasserkraft [h]                2855.83\nSonstige Erneuerbare [h]       2653.47\nSteinkohle [h]                 2192.86\nWind Onshore [h]               2062.55\nKernenergie [h]                1661.92\nErdgas [h]                     1576.42\nSonstige Konventionelle [h]    1293.98\nPumpspeicher [h]               1188.76\nPhotovoltaik [h]                883.48\ndtype: float64\n```\n:::\n:::\n\n\nThe calculation of annual operating hours shows that no type of power plant ran even close to full capacity. The highest utilization is observed for biomass and lignite. Biomass operated at full load for the equivalent of 51 percent of the 8,760 annual hours, while lignite did so for 50 percent. In contrast, the classic base-load generator, nuclear energy, reached only 25 percent. Hard coal, mainly used in Germany for mid-load operation, reached 19 percent. The year 2023 was particularly unusual for nuclear energy.\n\nTherefore, the annual profile of selected conventional generators is presented. To achieve high resolution, a monthly representation is chosen.\n\n::: {.panel-tabset}\n\n## Example Code: Nuclear Energy\n\n::: {.cell execution_count=29}\n``` {.python .cell-code}\nplotting_data = generation.copy()\n\nproducer = \"Kernenergie\"\n\nfig = plt.figure(figsize = (8, 12))\nfig.suptitle(producer, fontsize = 12)\nfor i in range(1, 13):\n    plotting_data_monthly = plotting_data[plotting_data['Datum von'].dt.month == i]\n    ax = fig.add_subplot(12, 1, i)\n    ax.plot(plotting_data_monthly[producer + \" [MWh]\"])\n    plt.margins(x = 0.01)\n    ax.set_ylabel(\"MWh\")\n    \n    # Generate title\n    plt.title(plotting_data_monthly['Datum von'].head(1).dt.strftime('%B').item(), fontsize = 10)\n    \n    # Generate xticks\n    day_index = plotting_data_monthly[~plotting_data_monthly['Datum von'].dt.day.duplicated()].index\n    day_names = plotting_data_monthly['Datum von'].dt.day.unique()\n    plt.xticks(day_index, day_names, fontsize = 8)\n\nplt.tight_layout()\nplt.show()\n```\n:::\n\n\n## Nuclear Energy\n\n::: {.cell execution_count=30}\n\n::: {.cell-output .cell-output-display}\n![Annual Pattern of Nuclear Energy](energiedatenanalyse_files/figure-pdf/cell-31-output-1.pdf){fig-alt='Each month is shown in 12 subplots representing nuclear power generation. While production stays within a narrow range from January to March, it drops to zero on April 15.'}\n:::\n:::\n\n\n## Lignite\n\n::: {.cell execution_count=31}\n\n::: {.cell-output .cell-output-display}\n![Annual Profile Lignite](energiedatenanalyse_files/figure-pdf/cell-32-output-1.pdf){fig-alt='The annual profile of electricity generation from lignite is shown month by month in 12 charts. The annual pattern is characterized by strong fluctuations. Phases of full-load production in the range of 4000 MWh per quarter hour are rarely maintained for periods longer than a week. Production peaks are often reached only for a few hours, after which production is sometimes sharply reduced. Low production levels in the range of 1000 MWh per quarter hour are not uncommon.'}\n:::\n:::\n\n\n## Hard Coal\n\n::: {.cell execution_count=32}\n\n::: {.cell-output .cell-output-display}\n![Annual Profile Hard Coal](energiedatenanalyse_files/figure-pdf/cell-33-output-1.pdf){fig-alt='The annual profile of electricity generation from hard coal is shown month by month in 12 charts. Production peaks rarely reach 3000 MWh per quarter hour and last only a few hours. Intraday ramp-up and ramp-down cycles dominate. Phases of low production in the range of 1000 MWh are also common.'}\n:::\n:::\n\n\n## Natural Gas\n\n::: {.cell execution_count=33}\n\n::: {.cell-output .cell-output-display}\n![Annual Profile Natural Gas](energiedatenanalyse_files/figure-pdf/cell-34-output-1.pdf){fig-alt='The annual profile of electricity generation from natural gas is shown month by month in 12 charts. The annual pattern of natural gas resembles that of hard coal, albeit at a significantly lower production level. Although the installed capacity of gas power plants is about three-quarters higher than that of lignite and hard coal plants, peak production on a quarter-hour basis reaches only 4000 MWh. Typical production levels are below 2000 MWh, often well below 1000 MWh.'}\n:::\n:::\n\n\n:::\n\nIn the **Nuclear Energy** tab, it can be seen that in 2023 the last German nuclear power plants Emsland, Isar 2, and Neckarwestheim 2 were taken off the grid. In autumn 2022, due to the energy crisis, an extended stretch operation was decided for these plants beyond the original shutdown date of December 31, 2022. [BMWK](https://www.bmwk.de/Redaktion/DE/Pressemitteilungen/2023/04/20230413-deutschland-beendet-das-zeitalter-der-atomkraft.html)\n\n**Until which day was the stretch operation approved? Determine the shutdown date using the dataset `generation`. Output the shutdown time from the column `'Datum bis'` in German date formatting `DD. Month YYYY um HH:MM Uhr`.**\n\n::: {#tip-abschaltung-akw .callout-tip title=\"Hint and Sample Solution\" collapse=\"true\"}\nWhen the shutdown occurred, electricity production from nuclear energy reached the value 0. The shutdown was completed in the period preceding the first period in which nuclear power generation had the value 0.\n\nYou can format the output of a column as datetime using the method [pandas.Series.dt.strftime](https://pandas.pydata.org/docs/reference/api/pandas.Series.dt.strftime.html).\n\n:::: {#tip-abschaltung-akw .callout-tip title=\"Sample Solution\" collapse=\"true\"}\n\nIn the graphical representation of the annual profile, only every 100th value was plotted, so it is possible that electricity generation reached zero before the final shutdown. Therefore, it is more reliable to search the dataset backwards. \n\nIn the forward search, the position of the first occurrence of the value 0 is determined with the `.eq()` method, and 1 is subtracted. In the backward search, the position of the first value greater than 0 is determined using the `.gt()` method.\n\n::: {.cell execution_count=34}\n``` {.python .cell-code}\nprint(f\"Forward search: generation['Kernenergie [MWh]'].eq(0).idxmax() - 1\\n{generation['Kernenergie [MWh]'].eq(0).idxmax() - 1}\\n\")\n\n# backward search\nprint(f\"Backward search: position := generation['Kernenergie [MWh]'].iloc[::-1].gt(0).idxmax()\\n{ ( position := generation['Kernenergie [MWh]'].iloc[::-1].gt(0).idxmax() ) }\\n\")\n\nprint(f\"generation['Datum bis'].iloc[position].strftime('%d. %B %Y um %H:%M Uhr')\\n{generation['Datum bis'].iloc[position].strftime('%d. %B %Y um %H:%M Uhr')}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nForward search: generation['Kernenergie [MWh]'].eq(0).idxmax() - 1\n10075\n\nBackward search: position := generation['Kernenergie [MWh]'].iloc[::-1].gt(0).idxmax()\n10075\n\ngeneration['Datum bis'].iloc[position].strftime('%d. %B %Y um %H:%M Uhr')\n16. April 2023 um 00:00 Uhr\n```\n:::\n:::\n\n\n::::\n:::\n\nThe calculation of annual full-load hours and the visualization of annual profiles show that, due to the high share of volatile renewable electricity generation in the German power system, there is no longer any baseload that can be served by conventional generators. This means that all non-renewable generators operate in load-following mode. This can be illustrated by the example of hard coal, whose achieved annual full-load hours are closer to the classic peak load generation from natural gas than to the mid-load generation from lignite. The utilization of a power generator can be represented using a sorted annual duration curve.\n\n::: {#imp-Jahresdauerlinie .callout-important}\n## Sorted Annual Duration Curve\n\nThe sorted annual duration curve is a diagram of the data sorted in descending order.\n\n:::: {.border}\n\n{{< video https://www.youtube.com/watch?v=rMxYJuGqR4s >}}\n\nEnergy Technology. 2 Introduction. 2.13 Sorted Annual Duration Curve by Henrik te Heesen is licensed under [CC BY-SA 3.0](https://creativecommons.org/licenses/by-sa/3.0/deed.en) and available on [YouTube](https://www.youtube.com/watch?v=rMxYJuGqR4s).\n\n::::\n:::\n\n::: {.panel-tabset}\n\n## Plot\n\n::: {.cell execution_count=35}\n\n::: {.cell-output .cell-output-display}\n![sorted annual duration curve of selected conventional generators](energiedatenanalyse_files/figure-pdf/cell-36-output-1.pdf){fig-alt='The sorted annual duration curves for lignite, hard coal, and natural gas are shown. Lignite shows an almost linear descending pattern, while natural gas and especially hard coal show sharply descending curves, meaning that high production levels are reached much less frequently than low levels. For example, lignite reaches a maximum production of about 4000 MWh on a single day. Half of this value (or more) is reached on 200 days of the year. In contrast, hard coal reaches its maximum production of about 3750 MWh on a single day, but half of this value (or more) is only reached on about 60 days of the year.'}\n:::\n:::\n\n\n## Code for the Plot\n\n::: {.cell execution_count=36}\n``` {.python .cell-code}\n# Group data by day and aggregate by daily mean.\nlignite_daily = generation['Braunkohle [MWh]'].groupby(generation[\"Datum von\"].dt.dayofyear).mean()\nhardcoal_daily = generation['Steinkohle [MWh]'].groupby(generation[\"Datum von\"].dt.dayofyear).mean()\nnaturalgas_daily = generation['Erdgas [MWh]'].groupby(generation[\"Datum von\"].dt.dayofyear).mean()\n\n## For verification\n## print(generation[\"Datum von\"].dt.dayofyear)\n## print(f\"\\n\\nlignite_daily.head()\\n{lignite_daily.head()}\\n\\n\"\n##       f\"For comparison:\\ngeneration['Braunkohle [MWh]'].iloc[[0, 1, 95, 96]]\\n{generation['Braunkohle [MWh]'].iloc[[0, 1, 95, 96]]}\\n\\n\"\n##       f\"generation['Braunkohle [MWh]'].iloc[0:96].mean()\\n{generation['Braunkohle [MWh]'].iloc[0:96].mean()}\") \n\n# Plot line chart\n# Shift index by 1 because index starts at 0 but represents day count.\nline_width = 5\nplt.figure(figsize = (8, 4))\n\nlignite_daily = lignite_daily.sort_values(ascending = False, ignore_index = True)\nlignite_daily.index += 1\nlignite_daily.plot.line(lw = line_width, color = 'brown', alpha = 0.5, label = 'Lignite')\n\nhardcoal_daily = hardcoal_daily.sort_values(ascending = False, ignore_index = True)\nhardcoal_daily.index += 1\nhardcoal_daily.plot.line(lw = line_width, color = 'black', alpha = 0.5, label = 'Hard Coal')\n\nnaturalgas_daily = naturalgas_daily.sort_values(ascending = False, ignore_index = True)\nnaturalgas_daily.index += 1\nnaturalgas_daily.plot.line(lw = line_width, color = 'lightskyblue', alpha = 0.5, label = 'Natural Gas')\n\nplt.title(label = \"sorted load duration curve for selected conventional generators\")\nplt.grid()\nplt.legend()\nplt.ylabel('average electricity generation in MWh\\n(on a quarter-hour basis)')\nplt.xlabel('number of days per year')\n\nplt.margins(x = 0.02)\nplt.show()\n```\n:::\n\n\n:::\n\nWhen comparing the achieved annual full-load hours, it was observed that the utilization of hard coal more closely resembles that of the peak load generator natural gas rather than the mid-load generator lignite. Furthermore, the graphical representation of the sorted annual duration curves shows that the generation profile of hard coal even resembles that of lignite less than that of natural gas.\n\nSo far, only the generation from conventional power plants has been considered. Biomass and lignite reach comparable annual full-load hours, making a comparison of the two generators interesting.  \n**Display the annual profile and the annual duration curves for biomass and lignite.**\n\n::: {#tip-generation-profiles-biomass-lignite .callout-tip title=\"Sample Solution: Generation Profiles of Biomass and Lignite\" collapse=\"true\"}\n\n:::: {.border}\n\n::::: {.panel-tabset}\n\n## Code\n\n::: {.cell execution_count=37}\n``` {.python .cell-code}\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Set the number of decimal places for display\npd.set_option(\"display.precision\", 2)\n\n# Load datasets\n\n# !\n# For your own use, adjust the file path to the correct location of the downloaded .csv file.\n# !\n\ngeneration0_ms = pd.read_csv(\n    \"01-daten/Realisierte_Erzeugung_202301010000_202401010000_Viertelstunde.csv\",\n    sep=\";\", thousands=\".\", decimal=\",\", parse_dates=[0, 1], date_format=\"%d.%m.%Y %H:%M\"\n)\n\n# Remove string \" Originalauflösungen\" from column names\ngeneration0_ms.columns = generation0_ms.columns.str.replace(pat=\" Originalauflösungen\", repl=\"\")\n\nprint(generation0_ms.head(10))\n\n# Group data of selected generation types by day and aggregate by daily mean\nlignite_daily_qtr = generation0_ms['Braunkohle [MWh]'].groupby(generation0_ms[\"Datum von\"].dt.dayofyear).mean()\nbiomass_daily_qtr = generation0_ms['Biomasse [MWh]'].groupby(generation0_ms[\"Datum von\"].dt.dayofyear).mean()\n\n# Plot line chart\nline_width = 5\nplt.figure(figsize=(8, 4))\n\nlignite_daily_qtr = lignite_daily_qtr.sort_values(ascending=False, ignore_index=True)\nlignite_daily_qtr.index += 1\nlignite_daily_qtr.plot.line(lw=line_width, color='brown', alpha=0.5, label='Lignite')\n\nbiomass_daily_qtr = biomass_daily_qtr.sort_values(ascending=False, ignore_index=True)\nbiomass_daily_qtr.index += 1\nbiomass_daily_qtr.plot.line(lw=line_width, color='greenyellow', alpha=0.5, label='Biomass')\n\nplt.title(label=\"Sorted annual duration curve for selected generators\")\nplt.grid()\nplt.legend()\nplt.ylabel('Average electricity generation in MWh\\n(quarter-hourly basis)')\nplt.xlabel('Number of days per year')\n\nplt.margins(x=0.02)\n\n# Load profile: Select the generator type here for which load profile should be plotted. Comment out the other.\ngenerator = \"Biomasse\"\n#generator = \"Braunkohle\"\n\nfig = plt.figure(figsize=(8, 12))\nfig.suptitle(generator, fontsize=12)\nfor i in range(1, 13):\n    monthly_data = generation0_ms[generation0_ms['Datum von'].dt.month == i]\n    ax = fig.add_subplot(12, 1, i)\n    ax.plot(monthly_data[generator + \" [MWh]\"])\n    plt.margins(x=0.01)\n    ax.set_ylabel(ylabel=\"MWh\")\n    \n    # Create title\n    plt.title(label=monthly_data['Datum von'].head(1).dt.strftime('%B').item(), fontsize=10)\n    \n    # Generate xticks\n    day_index = monthly_data[~monthly_data[\"Datum von\"].dt.day.duplicated()].index\n    day_numbers = monthly_data[\"Datum von\"].dt.day.unique()\n    plt.xticks(day_index, day_numbers, fontsize=8)\n\nplt.tight_layout()\nplt.show()\n```\n:::\n\n\n## Text-Output\n\n::: {.cell execution_count=38}\n\n::: {.cell-output .cell-output-stdout}\n```\n            Datum von           Datum bis  Biomasse [MWh]  Wasserkraft [MWh]  \\\n0 2023-01-01 00:00:00 2023-01-01 00:15:00         1094.25             320.00   \n1 2023-01-01 00:15:00 2023-01-01 00:30:00         1091.25             317.50   \n2 2023-01-01 00:30:00 2023-01-01 00:45:00         1090.25             317.25   \n3 2023-01-01 00:45:00 2023-01-01 01:00:00         1089.25             321.50   \n4 2023-01-01 01:00:00 2023-01-01 01:15:00         1085.25             315.25   \n5 2023-01-01 01:15:00 2023-01-01 01:30:00         1087.75             304.75   \n6 2023-01-01 01:30:00 2023-01-01 01:45:00         1086.50             303.50   \n7 2023-01-01 01:45:00 2023-01-01 02:00:00         1085.25             304.25   \n8 2023-01-01 02:00:00 2023-01-01 02:15:00         1080.25             308.25   \n9 2023-01-01 02:15:00 2023-01-01 02:30:00         1084.25             305.50   \n\n   Wind Offshore [MWh]  Wind Onshore [MWh]  Photovoltaik [MWh]  \\\n0               684.25             7145.75                0.50   \n1               743.50             7158.25                0.25   \n2               817.00             7302.25                0.25   \n3               814.50             7104.25                0.25   \n4               785.50             7322.00                0.25   \n5               898.50             7332.75                0.25   \n6               943.75             7259.75                0.25   \n7               958.25             7390.50                0.25   \n8              1009.75             7229.00                0.50   \n9               967.00             7421.75                0.25   \n\n   Sonstige Erneuerbare [MWh]  Kernenergie [MWh]  Braunkohle [MWh]  \\\n0                       32.25             615.25            962.75   \n1                       32.25             614.75            963.25   \n2                       32.50             615.00            966.50   \n3                       32.50             614.50            966.75   \n4                       32.25             614.50            969.00   \n5                       32.25             614.75            965.75   \n6                       32.25             614.75            967.50   \n7                       32.25             614.75            964.25   \n8                       32.25             615.00            963.00   \n9                       32.25             614.75            967.00   \n\n   Steinkohle [MWh]  Erdgas [MWh]  Pumpspeicher [MWh]  \\\n0            517.00        429.75               13.50   \n1            518.00        429.50                9.75   \n2            517.00        432.00                9.75   \n3            515.50        430.50                9.75   \n4            513.25        391.25               26.50   \n5            514.00        389.50               45.00   \n6            513.75        393.75               50.50   \n7            511.00        393.50               50.50   \n8            509.75        391.50               41.25   \n9            509.00        394.50               40.75   \n\n   Sonstige Konventionelle [MWh]  \n0                         307.25  \n1                         307.25  \n2                         308.25  \n3                         306.00  \n4                         306.75  \n5                         305.00  \n6                         302.00  \n7                         304.50  \n8                         303.00  \n9                         303.75  \n```\n:::\n:::\n\n\n## Annual Biomass Profile\n\n::: {.cell execution_count=39}\n\n::: {.cell-output .cell-output-display}\n![Annual Biomass Profile](energiedatenanalyse_files/figure-pdf/cell-40-output-1.pdf){fig-align='center' fig-alt='For each month, 12 subplots show electricity generation from biomass. Generation remains above 900 MWh per 15 minutes throughout the year. Above this level, frequent fluctuations in generation are observed. On one hand, generation seems to follow the daily load profile. On the other hand, in the bright generation, production appears reduced during midday hours.'}\n:::\n:::\n\n\n## Annual Profile of Lignite\n\n::: {.cell execution_count=40}\n\n::: {.cell-output .cell-output-display}\n![Annual Profile of Biomass](energiedatenanalyse_files/figure-pdf/cell-41-output-1.pdf){fig-align='center' fig-alt='For each month, 12 subplots show electricity generation from lignite. The chart corresponds to the previously shown annual profile of lignite in this section.'}\n:::\n:::\n\n\n## Sorted Annual Duration Curves\n\n::: {.cell execution_count=41}\n\n::: {.cell-output .cell-output-display}\n![Sorted annual duration curves for selected generators](energiedatenanalyse_files/figure-pdf/cell-42-output-1.pdf){fig-align='center' fig-alt='Displayed are the sorted annual duration curves for lignite and biomass. The sorted annual duration curve for lignite corresponds to the one shown earlier in this section (almost linearly decreasing). In contrast, the sorted annual duration curve for biomass runs almost parallel to the x-axis, indicating consistently high generation.'}\n:::\n:::\n\n\n:::::\n\nSolution template by Marc Sönnecken. The code and the outputs generated by sections of the code have been separated into tabs. For compatibility with this script, the file path and object names have been adjusted. Colors used have been adapted for accessibility.\n\n::::\n:::\n\n## Determining the Electricity Stored in Pumped Storage Plants {#sec-PumpedStorageContent}\nPrevious analyses have shown that two fundamental scenarios in the power grid must be distinguished:\n\n1. Residual load zero or negative: Marginal electricity is produced by renewable energy sources.\n\n2. Residual load positive: Marginal electricity is produced by conventional energy sources operating in load-following mode.\n\nThe annual course of electricity consumption through pumped storage plants and the corresponding scenario is shown in the following graph, which displays every 100th value of the data series `verbrauch['Pumpspeicher [MWh]']`.\n\n::: {.panel-tabset} \n\n## Plot\n\n::: {.cell execution_count=42}\n\n::: {.cell-output .cell-output-display}\n![Pumped-Storage Feed-in 2023](energiedatenanalyse_files/figure-pdf/cell-43-output-1.pdf){fig-alt='This plot shows the annual pattern of pumped-storage electricity feed-in. The colors differentiate between the predominantly conventional feed-in phases from power plants operating in load-following mode and the rare phases of renewable feed-in. Renewable feed-in occurred almost exclusively during the Christmas holidays.'}\n:::\n:::\n\n\n## Code for the Plot\n\n::: {.cell execution_count=43}\n``` {.python .cell-code}\n# Calculate residual load\nrenewables = ['Biomasse [MWh]', 'Wasserkraft [MWh]', 'Wind Offshore [MWh]', 'Wind Onshore [MWh]', 'Photovoltaik [MWh]', 'Sonstige Erneuerbare [MWh]']\n\nresidual_load = pd.DataFrame()\nresidual_load[\"Netzlast [MWh]\"] = consumption[\"Gesamt (Netzlast) [MWh]\"].copy() \nresidual_load[\"Erneuerbare [MWh]\"] = generation[renewables].sum(axis=\"columns\").copy()\nresidual_load[\"Restlast [MWh]\"] = residual_load[\"Netzlast [MWh]\"] - residual_load[\"Erneuerbare [MWh]\"]\nresidual_load = residual_load[\"Restlast [MWh]\"]\n\n# Calculate xticks\nmonths_index = generation[~generation[\"Datum von\"].dt.month.duplicated()].index\nmonth_names = generation[\"Datum von\"].iloc[months_index].dt.strftime(\"%B\") \n\n# Plot every n-th value\nstep = 100\nconsumption['Pumpspeicher [MWh]'][::step].plot(\n    figsize=(9, 6),\n    xlim=(consumption.index.min() - (len(consumption.index) / 100), consumption.index.max() * 1.01),\n    rot=45,\n    grid=True,\n    label=\"\"\n)\nplt.ylabel('Storage [MWh]', fontsize=12)\nplt.suptitle('Pumped Storage in 2023')\n\n# Set xticks\nplt.minorticks_off()\nplt.xticks(months_index, month_names)\n\n# Fill under the curve: plt.fill_between has a convenient \"where\" parameter\nplt.fill_between(\n    x=consumption['Pumpspeicher [MWh]'].index[::step],\n    y1=consumption['Pumpspeicher [MWh]'][::step],\n    label='conventional storage'\n)  # , where=residual_load[::step] > 0 would leave white spaces\nplt.fill_between(\n    x=consumption['Pumpspeicher [MWh]'].index[::step],\n    y1=consumption['Pumpspeicher [MWh]'][::step],\n    where=residual_load[::step] <= 0,\n    color='greenyellow',\n    label='renewable storage'\n)\n\nplt.legend()\nplt.show()\n```\n:::\n\n\n::: \n\nThe graphic reflects the insight gained in determining the residual and remaining load, namely that with the electricity mix realized in 2023, additional electricity demand is primarily met by conventional sources.  \n**What would the graphic look like if the feed-in from renewable energies were twice as high?**\n\n::: {#tip-pumpspeicher .callout-tip title=\"Sample solution: Storage with double renewable generation\" collapse=\"true\"}\n\nFor the calculation, it is sufficient to multiply the total electricity generation from renewable energies by 2.\n\n```\nresidual_load = pd.DataFrame()\nresidual_load[\"Netzlast [MWh]\"] = consumption[\"Gesamt (Netzlast) [MWh]\"].copy()\nresidual_load[\"Erneuerbare [MWh]\"] = generation[renewables].sum(axis=\"columns\").copy()\nresidual_load[\"Restlast [MWh]\"] = residual_load[\"Netzlast [MWh]\"] - 2 * residual_load[\"Erneuerbare [MWh]\"]\nresidual_load = residual_load[\"Restlast [MWh]\"]\n```\n\n::: {.cell execution_count=44}\n\n::: {.cell-output .cell-output-display}\n![Energy Storage in Pumped-Storage Hydropower Plants 2023](energiedatenanalyse_files/figure-pdf/cell-45-output-1.pdf){fig-alt='The annual pattern of energy storage in pumped-storage hydroelectric plants is shown with a doubling of renewable electricity production. Colors distinguish conventional storage phases by power plants operating in load-following mode and much more frequent phases of renewable storage.'}\n:::\n:::\n\n\n:::\n\n## Task: Exploratory Data Analysis\n\n::: {.border}\n\n![&nbsp;](00-bilder/960px-StauseeMooserboden_von_Tigerente_CC_BY-SA_3.0.jpg){width=\"80%\" fig-alt=\"Image of Kappruner Valley with the Mooserboden Reservoir\"}\n\nUpper and main stages of the power plant group: Mooser- and Wasserfallboden with Karlingerkees at the top left, in the background on the right the Großvenediger. Image by Tigerente is licensed under [CC BY-SA 3.0](https://creativecommons.org/licenses/by-sa/3.0/de/deed.de) and available on [wikimedia.org](https://commons.wikimedia.org/w/index.php?curid=4595972). 2008\n\n:::\n\n&nbsp;\n\n**Visualize the annual pattern of pumped storage in Austria for 2023.** Notes on downloading the data can be found in section [@sec-task-descriptive-data-analysis].\n\n::: {#wrn-DateColumn-Austria .callout-warning appearance=\"simple\" collapse=\"false\"}\n## Time Change in the Austrian Dataset\n\nIn the Austrian dataset, due to the switch from summer to winter time on the last Sunday in October, the 2 AM hour is recorded twice (and one hour is missing during the switch from winter to summer time on the last Sunday in March). The duplicated hour is marked in the dataset as 2A and 2B. (Notification from Austrian Power Grid AG, 13.08.2024)\n\n![Time change in the Austrian dataset](00-bilder/erzeugung-aut-zeitumstellung.png){fig-alt=\"A snippet from the Austrian generation dataset is shown. In the columns 'Zeit von [CET/CEST]' and 'Zeit bis [CET/CEST]', the period from 29.10.2023 02:00:00 to 29.10.2023 03:00:00 is highlighted in yellow to illustrate the anomaly described above.\"}\n\nTo read the date columns correctly, the entries need to be cleaned. One option is to replace the strings \"2A\" and \"2B\" with \"02\" using the `str.replace()` method (which will create a duplicate in the dataset).\n\n:::: {.callout-tip title=\"Example Solution: Correct Reading Using str.replace()\" collapse=\"true\"}\n\n::: {.cell execution_count=45}\n``` {.python .cell-code}\naustria_generation = pd.read_csv(\n    filepath_or_buffer=\"01-daten/AGPT_2022-12-31T23_00_00Z_2023-12-31T23_00_00Z_15M_de_2024-06-10T09_32_38Z.csv\",\n    sep=\";\", \n    decimal=\",\", \n    thousands=\".\"\n)\n\n# String replace & convert to datetime\n## Column 'Zeit von [CET/CEST]'\naustria_generation['Zeit von [CET/CEST]'] = austria_generation['Zeit von [CET/CEST]'].str.replace(pat='2A', repl='02')\naustria_generation['Zeit von [CET/CEST]'] = austria_generation['Zeit von [CET/CEST]'].str.replace(pat='2B', repl='02')\n\naustria_generation['Zeit von [CET/CEST]'] = pd.to_datetime(austria_generation['Zeit von [CET/CEST]'], format=\"%d.%m.%Y %H:%M:%S\")\n\n## Column 'Zeit bis [CET/CEST]'\naustria_generation['Zeit bis [CET/CEST]'] = austria_generation['Zeit bis [CET/CEST]'].str.replace(pat='2A', repl='02')\naustria_generation['Zeit bis [CET/CEST]'] = austria_generation['Zeit bis [CET/CEST]'].str.replace(pat='2B', repl='02')\n\naustria_generation['Zeit bis [CET/CEST]'] = pd.to_datetime(austria_generation['Zeit bis [CET/CEST]'], format=\"%d.%m.%Y %H:%M:%S\")\n\nprint(austria_generation.dtypes)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nZeit von [CET/CEST]             datetime64[ns]\nZeit bis [CET/CEST]             datetime64[ns]\nWind [MW]                              float64\nSolar [MW]                             float64\nBiomasse [MW]                          float64\nGas [MW]                               float64\nKohle [MW]                             float64\nÖl [MW]                                float64\nGeothermie [MW]                        float64\nPumpspeicher [MW]                      float64\nLauf- und Schwellwasser [MW]           float64\nSpeicher [MW]                          float64\nSonstige Erneuerbare [MW]              float64\nMüll [MW]                              float64\nAndere [MW]                            float64\ndtype: object\n```\n:::\n:::\n\n\n::::\n\n:::\n\n::: {.callout-tip title=\"Musterlösung Aufgabe explorative Datenanalyse\" collapse=\"true\"}\n\n:::: {.border}\n::::: {.panel-tabset}\n\n## Code\n\n::: {.cell execution_count=46}\n``` {.python .cell-code}\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Set the number of decimal places\npd.set_option(\"display.precision\", 2)\n\n# Load dataset into variable generation0_austria_ms\n\n# !\n# For your own use, adjust the file path to the correct location of the downloaded .csv file.\n# !\ngeneration0_austria_ms = pd.read_csv(\n    \"01-daten/AGPT_2022-12-31T23_00_00Z_2023-12-31T23_00_00Z_15M_de_2024-06-10T09_32_38Z.csv\", \n    sep=\";\", thousands=\".\", decimal=\",\", parse_dates=[0, 1], date_format=\"%d.%m.%Y %H:%M\"\n)\n\n# String replace & convert to datetime\n## Column \"Zeit von [CET/CEST]\"\ngeneration0_austria_ms['Zeit von [CET/CEST]'] = generation0_austria_ms['Zeit von [CET/CEST]'].str.replace(pat='2A', repl='02')\ngeneration0_austria_ms['Zeit von [CET/CEST]'] = generation0_austria_ms['Zeit von [CET/CEST]'].str.replace(pat='2B', repl='02')\n\ngeneration0_austria_ms['Zeit von [CET/CEST]'] = pd.to_datetime(\n    generation0_austria_ms['Zeit von [CET/CEST]'], format=\"%d.%m.%Y %H:%M:%S\"\n)\n\n## Column \"Time to [CET/CEST]\"\ngeneration0_austria_ms['Zeit bis [CET/CEST]'] = generation0_austria_ms['Zeit bis [CET/CEST]'].str.replace(pat='2A', repl='02')\ngeneration0_austria_ms['Zeit bis [CET/CEST]'] = generation0_austria_ms['Zeit bis [CET/CEST]'].str.replace(pat='2B', repl='02')\n\ngeneration0_austria_ms['Zeit bis [CET/CEST]'] = pd.to_datetime(\n    generation0_austria_ms['Zeit bis [CET/CEST]'], format=\"%d.%m.%Y %H:%M:%S\"\n)\n\nprint(generation0_austria_ms.dtypes)\nprint(generation0_austria_ms.head(10))\n\n# Create a copy of the dataset\ngeneration_c_austria_ms = generation0_austria_ms.copy()\n\nplotting_data_ms = generation_c_austria_ms.copy()\n\ngenerator_type = \"Pumpspeicher\"\n\nfig = plt.figure(figsize=(7.5, 12))\nfig.suptitle(generator_type, fontsize=12)\n\nfor i in range(1, 13):\n    plotting_data_monthly_ms = plotting_data_ms[plotting_data_ms[\"Zeit von [CET/CEST]\"].dt.month == i]\n    ax = fig.add_subplot(12, 1, i)\n    ax.plot(plotting_data_monthly_ms[generator_type + \" [MW]\"])\n    plt.margins(x=0.01)\n    ax.set_ylabel(\"MW\")\n    \n    # Create title\n    plt.title(\n        plotting_data_monthly_ms[\"Zeit von [CET/CEST]\"].head(1).dt.strftime('%B').item(), \n        fontsize=10\n    )\n    \n    # Create xticks\n    day_index = plotting_data_monthly_ms[~plotting_data_monthly_ms[\"Zeit von [CET/CEST]\"].dt.day.duplicated()].index\n    day_labels = plotting_data_monthly_ms[\"Zeit von [CET/CEST]\"].dt.day.unique()\n    plt.xticks(day_index, day_labels, fontsize=8)\n\nplt.tight_layout()\nplt.show()\n```\n:::\n\n\n## Plot\n\n::: {.cell execution_count=47}\n\n::: {.cell-output .cell-output-stdout}\n```\nZeit von [CET/CEST]             datetime64[ns]\nZeit bis [CET/CEST]             datetime64[ns]\nWind [MW]                              float64\nSolar [MW]                             float64\nBiomasse [MW]                          float64\nGas [MW]                               float64\nKohle [MW]                             float64\nÖl [MW]                                float64\nGeothermie [MW]                        float64\nPumpspeicher [MW]                      float64\nLauf- und Schwellwasser [MW]           float64\nSpeicher [MW]                          float64\nSonstige Erneuerbare [MW]              float64\nMüll [MW]                              float64\nAndere [MW]                            float64\ndtype: object\n  Zeit von [CET/CEST] Zeit bis [CET/CEST]  Wind [MW]  Solar [MW]  \\\n0 2023-01-01 00:00:00 2023-01-01 00:15:00     1000.0         0.0   \n1 2023-01-01 00:15:00 2023-01-01 00:30:00      964.0         0.0   \n2 2023-01-01 00:30:00 2023-01-01 00:45:00      956.0         0.0   \n3 2023-01-01 00:45:00 2023-01-01 01:00:00      992.0         0.0   \n4 2023-01-01 01:00:00 2023-01-01 01:15:00      880.0         0.0   \n5 2023-01-01 01:15:00 2023-01-01 01:30:00      888.0         0.0   \n6 2023-01-01 01:30:00 2023-01-01 01:45:00      948.0         0.0   \n7 2023-01-01 01:45:00 2023-01-01 02:00:00      968.0         0.0   \n8 2023-01-01 02:00:00 2023-01-01 02:15:00      956.0         0.0   \n9 2023-01-01 02:15:00 2023-01-01 02:30:00      952.0         0.0   \n\n   Biomasse [MW]  Gas [MW]  Kohle [MW]  Öl [MW]  Geothermie [MW]  \\\n0          240.0      27.6         0.0      0.0             0.07   \n1          240.0      27.6         0.0      0.0             0.07   \n2          240.0      28.0         0.0      0.0             0.07   \n3          240.0      27.6         0.0      0.0             0.07   \n4          240.0      27.6         0.0      0.0             0.07   \n5          240.0      28.4         0.0      0.0             0.07   \n6          240.0      28.8         0.0      0.0             0.07   \n7          240.0      28.0         0.0      0.0             0.07   \n8          240.0      28.8         0.0      0.0             0.07   \n9          240.0      28.4         0.0      0.0             0.07   \n\n   Pumpspeicher [MW]  Lauf- und Schwellwasser [MW]  Speicher [MW]  \\\n0            -1404.8                        2291.6           70.4   \n1            -1532.8                        2283.2           66.8   \n2            -1544.4                        2240.0          100.4   \n3            -1579.6                        2199.6           77.6   \n4            -1590.8                        2234.8           63.2   \n5            -1602.8                        2229.2           73.6   \n6            -1572.0                        2211.2           69.2   \n7            -1579.2                        2194.8           70.8   \n8            -1649.6                        2202.8           75.2   \n9            -1702.0                        2172.4           65.6   \n\n   Sonstige Erneuerbare [MW]  Müll [MW]  Andere [MW]  \n0                        0.0      100.0         22.0  \n1                        0.0      100.0         22.0  \n2                        0.0      100.0         22.0  \n3                        0.0      100.0         22.0  \n4                        0.0      100.0         22.0  \n5                        0.0      100.0         22.0  \n6                        0.0      100.0         22.0  \n7                        0.0      100.0         22.0  \n8                        0.0      100.0         22.0  \n9                        0.0      100.0         22.0  \n```\n:::\n\n::: {.cell-output .cell-output-display}\n![Annual profile of pumped storage in Austria 2023](energiedatenanalyse_files/figure-pdf/cell-48-output-2.pdf){fig-align='center' fig-alt='In 12 subplots, the monthly annual profile of pumped storage in Austria in 2023 is shown. The x-axis shows the days of each month, the y-axis the power input/output. The power curve is very volatile. On many days, pumped storage delivers power close to the maximum of around 2500 MW, but only for a few hours. Negative power levels around 1000 MW are regularly reached, meaning the pumped storage pumps water back into the reservoirs. Power levels of zero or negative values tend to occur at night during winter months, and around noon during summer.'}\n:::\n:::\n\n\n:::::\n\nSample solution by Marc Sönnecken. For compatibility with this script, the file paths and object names have been adjusted, and the graphic width reduced.\n\n::::\n:::\n\n# Inferential Data Analysis\nInferential data analysis means drawing conclusions based on data. It differs from descriptive and exploratory data analysis in that data are not only observed and compared, but also used to generate new insights.\n\nIn the exploratory analysis of the generation data, it was observed that in 2023, full supply from renewable energies is already reached at certain points. From considering the doubled renewable electricity generation in 2023 (see @tip-doubling-RE), it can be inferred that with the increasing expansion of renewable electricity production, periods of renewable overproduction will occur more frequently. The prospect of regular renewable production surpluses creates a need for electricity storage to make electricity from periods of overproduction usable during periods with positive residual load.\n\nThis section examines the resulting storage requirements.\n\n::: {.callout-warning appearance=\"simple\"}\n# Note\n\nThe following calculations are performed using the so-called \"copper plate model\" based on the aggregate data on electricity generation and consumption published by the Federal Network Agency. In reality, the available capacities for electricity transmission play an important role in designing a power system. Here, they are only considered to the extent that the data reflect the actual realized electricity generation in the German electricity system. Curtailment of renewable electricity generation is also neglected. In the first quarter of 2023, this amounted to 5.29 percent of renewable generation ([German Bundestag Drucksache 20/9016, p. 2](https://dserver.bundestag.de/btd/20/090/2009016.pdf)).\n\nElectricity trade with foreign countries is also ignored (see difference between grid load and electricity generation).\n\n:::\n\n## Background: Renewable Energy Expansion Path\n\nIn Germany, the expansion of renewable energies began in the 1990s. Since the early 2000s, renewable electricity generation has increased largely continuously.\n\n::: {.border}\n![Renewable electricity generation in Germany since 1990](00-bilder/ren-strom-d-vq-ccbysa40.png){fig-alt=\"The development of electricity generation from photovoltaics, biomass, offshore wind, onshore wind, and hydropower on an annual basis in Germany from 1990 to 2022 is shown. Until 1995, electricity generation is practically exclusively from hydropower at 20 TWh. This value remains almost unchanged until 2022 with minor fluctuations. From 1996 onwards, the addition of other forms of renewable electricity generation becomes visible. In 2001, due to the addition of onshore wind and biomass, electricity production reaches 40 TWh. Since then, approximately 10 TWh are added annually from renewable sources, on average and fairly evenly (considering weather-related fluctuations). From 2006, photovoltaics were added, and from 2014, offshore wind.\"}\n\nRenewable electricity generation in Germany since 1990 by Volker Quaschning based on data from AG Energiebilanzen ([Electricity generation by energy source (electricity mix) from 1990 to 2022 (in TWh) Germany total (XLSX)](https://ag-energiebilanzen.de/wp-content/uploads/2024/04/STRERZ_Abg_02_2024_korr.xlsx)) is licensed under [CC BY-SA 4.0](http://creativecommons.org/licenses/by-sa/4.0/) and available at <https://www.volker-quaschning.de/datserv/ren-Strom-D/index.php>. 2023\n\n:::\n\n&nbsp;\n\nThe Renewable Energy Sources Act (EEG) defines in Section 4 expansion paths for the installed capacity of solar energy, onshore wind, and biomass. The expansion path for offshore wind is regulated in Section 1 of the Offshore Wind Energy Act.\n\n::: {.callout-warning appearance=\"simple\" collapse=\"true\" title=\"Legal Basis for the Renewable Expansion Path\"}\n\n:::: {.border layout=\"[[5, 90, 5], [1], [1], [5, 90, 5], [1]]\"}\n\n&nbsp;\n\n**§ 4 Expansion Path**  \n[...]  \n1. an increase in the installed capacity of onshore wind turbines to  \n    a) 69 gigawatts by 2024,      \n    b) 84 gigawatts by 2026,      \n    c) 99 gigawatts by 2028,      \n    d) 115 gigawatts by 2030,      \n    e) 157 gigawatts by 2035, and      \n    f) 160 gigawatts by 2040  \n    [...]  \n2. an increase in the installed capacity of offshore wind turbines according to the Offshore Wind Energy Act,  \n3. an increase in the installed capacity of solar power plants to  \n    a) 88 gigawatts by 2024,  \n    b) 128 gigawatts by 2026,      \n    c) 172 gigawatts by 2028,      \n    d) 215 gigawatts by 2030,      \n    e) 309 gigawatts by 2035, and      \n    f) 400 gigawatts by 2040    \n    [...]  \n4. an installed capacity of biomass plants of 8,400 megawatts by 2030.\n\n&nbsp;  \n\nRenewable Energy Sources Act (EEG 2023) [Federal Ministry of Justice](https://www.gesetze-im-internet.de/eeg_2014/__4.html)\n\n&nbsp;\n\n&nbsp;\n\n**§ 1 Purpose and Objective of the Act**  \n[...]  \n(2) The objective of this Act is to increase the installed capacity of offshore wind turbines connected to the grid to at least 30 gigawatts by 2030, at least 40 gigawatts by 2035, and at least 70 gigawatts by 2045.\n\n&nbsp;  \n\nOffshore Wind Energy Development and Promotion Act (WindSeeG) [Federal Ministry of Justice](https://www.gesetze-im-internet.de/windseeg/BJNR231000016.html)\n\n::::\n\n:::\n\nThe federal government's expansion targets specify installed capacities for 2030 and 2035 as:\n\n  - 115 GW onshore wind by 2030, 157 GW by 2035,\n\n  - 30 GW offshore wind by 2030, 40 GW by 2035,\n\n  - 215 GW solar by 2030, 309 GW by 2035, and\n\n  - 8.4 GW biomass.\n\nThis implies a planned increase in installed capacity compared to the 2023 installed capacity of:\n\n::: {#lst-zubaufaktoren}\n\n::: {.cell execution_count=48}\n``` {.python .cell-code}\n# Calculate expansion factors for 2030 and 2035 based on installed capacity\n\nprint(f\"Onshore Wind 2030:\\t{( windonshore_growth_factor_2030 := 115 / (installed_capacity['Wind Onshore [MW]'].sum() / 1000) ):,.2f}\\n\"\n      f\"Offshore Wind 2030:\\t{( windoffshore_growth_factor_2030 := 30 / (installed_capacity['Wind Offshore [MW]'].sum() / 1000) ):,.2f}\\n\"\n      f\"Solar 2030:\\t\\t\\t{( solar_growth_factor_2030 := 215 / (installed_capacity['Photovoltaik [MW]'].sum() / 1000) ):,.2f}\\n\"\n      f\"Biomass 2030:\\t\\t{8.4 / (installed_capacity['Biomasse [MW]'].sum() / 1000):,.2f}\")\n\nprint(f\"\\n\\nOnshore Wind 2035:\\t{( windonshore_growth_factor_2035 := 157 / (installed_capacity['Wind Onshore [MW]'].sum() / 1000) ):,.2f}\\n\"\n      f\"Offshore Wind 2035:\\t{( windoffshore_growth_factor_2035 := 40 / (installed_capacity['Wind Offshore [MW]'].sum() / 1000) ):,.2f}\\n\"\n      f\"Solar 2035:\\t\\t\\t{( solar_growth_factor_2035 := 309 / (installed_capacity['Photovoltaik [MW]'].sum() / 1000) ):,.2f}\\n\"\n      f\"Biomass 2035:\\t\\t{8.4 / (installed_capacity['Biomasse [MW]'].sum() / 1000):,.2f}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nOnshore Wind 2030:\t2.00\nOffshore Wind 2030:\t3.69\nSolar 2030:\t\t\t3.41\nBiomass 2030:\t\t0.99\n\n\nOnshore Wind 2035:\t2.73\nOffshore Wind 2035:\t4.92\nSolar 2035:\t\t\t4.90\nBiomass 2035:\t\t0.99\n```\n:::\n:::\n\n\n:::\n\nBy 2030, onshore wind power production is planned to be doubled, while offshore wind and photovoltaic production are planned to increase by a factor of 3.5. By 2035, onshore wind is expected to nearly triple, and offshore wind and photovoltaic production are expected to quintuple. Biomass expansion is not planned. The growth factors are stored in an object.\n\n::: {.callout-warning appearance=\"simple\"}\n## Power Grid Development Plan\n\nIn addition to generation capacity, the electricity transmission grid is also to be expanded. These plans are documented in the Power Grid Development Plan, which is updated every two years by the four transmission system operators in coordination with the Federal Network Agency.\n\nThe current and previous grid development plans can be accessed at <https://www.netzentwicklungsplan.de/>.\n:::\n\n## Background: Energy Storage\nEnergy storage systems store electricity during periods of surplus and release it during periods of deficit. Different types of energy storage and their applications are presented in the following video. Storage types differ fundamentally in terms of capacity and charge/discharge power.\n\n::: {.border}\n{{< video https://www.youtube.com/watch?v=yiJ1vAAJnVA >}}\n\nEnergy Technology. 14 Energy Storage. 14.02 Key Figures by Henrik te Heesen is licensed under [CC BY-SA 3.0](https://creativecommons.org/licenses/by-sa/3.0/deed.de) and available on [YouTube](https://www.youtube.com/watch?v=yiJ1vAAJnVA). 2020\n:::\n\n::: {#imp-keyFigures-energyStorage .callout-important}\n# Selected Key Figures of Energy Storage Systems\n\n:::: {.border}\n\n- Nominal Storage Capacity: The total amount of energy that can be withdrawn from the storage system.\n\n- Usable Storage Capacity: The portion of nominal capacity that can be used without causing damage.\n\n- Depth of Discharge (DoD): Difference between the maximum and minimum allowed state of charge.\n\n- State of Charge (SoC): Ratio of currently stored energy to nominal capacity, usually expressed as a percentage.\n\n- Efficiency: Effectiveness of storage considering charging, discharging, and losses (such as self-discharge).\n\nFurther key figures are introduced in the following video:\n\n{{< video https://www.youtube.com/watch?v=0-PRS2naETE >}}\n\nEnergy Technology. 14 Energy Storage. 14.03 Key Figures and Definitions by Henrik te Heesen is licensed under [CC BY-SA 3.0](https://creativecommons.org/licenses/by-sa/3.0/deed.de) and available on [YouTube](https://www.youtube.com/watch?v=0-PRS2naETE). 2020\n::::\n\n:::\n\n## Calculating Storage Size\nThe following section develops the basic principles of storage design and the methods for calculating storage size. All considerations are based on the residual load curve. Values below zero correspond to a surplus of renewable generation, while values above zero correspond to a grid load that must be served by dispatchable power plants or storage. The residual load is determined as follows:\n\n::: {.cell execution_count=49}\n``` {.python .cell-code}\nrenewables = ['Biomasse [MWh]', 'Wasserkraft [MWh]', 'Wind Offshore [MWh]', 'Wind Onshore [MWh]', 'Photovoltaik [MWh]', 'Sonstige Erneuerbare [MWh]']\n\nresidual_load = pd.DataFrame()\nresidual_load[\"Netzlast [MWh]\"] = consumption[\"Gesamt (Netzlast) [MWh]\"].copy()\nresidual_load[\"Erneuerbare [MWh]\"] = generation[renewables].sum(axis=\"columns\").copy()\nresidual_load[\"Restlast [MWh]\"] = residual_load[\"Netzlast [MWh]\"] - residual_load[\"Erneuerbare [MWh]\"]\nresidual_load = residual_load[\"Restlast [MWh]\"]\n```\n:::\n\n\nTo better understand the scale of the calculations, the storage size is put in relation to the existing pumped-storage capacity of 37.4 GWh.\n\n::: {.cell execution_count=50}\n``` {.python .cell-code}\npumped_storage_capacity_MWh = 37.4 * 1000\n```\n:::\n\n\n&nbsp;\n\n::: {#tip-Testdaten .callout-tip collapse=\"false\" title=\"Funktionsentwicklung mit Testdaten\"}\n\n\n\n\nThe functions developed below generally offer an option to output calculation results, but due to the length of the data series, displaying the residual load is not meaningful. As a result, the data series itself as well as intermediate and final results of the calculations, including any existing errors, cannot be easily reviewed. Therefore, for function development, it is recommended to work with test data. This allows calculations to be performed more quickly, and intermediate results and final outputs can be displayed for verification if needed. The following functions were developed using randomly generated test data.\n\nIn the following code block, a residual load curve of ten random values is generated. By adjusting the values for `a` and `b`, the outcome can be controlled. The output records the sum of the data series. A negative value indicates that the simulated residual load curve shows a surplus production of renewable energy. A positive value indicates that the positive residual load along the simulated curve exceeds the renewable surplus production.\n\nThe code block also creates a static data series. This serves to store test data that led to errors. The `random_data` series is output as a list so that it can be copied and pasted into the static data series for further testing.\n\n::: {.cell execution_count=51}\n``` {.python .cell-code}\nimport random as rd\nimport pandas as pd\n\n# Generate a list of 10 random integers between -20 and 20\nrandom_data = []\nfor i in range(10):\n    random_data.append(rd.randint(a=-20, b=20))\n\n# Convert the list to a pandas Series with float type\nrandom_data = pd.Series(random_data, dtype='float')\nprint(f\"random_data: {list(random_data)}\\nSum of random_data: {random_data.sum()}\\n\")\n\n# Define a static dataset as a pandas Series with float type\nstatic_data = pd.Series([8, -14, -7, 1, 3, -6, 5, -20, -2, 12], dtype='float')\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nrandom_data: [14.0, -12.0, 3.0, -18.0, 12.0, -7.0, 17.0, -9.0, 18.0, 16.0]\nSum of random_data: 34.0\n\n```\n:::\n:::\n\n\n:::\n\n### Surplus or Deficit of Renewable Energy\nThe required size of the electricity storage depends, on one hand, on the ratio of the amount of renewable surplus production to the residual load that must be served from the storage. On the other hand, the efficiency η (Greek letter Eta) of the storage during charging and discharging plays a role.\n\n::: {layout=\"[50, 50]\"}\n\n::: {.cell execution_count=52}\n\n::: {.cell-output .cell-output-display}\n![](energiedatenanalyse_files/figure-pdf/cell-53-output-1.pdf){fig-alt='Two simplified residual load curves, each consisting of two bars, are shown over the course of a year. The x-axis represents the 365 days of the year, and the y-axis represents the residual load from minus 1 to 1. In the top plot, the annual course with a renewable energy deficit is displayed. In the first half of the year, the residual load is negative at -0.5, in the second half positive at 1. Each is represented by a single bar of the corresponding height. The first bar with negative values is colored and hatched diagonally upward to the left to indicate the storage phase. The second bar with positive values is hatched diagonally downward to the right up to half the height (0.5) to indicate the discharge phase, while the area from 0.5 to 1 is unfilled, representing residual load served by conventional power plants. In the bottom plot, the annual course with a renewable energy surplus is shown. In the first half of the year, the residual load is -1, in the second half 0.5. The first bar with negative values is unfilled and hatched diagonally upward to the left up to half the height (-0.5) to indicate the storage phase. The second bar with positive values (0.5) is colored to indicate required storage and hatched diagonally downward to indicate discharge.'}\n:::\n:::\n\n\nRenewable Electricity Production: Surplus or Deficit?\n: If the sum of renewable surplus production is smaller than the residual load to be served from storage, the required storage capacity corresponds to the sum of the renewable surplus production.\n: If the sum of renewable surplus production is larger than the residual load to be served from storage, the required storage capacity corresponds to the sum of the residual load to be served.\n: Whether there is a surplus or a deficit of renewable electricity production can be determined from the sign of the summed residual load. A negative sign indicates a renewable electricity surplus, while a positive sign indicates a renewable electricity deficit.\n\n::: {.cell execution_count=53}\n\n::: {.cell-output .cell-output-display}\n![](energiedatenanalyse_files/figure-pdf/cell-54-output-1.pdf){fig-alt='A chart with two bars shows a simplified annual residual load with charging and discharging efficiency. The x-axis represents the 365 days of the year, the y-axis the residual load from minus 1 to 1. In the first half of the year, the residual load is negative at minus 1, in the second half positive at 1. The first bar with negative values is colored up to minus 0.8 and hatched upward to indicate storage size and the charging phase. The area from minus 0.8 to minus 1 is dotted, representing charging losses at an efficiency of 0.8. The second bar with positive values is hatched downward up to 0.64 to indicate the discharging phase. The area from 0.64 to 0.8 is large-dotted, representing discharging losses at an efficiency of 0.8. The area from 0.8 to 1 is plain white and corresponds, like the discharging loss area, to residual load handled by peaking power plants.'}\n:::\n:::\n\n\nEfficiency\n: The charging efficiency reduces the available surplus power. If the sum of renewable surplus production is smaller than the residual load to be met from the storage, the storage can be sized smaller by the charging efficiency.\n: The discharging efficiency (including storage losses) increases the load to be met by the storage. If the sum of renewable surplus production is greater than the residual load to be met from the storage, the storage must be sized larger by the discharging efficiency.\n\n:::\n\n#### Calculation\nWhether phases of renewable overproduction or phases of positive residual load dominate over the course of a year can be determined using the following functions.\n\n::: {.panel-tabset}\n\n## without efficiency\n\n::: {.cell execution_count=54}\n``` {.python .cell-code}\n# Detect excess renewable energy\n## Input: data = pd.Series(data, dtype='float')\n## Processing: sum is calculated over the pd.Series\n## Output: returns the boolean value of data.sum() < 0\n\ndef check_renewable_excess(data):\n  \n  return data.sum() < 0\n\ncheck_renewable_excess(residual_load)\n```\n\n::: {.cell-output .cell-output-display execution_count=53}\n```\nnp.False_\n```\n:::\n:::\n\n\n## with efficiency\n\n::: {.cell execution_count=55}\n``` {.python .cell-code}\n# Determine renewable energy surplus, given a charge and discharge efficiency\n## Input: data = pd.Series(data, dtype='float'), charge_efficiency = 1, discharge_efficiency = 1\n## Processing: values less than 0 are multiplied by the charge efficiency\n## Processing: values greater than 0 are divided by the discharge efficiency\n## Processing: the sum is computed over the pd.Series\n## Output: returns True if data_efficiency_adjusted.sum() < 0, otherwise False\n\ndef check_RE_surplus(data, charge_efficiency=1, discharge_efficiency=1):\n    data_efficiency_adjusted = data.copy()\n    \n    data_efficiency_adjusted[data_efficiency_adjusted < 0] = (\n        data_efficiency_adjusted[data_efficiency_adjusted < 0] * charge_efficiency\n    )\n    data_efficiency_adjusted[data_efficiency_adjusted > 0] = (\n        data_efficiency_adjusted[data_efficiency_adjusted > 0] / discharge_efficiency\n    )\n    \n    return data_efficiency_adjusted.sum() < 0\n\ncheck_RE_surplus(residual_load, charge_efficiency=0.9, discharge_efficiency=0.9)\n```\n\n::: {.cell-output .cell-output-display execution_count=54}\n```\nnp.False_\n```\n:::\n:::\n\n\n:::\n\nAs known from the marginal electricity analysis in section [@sec-PumpedStorageContent], there was no surplus of renewable electricity production in 2023.\n\n### Cyclicality\nOver the course of a year, the sequence of periods with renewable surpluses and periods with positive residual load affects how large a storage system needs to be.\n\n::: {layout=\"[50, 50]\"} \n\n::: {.cell execution_count=56}\n\n::: {.cell-output .cell-output-display}\n![](energiedatenanalyse_files/figure-pdf/cell-57-output-1.pdf){fig-alt='Two simplified residual load curves, each consisting of four bars, are shown for two consecutive years in two graphs. The x-axis represents the 730 days of the two consecutive years, the y-axis the residual load from -1 to 1. The upper graph shows the two-year residual load with a deficit of renewable surplus generation. In the first half-year, the positive residual load is 1, which cannot yet be covered by stored electricity. In the second half-year, the residual load is -0.5. This bar is colored and hatched upward, indicating the required storage capacity and the charging phase. The second year\\'s pattern repeats. In the third half-year, the positive residual load is again 1. The third bar with positive values of 1 is hatched downward from 0.5 to 0, showing the discharge phase. The area from 0.5 to 1 is unfilled, corresponding to residual load served by dispatchable power plants. In the fourth half-year, the negative residual load is again -0.5, hatched upward to indicate recharge. The lower graph shows the two-year residual load with a surplus of renewable generation. In the first half-year, the positive residual load is 0.5, not yet covered by stored electricity. In the second half-year, the residual load is -1, hatched upward to indicate charging up to -0.5; the area from -0.5 to -1 is unmarked, representing unused renewable surplus. The second year repeats. In the third half-year, the positive residual load is 0.5, hatched downward to indicate discharge. In the fourth half-year, the residual load is -1, hatched upward to indicate charging, while the area from -0.5 to -1 remains unmarked.'}\n:::\n:::\n\n\nOrder Dependence\n: If only a single year is considered, the order of renewable over- and underproduction determines how much electricity can be stored. In the worst-case scenario, there is a positive residual load in the first half of the year (but the storage is still empty) and renewable overproduction occurs in the second half of the year (which would no longer be absorbed in the second half).\n: Order dependence can be resolved by considering two consecutive years. In the first year, the storage is connected to the grid empty. The second year begins with the storage filled by the surplus production from the previous year.\n\n::: {.cell execution_count=57}\n\n::: {.cell-output .cell-output-display}\n![](energiedatenanalyse_files/figure-pdf/cell-58-output-1.pdf){fig-alt='Two simplified annual profiles of residual load are shown in two charts. The x-axis represents the 365 days of the year, and the y-axis shows the residual load from minus 1 to 1. The top chart depicts the annual profile of residual load for a full cycle of complete charging and discharging with two bars. In the first half of the year, the residual load is minus 1; the bar is colored and hatched upwards. The coloring indicates the required storage size, and the upward hatching indicates the charging phase. In the second half of the year, the residual load is 1. This bar is hatched downwards to the right to indicate the discharging phase. The bottom chart shows the annual profile of residual load for two full cycles with four bars. In the first quarter, the residual load is minus 1; the bar is colored and hatched upwards. The coloring indicates the required storage size, which is half of that in the top chart, and the upward hatching indicates the charging phase. In the second quarter, the residual load is 1, hatched downwards to the right to indicate discharging. The pattern of charging and discharging at 1 repeats in the second half of the year.'}\n:::\n:::\n\n\nNumber of Full Cycles\n: The required size of the energy storage depends on the distribution of the residual load and the number of full cycles achieved. A full cycle means that a storage system is completely charged and then fully discharged.\n: In the worst-case scenario, only a single charge/discharge cycle occurs. In this case, the required storage size equals the sum of the renewable surplus production.\n: The more frequently charging and discharging cycles alternate, the smaller the required storage size. This corresponds to the sum of the renewable surplus production divided by the number of full cycles.\n\n::: {.cell execution_count=58}\n\n::: {.cell-output .cell-output-display}\n![](energiedatenanalyse_files/figure-pdf/cell-59-output-1.pdf){fig-alt='Two simplified annual residual load profiles with partial cycles are shown in two plots. The x-axis represents the 365 days of the year, and the y-axis the residual load from -1 to 1. In the top plot, the annual residual load during a renewable energy deficit is shown with four bars. In the first quarter, the negative residual load is -0.5; the bar is colored and hatched upward, indicating the storage phase. In the second quarter, the positive residual load is 0.25, marking the start of partial discharge, so the bar is hatched downward. In the third quarter, the negative residual load is again -0.5, hatched to indicate the storage phase. The area from 0 to -0.25 is uncolored, showing partial storage where previously withdrawn electricity is replenished. The area from -0.25 to -0.5 is colored, adding additional electricity to storage. The total stored electricity is now 0.75. In the fourth quarter, the positive residual load is 1. The area from 0 to 0.75 is hatched downward, indicating storage discharge. The area from 0.75 to 1 is unmarked (white), representing residual load covered by conventional power plants. In the bottom plot, the annual residual load during a renewable energy surplus is shown with four bars. In the first quarter, the negative residual load is -1, hatched upward for storage. In the second quarter, the positive residual load is 0.25, marking the start of partial discharge with downward hatching. In the third quarter, the negative residual load is -1; up to -0.25 it is hatched upward to indicate storage replenishment, while -0.25 to -1 is unmarked, representing surplus electricity not stored. In the fourth quarter, the positive residual load is 1; the bar is colored for required storage size and hatched downward for discharge.'}\n:::\n:::\n\n\nPartial Cycles\n: The distribution of occurring partial cycles also reduces the required storage capacity.  \n: If the sum of renewable surplus production is smaller than the residual load that the storage needs to cover, the required storage capacity corresponds to the minimum of the cumulative sum of the residual load, provided it is never set above 0 (exceeding this point would indicate the moment when the storage is empty).  \n: If the sum of renewable surplus production is greater than the residual load that the storage needs to cover, the required storage capacity corresponds to the maximum of the cumulative sum of the residual load, provided it is never set below 0 (falling below this point would indicate the moment when the storage is oversized).  \n\n:::\n\n#### Calculation\nThe storage capacity is calculated from the annual profile of the residual load. To avoid dependency on the time at which the storage is connected to the grid, the dataset is iterated twice (resolving any order-dependency). The required storage capacity is calculated using the cumulative sum of the residual load. If the sum of renewable surplus production is smaller than the sum of residual load that the storage needs to cover, the cumulative sum is never set above 0. Exceeding this upper limit would be the moment when the storage is empty and positive residual load can no longer be served. Conversely, if the sum of renewable surplus production is greater than the sum of residual load to be covered, the cumulative sum is never set below 0. Falling below this limit would be the moment when the storage is oversized and energy is held that is never consumed by positive residual load throughout the year.\n\n::: {.panel-tabset}\n\n## without efficiency\n\n::: {.cell execution_count=59}\n``` {.python .cell-code}\n# Calculate storage size\n## Input: data = pd.Series(data, dtype='float'), output = False\n## Processing: call the function check_RE_surplus to distinguish between upper limit = 0 (storage empty) and lower limit = 0 (storage oversized)\n## Processing: data is concatenated twice into data_x2. For data_x2, the capped cumulative sum at 0 is calculated and storage size is determined.\n## Output: if output = False, the storage size (float) is returned; if output = True, the sum of data and the storage size are printed\n\ndef calculate_storage_capacity(data, output=False):\n\n    data_x2 = pd.concat([data, data])\n\n    surplus = check_RE_surplus(data)\n    \n    if surplus:\n        \n        # calculate capped cumulative sum\n        capped_cumsum = []\n        total = 0\n\n        for i in data_x2:\n            total += i \n\n            # check lower limit\n            if total < 0:\n                total = 0\n            \n            capped_cumsum.append(total)\n\n        storage_capacity = max(capped_cumsum)\n    \n    else:\n\n        # calculate capped cumulative sum\n        capped_cumsum = []\n        total = 0\n\n        for i in data_x2:\n            total += i\n\n            # check upper limit\n            if total > 0:\n                total = 0\n            \n            capped_cumsum.append(total)\n\n        storage_capacity = abs(min(capped_cumsum))\n\n    if output:  # output = True\n        print(f\"\\nSum of data: {data.sum()}\\nStorage size: {storage_capacity}\")\n        \n    else:  # output = False\n        return storage_capacity\n\nstorage_2023 = calculate_storage_capacity(residual_load, output=False)\n\nprint(f\"Required storage size 2023: {storage_2023:,.1f} MWh\\nThis corresponds to {storage_2023 / pumped_storage_capacity_MWh:,.1f} pumped-storage equivalents.\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nRequired storage size 2023: 119,667.0 MWh\nThis corresponds to 3.2 pumped-storage equivalents.\n```\n:::\n:::\n\n\n## with Efficiency\n\n::: {.cell execution_count=60}\n``` {.python .cell-code}\n# Calculate storage size\n## Input: data = pd.Series(data, dtype='float'), charge_efficiency = 1, discharge_efficiency = 1, output = False\n## Processing: call the function check_RE_surplus to distinguish between upper limit = 0 (storage empty) and lower limit = 0 (storage oversized)\n## Processing: data is concatenated twice to data_x2. For data_x2, the capped cumulative sum at 0 is calculated and the storage size is determined.\n## Output: if output = False, the storage size (float) is returned; if output = True, the sum of data and the storage size are printed\n\ndef calculate_storage_capacity(data, charge_efficiency=1, discharge_efficiency=1, output=False):\n\n    data_x2 = pd.concat([data, data])\n\n    surplus = check_RE_surplus(data, charge_efficiency, discharge_efficiency)\n    \n    if surplus:\n        \n        # Calculate capped cumulative sum\n        capped_cumsum = []\n        total = 0\n\n        for i in data_x2:\n            if i < 0:\n                total += i * charge_efficiency\n            else:\n                total += i / discharge_efficiency\n\n            # Check lower limit\n            if total < 0:\n                total = 0\n            \n            capped_cumsum.append(total)\n\n        storage_capacity = max(capped_cumsum)\n    \n    else:  # Underproduction\n\n        # Calculate capped cumulative sum\n        capped_cumsum = []\n        total = 0\n\n        for i in data_x2:\n            if i < 0:\n                total += i * charge_efficiency\n            else:\n                total += i / discharge_efficiency\n\n            # Check upper limit\n            if total > 0:\n                total = 0\n            \n            capped_cumsum.append(total)\n\n        storage_capacity = abs(min(capped_cumsum))\n\n    if output:  # output = True\n        print(f\"\\nSum of data: {data.sum()}\\nStorage size: {storage_capacity}\")\n\n    else:  # output = False\n        return storage_capacity\n\nstorage_2023capacity = calculate_storage_capacity(residual_load, charge_efficiency=0.9, discharge_efficiency=0.9, output=False)\n\nprint(f\"Required storage size 2023: {storage_2023:,.1f} MWh\\nThis corresponds to {storage_2023 / pumped_storage_capacity_MWh:,.1f} pumped-storage equivalents.\")   \n```\n\n::: {.cell-output .cell-output-stdout}\n```\nRequired storage size 2023: 119,667.0 MWh\nThis corresponds to 3.2 pumped-storage equivalents.\n```\n:::\n:::\n\n\n:::\n\n#### Annual Storage Profile\nAfter determining the storage capacity, the annual storage profile for the first and second year can be calculated and visualized. The annual storage profile for the second year represents the stable equilibrium, which can be repeated indefinitely for a given residual load curve.\n\n  - Input: The function receives a residual load curve as input. Additionally, a storage capacity can be provided; otherwise, it is determined by calling the function `calculate_storage_capacity()`.\n\n  - Processing: Starting with an empty storage, the residual load series is traversed element by element twice. Negative values are stored until the storage capacity is reached. Positive values are withdrawn from the storage until the storage level reaches zero. In the function extended with charge and discharge efficiencies, stored values are multiplied by the charge efficiency (0.9) and withdrawn values are divided by the discharge efficiency (0.9).\n\n  - Output: If `output = False`, the function returns a tuple. Position 0 contains the storage capacity, position 1 the annual profile for year 1 as a pd.Series, and position 2 the annual profile for year 2 as a pd.Series. The annual profiles are subsequently visualized in a panel. If `output = True`, the cumulative sum of the residual load and the storage capacity, as well as the provided residual load curve, storage levels, and available capacity for year 1 and year 2, are printed with `print()`—this is typically useful only for test data.\n\n::: {.panel-tabset}\n\n## without efficiency\n\n::: {.cell execution_count=61}\n``` {.python .cell-code}\n# Calculate annual storage profile\n## Input: data = pd.Series(data, dtype='float'), storage_capacity=-1, output=False\n## Processing: If storage_capacity=-1, the storage size is determined with the functicapacity(data)\n## Processing: data is concatenated twice to data_x2.\n## Processing: Based on the storage capacity, the storage level and free capacity are calculated for all data values for year 1 and all following years.\n## Output: If output=False, returns a tuple with storage_capacity (float), storage_level_year1 (pd.Series), storage_level_year2 (pd.Series)\n## Output: If output=True, also returns cumulative residual load, storage capacity, residual load curve, storage levels, and free storage capacity for year 1 and year 2\n\ndef calculate_annual_storage(data, storage_capacity=-1, output=False):\n\n    data_x2 = pd.concat([data, data])\n\n    if storage_capacity == -1:\n        storage_capacity = calculate_storage_capacity(data) \n\n    # Calculate annual storage profile\n    annual_storage = []\n    storage_level = []\n    free_capacity = storage_capacity  # storage is empty\n    for i in data_x2:\n\n        if (storage_capacity - free_capacity) - i < 0:  # load without prior storage cannot be supplied\n            free_capacity = storage_capacity\n\n        elif free_capacity + i < 0:  # if storage is full, surplus must be discarded\n            free_capacity = 0\n\n        else:  # charging/discharging\n            free_capacity += i\n\n        annual_storage.append(free_capacity)\n        storage_level.append(storage_capacity - free_capacity)\n\n    if output:  # output=True\n        dataset = pd.DataFrame({\n            'Residual Load': data,\n            'Storage Level Year1': storage_level[:len(annual_storage)//2],\n            'Free Capacity Year1': annual_storage[:len(annual_storage)//2],\n            'Storage Level Following Years': storage_level[len(annual_storage)//2:],\n            'Free Capacity Following Years': annual_storage[len(annual_storage)//2:]\n        })\n\n        print(f\"\\nSum of data: {data.sum()}\\nStorage Capacity: {storage_capacity}\")\n        print(dataset)\n\n    else:  # output=False\n        return storage_capacity, pd.Series(storage_level[:len(annual_storage)//2]), pd.Series(storage_level[len(annual_storage)//2:])\n\nstorage_2023 = calculate_annual_storage(residual_load, output=False)\n```\n:::\n\n\n## Plot without Efficiency\n\n::: {.cell execution_count=62}\n\n::: {.cell-output .cell-output-display}\n![Residual load 2023 and annual cycle of a storage with efficiency 1](energiedatenanalyse_files/figure-pdf/cell-63-output-1.pdf){fig-alt='The graphic shows the residual load for the year 2023. This is mostly positive and only negative at a few points during the year. Around the Christmas holidays, there is a longer period of negative residual load. In addition, the annual cycle of the storage is shown, storing all renewable production surpluses and discharging again during positive residual load. The interpretation of the annual cycle follows in the further text.'}\n:::\n:::\n\n\n## Code for the plot without efficiency\n\n::: {.cell execution_count=63}\n``` {.python .cell-code}\n# Load data\nannual_storage_year1 = storage_2023[1]\nannual_storage_year2 = storage_2023[2]\n\n# Create xticks\nmonth_index = generation[~generation[\"Datum von\"].dt.month.duplicated()].index\nmonth_names = generation[\"Datum von\"].iloc[month_index].dt.strftime(\"%B\") \n\n# Create graphic with three subplots\nfont_size = 10\n\nfig, (ax1, ax2, ax3) = plt.subplots(3, 1, figsize = (7.5, 6), height_ratios = [2, 1, 1], sharex = True, layout = 'tight')\nplt.suptitle('Residual load 2023 and annual cycle of a storage with efficiency 1')\nplt.xticks(month_index, month_names, rotation = 45);\nplt.minorticks_off()\nplt.setp([ax1, ax2, ax3], xlim = (residual_load.index.min() - len(residual_load.index) / 100, residual_load.index.max() * 1.01))\nplt.setp([ax2, ax3], ylim = (0, max(max(annual_storage_year1), max(annual_storage_year2)) * 1.1))\n\n## plot residual load\nax1.plot(residual_load, label = \"Residual load\")\nax1.grid()\nax1.set_ylabel('MWh')\nax1.legend()\n\n## plot annual_storage_year1\nax2.plot(annual_storage_year1, color = 'black', linestyle = '-', label = 'Battery Year 1')\nax2.grid()\nax2.set_ylabel('MWh')\nax2.legend()\n\n## plot annual_storage_year2\nax3.plot(annual_storage_year2, color = 'black', linestyle = '-', label = 'Battery Year 2')\nax3.tick_params(axis = 'x', rotation = 45)\nax3.set_ylabel('MWh')\nax3.grid()\nax3.legend()\n\nplt.show()\n```\n:::\n\n\n## With Efficiency\n\n::: {.cell execution_count=64}\n``` {.python .cell-code}\n# Calculate annual storage cycle\n## Input: data = pd.Series(data, dtype = 'float'), storage_capacity = -1, charge_efficiency = 1, discharge_efficiency = 1, output = False\n## Processing: If storage_capacity = -1, the storage size is calculated with the functicapacity(data).\n## Processing: data is concatenated twice to data_x2.\n## Processing: Based on the storage size, the state of charge and free capacity are calculated for all values of data for Year1 and all following years.\n## Output: If output is False, a tuple of storage_capacity (float), state of charge Year1 (pd.Series), state of charge Year2 (pd.Series) is returned.\n## Output: If output is True, the cumulative sum of the residual load, the storage size, the residual load curve, the states of charge and free capacities for Year1 and Year2 are returned.\n\ndef calculate_annual_storage(data, storage_capacity = -1, charge_efficiency = 1, discharge_efficiency = 1, output = False):\n\n  data_x2 = pd.concat([data, data])\n\n  if storage_capacity == -1:\n    storage_capacity = calculate_storage_capacity(data, charge_efficiency, discharge_efficiency) \n\n  annual_storage = []\n  storage_state = []\n  free_capacity = storage_capacity # storage is empty \n  for i in data_x2:\n\n    if i > 0: # residual load\n\n      # demand without corresponding previous charging cannot be fully supplied, storage then empty\n      if (storage_capacity - free_capacity) - i / discharge_efficiency < 0:\n        free_capacity = storage_capacity\n\n      else: # discharging\n        free_capacity += i / discharge_efficiency # here too much can be discharged\n        if free_capacity > storage_capacity:\n          free_capacity = storage_capacity\n    \n    else: # i <= 0 renewable surplus\n      \n      # if storage is full, surplus must be discarded\n      if free_capacity + i * charge_efficiency < 0: \n        free_capacity = 0\n      \n      else: # charging\n        free_capacity += i * charge_efficiency\n\n    annual_storage.append(free_capacity)\n    storage_state.append(storage_capacity - free_capacity)\n\n  if output: # output = True\n\n    dataset = pd.DataFrame({'Residual load': data, 'State of charge Year1': storage_state[ : len(annual_storage) // 2 ], 'Free capacity Year1': annual_storage[ : len(annual_storage) // 2 ], 'State of charge following years': storage_state[ len(annual_storage) // 2 : ], 'Free capacity following years': annual_storage[ len(annual_storage) // 2 : ]})\n\n    print(f\"\\nSum data: {data.sum()}\\nStorage size: {storage_capacity}\")\n    print(dataset)\n\n  else: # output = False\n    return storage_capacity, pd.Series(storage_state[ : len(annual_storage) // 2 ]), pd.Series(storage_state[ len(annual_storage) // 2 : ])\n\nstorage_2023_eff_90_90 = calculate_annual_storage(residual_load, charge_efficiency = 0.9, discharge_efficiency = 0.9, output = False)\n```\n:::\n\n\n## Plot with Efficiency\n\n::: {.cell execution_count=65}\n\n::: {.cell-output .cell-output-display}\n![Residual load 2023 and annual cycle of a storage with charge and discharge efficiency 0.9](energiedatenanalyse_files/figure-pdf/cell-66-output-1.pdf){fig-alt='The graphic shows the residual load for the year 2023. This is mostly positive and only negative at a few points during the year. Around the Christmas holidays, there is a longer period of negative residual load. In addition, the annual cycle of the storage with a charging and discharging efficiency of 0.9 is shown, storing all renewable production surpluses and discharging again during positive residual load. The interpretation of the annual cycle follows in the further text.'}\n:::\n:::\n\n\n## Code for the plot with efficiency\n\n::: {.cell execution_count=66}\n``` {.python .cell-code}\n# Load data\nannual_storage_year1 = storage_2023_eff_90_90[1]\nannual_storage_year2 = storage_2023_eff_90_90[2]\n\n# Create xticks\nmonth_index = generation[~generation[\"Datum von\"].dt.month.duplicated()].index\nmonth_names = generation[\"Datum von\"].iloc[month_index].dt.strftime(\"%B\") \n\n# Create graphic with three subplots\nfont_size = 10\n\nfig, (ax1, ax2, ax3) = plt.subplots(3, 1, figsize = (7.5, 6), height_ratios = [2, 1, 1], sharex = True, layout = 'tight')\nplt.suptitle('Residual load 2023 and annual cycle of a storage with charge and discharge efficiency 0.9')\nplt.xticks(month_index, month_names, rotation = 45);\nplt.minorticks_off()\nplt.setp([ax1, ax2, ax3], xlim = (residual_load.index.min() - len(residual_load.index) / 100, residual_load.index.max() * 1.01))\nplt.setp([ax2, ax3], ylim = (0, max(max(annual_storage_year1), max(annual_storage_year2)) * 1.1))\n\n## plot residual load\nax1.plot(residual_load, label = \"Residual load\")\nax1.grid()\nax1.set_ylabel('MWh')\nax1.legend()\n\n## plot annual_storage_year1\nax2.plot(annual_storage_year1, color = 'black', linestyle = '-', label = 'Battery Year 1')\nax2.grid()\nax2.set_ylabel('MWh')\nax2.legend()\n\n## plot annual_storage_year2\nax3.plot(annual_storage_year2, color = 'black', linestyle = '-', label = 'Battery Year 2')\nax3.tick_params(axis = 'x', rotation = 45)\nax3.set_ylabel('MWh')\nax3.grid()\nax3.legend()\n\nplt.show()\n```\n:::\n\n\n:::\n\nThe required storage capacity results from the renewable generation surpluses during the Christmas holidays. These capacities are hardly used during the rest of the year, so the storage remains empty most of the time. The annual profile for the first and second year is visually identical. This can easily be checked with `pd.Series1.equals(pd.Series2)`. If charging and discharging efficiencies are considered, the charged and discharged energy – and thus the required storage capacity – are reduced. \n\n#### Calculate number of cycles\nBased on the storage size and the annual profile of the storage, the number of cycles can be calculated for the first year and for all subsequent years. One cycle corresponds to a complete charge and discharge of the storage or an equivalent number of partial charge cycles. The number of cycles therefore results from the sum of the charged and discharged energy in the annual profile of the storage, divided by the storage size and by 2.\n\n  - **Input:** The function can be provided with a tuple consisting of a storage size at position 0 and storage annual profiles for year 1 and year 2 at positions 1 and 2. Otherwise, these are determined by calling the function `calculate_storage_annual_profile` (without or with charging and discharging efficiency).\n\n  - **Processing:** To determine the charged and discharged energy, the method `pd.Series.diff()` is used for the storage annual profiles to compute the element-wise difference of each value to its predecessor (sliding difference). For example, for the sequence `1, 4, -6, 2`, the element-wise difference is `NaN, 3, -10, 8`. Since the first value has no predecessor, the difference is NaN. Therefore, a zero is prepended to the annual profile in year 1 (because the storage starts empty when connected to the grid), and for year 2 the last value from year 1 is prepended (because the storage starts into the second year with that charge level). The sequence for year 2 would then look like this: `2, 1, 4, -6, 2`. The element-wise difference would be: `NaN, -1, 3, -10, 8`. Afterwards, the values are converted to absolute values and summed. The instruction is thus: `pd.Series.diff().abs().sum()`. To calculate the number of cycles, the sum of the charged and discharged energy is divided by the storage size and by 2.\n  \n  - **Output:** If `output = False`, the function returns a tuple with the number of cycles for year 1 and year 2. If `output = True`, the output is printed using `print()`.\n\n::: {.panel-tabset}\n\n## without efficiency\n\n::: {.cell execution_count=67}\n``` {.python .cell-code}\n# Calculate number of cycles\n## Input: data = pd.Series(data, dtype='float'), output = False\n## Input: If the input is a tuple {'storage_capacity': float, 'storage_profile_year1': pd.Series, 'storage_profile_year2': pd.Series}, the number of cycles is calculated directly.\n## Input: If the input is data = pd.Series(data, dtype='float'), then storage_profile_calculate(data, storage_capacity = -1, output = False) is called.\n## Processing: Element-wise, for year 1 and year 2, the difference between consecutive values is computed, absolute values are taken, and summed.\n## Processing: For sliding difference calculation, a zero must be prepended to the profile in year 1, and the last value from year 1 must be prepended to the profile in year 2.\n## Processing: The sum of storage charging and discharging is divided by the storage capacity and by 2.\n## Output: Number of cycles for year 1 and year 2 – if output = False, returned as a tuple; if output = True, printed.\n\ndef calculate_cycles(data, output = False):\n  \n  if type(data) is tuple: # storage capacity and profiles were provided\n    storage_capacity = data[0]\n    storage_profile_year1 = data[1]\n    storage_profile_year2 = data[2]\n  \n  else: # residual load was provided\n    result = storage_profile_calculate(data, storage_capacity = -1, output = False)\n    storage_capacity = result[0]\n    storage_profile_year1 = result[1]\n    storage_profile_year2 = result[2]\n  \n  # Prepend a zero to year 1 profile, prepend the last value of year 1 to year 2 profile\n  storage_profile_year1 = pd.concat([pd.Series(0), storage_profile_year1])\n  storage_profile_year2 = pd.concat([storage_profile_year1[-1:], storage_profile_year2])\n\n  # Calculate number of cycles\n  cycles_year1 = storage_profile_year1.diff().abs().sum() / (storage_capacity * 2) # one cycle = full charge and discharge --> divide by 2\n  cycles_year2 = storage_profile_year2.diff().abs().sum() / (storage_capacity * 2) # one cycle = full charge and discharge --> divide by 2\n  \n  if output:\n    print(f\"Number of cycles year 1: {cycles_year1:,.2f}\\n\"\n          f\"Number of cycles year 2: {cycles_year2:,.2f}\")\n  \n  else:\n    return cycles_year1, cycles_year2\n  \ncalculate_cycles(storage_2023, output = True)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nNumber of cycles year 1: 8.38\nNumber of cycles year 2: 8.38\n```\n:::\n:::\n\n\n## with Efficiency\n\n::: {.cell execution_count=68}\n``` {.python .cell-code}\n# Calculate number of cycles with efficiency\n## Input: data = pd.Series(data, dtype = 'float'), charge_efficiency = 1, discharge_efficiency = 1, output = False\n## Input: If the input is a tuple {'storage_capacity': float, 'storage_profile_year1': pd.Series, 'storage_profile_year2': pd.Series}, the number of cycles is calculated directly.\n## Input: If the input is data = pd.Series(data, dtype = 'float'), then calculate_annual_storage(data, storage_capacity = -1, charge_efficiency = 1, discharge_efficiency = 1, output = False) is called.\n## Processing: For year 1 and year 2, the element-wise difference of consecutive values is computed, taken as absolute, and summed.\n## Processing: For the sliding difference calculation, prepend a zero to the storage profile in year 1, and prepend the last value from year 1 to the storage profile of year 2.\n## Processing: The sum of storage charging and discharging is divided by the storage capacity and then by 2.\n## Output: Number of cycles for year 1 and year 2 – if output = False as return value (tuple), if output = True via print()\n\ndef calculate_cycles(data, charge_efficiency = 1, discharge_efficiency = 1, output = False):\n  \n  if type(data) is tuple: # storage capacity and storage profiles were passed\n    storage_capacity = data[0]\n    storage_profile_year1 = data[1]\n    storage_profile_year2 = data[2]\n  \n  else: # residual load was passed\n    result = calculate_annual_storage(data, storage_capacity = -1, charge_efficiency = charge_efficiency, discharge_efficiency = discharge_efficiency, output = False)\n    storage_capacity = result[0]\n    storage_profile_year1 = result[1]\n    storage_profile_year2 = result[2]\n  \n  # prepend zero to storage profile year 1, prepend last value from year 1 to storage profile year 2\n  storage_profile_year1 = pd.concat([pd.Series(0), storage_profile_year1])\n  storage_profile_year2 = pd.concat([storage_profile_year1[ - 1: ], storage_profile_year2])\n\n  # calculate number of cycles  \n  cycles_year1 = storage_profile_year1.diff().abs().sum() / (storage_capacity * 2) # one cycle = full charge and discharge --> divide by 2\n  cycles_year2 = storage_profile_year2.diff().abs().sum() / (storage_capacity * 2) # one cycle = full charge and discharge --> divide by 2\n  \n  if output:\n    print(f\"Number of cycles year 1: {cycles_year1:,.2f}\\n\"\n          f\"Number of cycles year 2: {cycles_year2:,.2f}\")\n  \n  else:\n    return cycles_year1, cycles_year2\n  \ncalculate_cycles(residual_load, charge_efficiency = 0.9, discharge_efficiency = 0.9, output = True)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nNumber of cycles year 1: 8.79\nNumber of cycles year 2: 8.79\n```\n:::\n:::\n\n\n:::\n\nDue to the low renewable generation surpluses in 2023, the number of cycles in Year 1 and Year 2 is identical. When efficiency is considered, the number of cycles increases because the storage size is smaller.\n\n### Capping\n\n::: {layout=\"[50, 50]\"}\n\n::: {.cell execution_count=69}\n\n::: {.cell-output .cell-output-display}\n![](energiedatenanalyse_files/figure-pdf/cell-70-output-1.pdf){fig-alt='In two graphics, two simplified residual load curves consisting of four bars each are shown over the course of the year. The x-axis shows the 365 days of the year, the y-axis shows the residual load from minus 1 to 1. In the upper graphic, the yearly course of storage without capping of generation peaks is shown. In the first quarter of the year, the residual load is negative at minus 1. The first bar is colored and shaded with an upward-sloping hatch. The coloring indicates the required storage size, the upward hatching the charging phase. In the second quarter, the residual load is positive at 1, and the discharging is indicated by a downward hatching. In the third and fourth quarters, phases of charging and discharging occur at minus and plus 0.5, respectively, and are shaded accordingly. In this way, 1.5 charging and discharging cycles are realized. In the lower graphic, the same yearly course is shown, but the storage size is limited to 0.5. In the first quarter with a residual load of -1, only -0.5 is stored. This is represented by coloring and upward hatching of the area between 0 and 0.5. The area between -0.5 and -1 is left white and unmarked. This surplus electricity is not stored. Similarly, in the second quarter, the residual load of 1 is only half covered by the storage. The residual load in the range from 0.5 to 1 must be supplied by load-following power plants. The subsequent charging and discharging phases in the third and fourth quarters correspond to residual loads of minus and plus 0.5. The storage limited to 0.5 thus achieves 2 charging and discharging cycles.'}\n:::\n:::\n\n\nCapping of Generation Peaks\n: Capping of generation peaks is a way to reduce the required storage size. Limiting the charging leads to better utilization of storage capacity and a higher number of cycles.  \n: In the upper example, the storage size is dimensioned according to the maximum renewable surplus production. The storage thus reaches 1.5 cycles.  \n: In the lower example, the storage is dimensioned smaller. The storage reaches 2 cycles.  \n\n:::\n\n#### Calculation\nBased on the annual profile of the storage, the effect of capping generation peaks on the stored electricity amount and the achieved number of storage cycles can be calculated. For this purpose, the annual profile of the storage is computed for various reduced storage sizes, along with the achieved cycle number and the amount of electricity not stored.  \n\n  - Input: The function is given a residual load data series as a `pd.Series` and optionally a list of reduced storage sizes, expressed as relative fractions of 1. If no list is provided, the calculation is performed for the relative storage sizes [0.9, 0.8, 0.7, 0.6, 0.5].\n\n  - Processing: For the residual load, the uncapped storage size and annual profiles in year 1 and year 2 are calculated by calling the function `calculate_storage_annual_profile`. Then the achieved cycle number is determined by calling the function `calculate_cycles`. Based on the annual profiles, the stored electricity amount is calculated. For this, the method `pd.Series.diff()` is used to compute the elementwise difference between each value and its predecessor (sliding difference). As with the cycle calculation, a zero is prepended to the annual profile in year 1, and the last value of year 1 is prepended to year 2. The stored electricity amount is the sum of all positive values in this series. Negative values indicate a reduction of the charge between two points in time, i.e. discharging phases. Therefore, negative values are set to zero with the `.clip` method. The instruction is: `pd.Series.diff().clip(lower = 0).sum()`.  \n  These steps are repeated for all elements in the variable `new_storage_capacitys`. For this, the uncapped storage size is multiplied by one of the relative storage sizes, and the achieved cycle number as well as the stored electricity amount are calculated. From the difference of the stored electricity amount for each new storage size compared to the baseline year, the capped electricity amount is determined.\n\n  - Output: If `output = False`, a DataFrame with three columns is returned. The column with index 0 contains the relative storage size, columns 1 and 2 contain the capped electricity amounts in year 1 and year 2. If `output = True`, this DataFrame is printed with `print()`. Additionally, a five-column DataFrame with the intermediate results (including the baseline year in row 0) is printed. This contains in the column with index 0 the absolute storage size, and in the following columns the stored electricity amount in year 1 (column with index 1), the cycle number in year 1 (column with index 2), the stored electricity amount in year 2 (column with index 3), and the cycle number in year 2 (column with index 4).\n\n::: {.panel-tabset}\n\n## without efficiency\n\n::: {.cell execution_count=70}\n``` {.python .cell-code}\n# Curtailment calculation: How much renewable energy (RE) is discarded when storage size is limited?\n## Input: Residual load curve data = pd.Series(data, dtype='float', new_storage_capacitys = [0.9, 0.8, 0.7, 0.6, 0.5], output = False)\n## Processing: For data, the function calculate_annual_storage() determines the storage size and the storage profiles for Year 1 and Year 2 without additional curtailment\n## Processing: For data, the function calculate_cycles() determines the number of cycles in Year 1 and Year 2 without additional curtailment\n## Processing: Based on the storage profiles, the stored electricity amount without additional curtailment is determined\n## Processing: The processing steps are repeated for all elements provided in the variable new_storage_capacitys\n## Processing: The storage size of the base residual load curve data is multiplied by the values provided in new_storage_capacitys\n## Processing: From the difference between the stored electricity amounts for each new storage size and the base year, the curtailed electricity amount is determined\n## Output: If output = False, a DataFrame with three columns is returned. Column with index 0 contains the relative storage size, Columns 1 and 2 contain the curtailed electricity amounts in Year 1 and Year 2.\n## Output: If output = True, the three-column DataFrame is printed using print().\n## Output: Additionally, a five-column DataFrame with intermediate results (including base year) is printed.\n## Output: (Index information): 0 = absolute storage size, 1 = stored electricity Year 1, 2 = cycle number Year 1, 3 = stored electricity Year 2, 4 = cycle number Year 2\n\ndef calculate_curtailment_effect(data, new_storage_capacitys = [0.9, 0.8, 0.7, 0.6, 0.5], output = False):\n\n  # Determine base year storage size\n  result = calculate_annual_storage(data, storage_capacity = -1, output = False)\n  storage_capacity0 = result[0]\n  storage_profile_year1 = result[1]\n  storage_profile_year2 = result[2]\n\n  # Determine number of cycles in base year, pass tuple\n  cycles = calculate_cycles(result, output = False)\n  cycles_year1 = cycles[0]\n  cycles_year2 = cycles[1]\n  \n  # Add a zero in front of storage profile Year 1, append last value of Year 1 to Year 2\n  storage_profile_year1 = pd.concat([pd.Series([0]), storage_profile_year1])\n  storage_profile_year2 = pd.concat([storage_profile_year1[-1:], storage_profile_year2])\n\n  # Determine stored electricity in base year\n  storage_amount_year1 = storage_profile_year1.diff().clip(lower = 0).sum()\n  storage_amount_year2 = storage_profile_year2.diff().clip(lower = 0).sum()\n\n  # Save results in DataFrame\n  dataframe = pd.DataFrame({'Storage size': [storage_capacity0], 'Storage amount Year1': [storage_amount_year1], 'Cycles Year1': cycles_year1, 'Storage amount Year2': [storage_amount_year2], 'Cycles Year2': cycles_year2})\n  \n  # Determine stored electricity with alternative storage sizes\n  count = 1\n\n  for i in range(len(new_storage_capacitys)):\n\n    storage_capacity_new = storage_capacity0 * new_storage_capacitys[i]\n    \n    result = calculate_annual_storage(data, storage_capacity = storage_capacity_new, output = False)\n    storage_profile_year1 = result[1]\n    storage_profile_year2 = result[2]\n\n    # Determine number of cycles in base year, pass tuple\n    cycles = calculate_cycles(result, output = False)\n    cycles_year1 = cycles[0]\n    cycles_year2 = cycles[1]\n\n    # Add a zero in front of storage profile Year 1, append last value of Year 1 to Year 2\n    storage_profile_year1 = pd.concat([pd.Series([0]), storage_profile_year1])\n    storage_profile_year2 = pd.concat([storage_profile_year1[-1:], storage_profile_year2])\n\n    # Determine stored electricity with new storage size\n    storage_amount_year1 = storage_profile_year1.diff().clip(lower = 0).sum()\n    storage_amount_year2 = storage_profile_year2.diff().clip(lower = 0).sum()\n\n    new_row = [storage_capacity_new, storage_amount_year1, cycles_year1, storage_amount_year2, cycles_year2]\n    dataframe.loc[count] = new_row\n  \n    count += 1\n  \n  # Calculate curtailed amount data.sub(data[0]).drop(0)\n  curtailed_storage_year1 = dataframe['Storage amount Year1'].sub(dataframe['Storage amount Year1'][0]).abs().drop(0).reset_index(drop = True)\n  curtailed_storage_year2 = dataframe['Storage amount Year2'].sub(dataframe['Storage amount Year2'][0]).abs().drop(0).reset_index(drop = True)\n  dataset = pd.DataFrame({'Relative storage size': pd.Series(new_storage_capacitys), 'Curtailed storage Year1': curtailed_storage_year1, 'Curtailed storage Year2': curtailed_storage_year2})\n  \n  if output:\n\n    print(dataframe)\n    print(\"\\n\")\n    print(dataset)\n\n  else:\n    return dataset\n\ncalculate_curtailment_effect(residual_load, output = True)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n   Storage size  Storage amount Year1  Cycles Year1  Storage amount Year2  \\\n0      119667.0              1.00e+06          8.38              1.00e+06   \n1      107700.3              9.91e+05          9.20              9.91e+05   \n2       95733.6              9.79e+05         10.23              9.79e+05   \n3       83766.9              9.63e+05         11.49              9.63e+05   \n4       71800.2              9.39e+05         13.07              9.39e+05   \n5       59833.5              8.99e+05         15.03              8.99e+05   \n\n   Cycles Year2  \n0          8.38  \n1          9.20  \n2         10.23  \n3         11.49  \n4         13.07  \n5         15.03  \n\n\n   Relative storage size  Curtailed storage Year1  Curtailed storage Year2\n0                    0.9                  11966.7                  11966.7\n1                    0.8                  23933.4                  23933.4\n2                    0.7                  40443.7                  40443.7\n3                    0.6                  64377.1                  64377.1\n4                    0.5                 103619.5                 103619.5\n```\n:::\n:::\n\n\n## with Efficiency\n\n::: {.cell execution_count=71}\n``` {.python .cell-code}\n# Calculate curtailment: How much renewable energy is discarded when storage size is limited?\n## Input: Residual load curve data = pd.Series(data, dtype = 'float', charge_efficiency = 1, discharge_efficiency = 1, new_storage_capacitys = [0.9, 0.8, 0.7, 0.6, 0.5], output = False)\n## Processing: For data, the function calculate_annual_storage() determines the storage size and the annual profiles for Year 1 and Year 2 without additional curtailment\n## Processing: For data, the function calculate_cycles() determines the number of cycles in Year 1 and Year 2 without additional curtailment\n## Processing: Based on the annual profiles, the stored electricity amount without additional curtailment is determined\n## Processing: These steps are repeated for all elements passed in the variable new_storage_capacitys\n## Processing: The storage size of the base residual load curve data is multiplied by the values passed in new_storage_capacitys\n## Processing: From the difference between stored electricity for each new storage size and the base year, the curtailed electricity is determined\n## Output: If output = False a DataFrame with three columns is returned. Column 0 contains the relative storage size, columns 1 and 2 contain the curtailed electricity in Year 1 and Year 2.\n## Output: If output = True the three-column DataFrame is printed with print().\n## Output: Additionally, a five-column DataFrame with intermediate results (including the base year) is printed with print().\n## Output: (Index references): 0 = absolute storage size, 1 = stored electricity Year 1, 2 = cycles Year 1, 3 = stored electricity Year 2, 4 = cycles Year 2\n\ndef calculate_curtailment_effect(data, charge_efficiency = 1, discharge_efficiency = 1, new_storage_capacitys = [0.9, 0.8, 0.7, 0.6, 0.5], output = False):\n\n  # Determine storage size in the base year\n  result = calculate_annual_storage(data, storage_capacity = -1, charge_efficiency = charge_efficiency, discharge_efficiency = discharge_efficiency, output = False)\n  base_storage_capacity = result[0]\n  storage_profile_year1 = result[1]\n  storage_profile_year2 = result[2]\n\n  # Determine number of cycles in the base year, pass tuple\n  cycles = calculate_cycles(result, charge_efficiency = charge_efficiency, discharge_efficiency = discharge_efficiency, output = False)\n  cycles_year1 = cycles[0]\n  cycles_year2 = cycles[1]\n  \n  # Prepend zero to annual profile Year 1, add last value of Year 1 to start of Year 2\n  storage_profile_year1 = pd.concat([pd.Series([0]), storage_profile_year1])\n  storage_profile_year2 = pd.concat([storage_profile_year1[ - 1: ], storage_profile_year2])\n\n  # Determine stored electricity in the base year\n  storage_year1 = storage_profile_year1.diff().clip(lower = 0).sum()\n  storage_year2 = storage_profile_year2.diff().clip(lower = 0).sum()\n\n  # Save results in DataFrame\n  dataframe = pd.DataFrame({'Storage size': [base_storage_capacity], 'Storage Year1': [storage_year1], 'Cycles Year1': cycles_year1, 'Storage Year2': [storage_year2], 'Cycles Year2': cycles_year2})\n  \n  # Determine stored electricity for alternative storage sizes\n  count = 1\n\n  for i in range(len(new_storage_capacitys)):\n\n    new_storage_capacity = base_storage_capacity * new_storage_capacitys[i]\n    \n    result = calculate_annual_storage(data, storage_capacity = new_storage_capacity, charge_efficiency = charge_efficiency, discharge_efficiency = discharge_efficiency, output = False)\n    storage_profile_year1 = result[1]\n    storage_profile_year2 = result[2]\n\n    # Determine number of cycles for new storage size\n    cycles = calculate_cycles(result, charge_efficiency = charge_efficiency, discharge_efficiency = discharge_efficiency, output = False)\n    cycles_year1 = cycles[0]\n    cycles_year2 = cycles[1]\n\n    # Prepend zero to annual profile Year 1, add last value of Year 1 to start of Year 2\n    storage_profile_year1 = pd.concat([pd.Series([0]), storage_profile_year1])\n    storage_profile_year2 = pd.concat([storage_profile_year1[ - 1: ], storage_profile_year2])\n\n    # Determine stored electricity for new storage size\n    storage_year1 = storage_profile_year1.diff().clip(lower = 0).sum()\n    storage_year2 = storage_profile_year2.diff().clip(lower = 0).sum()\n\n    new_row = [new_storage_capacity, storage_year1, cycles_year1, storage_year2, cycles_year2]\n    dataframe.loc[count] = new_row\n  \n    count += 1\n  \n  # Calculate curtailed amounts data.sub(data[0]).drop(0)\n  curtailed_storage_year1 = dataframe['Storage Year1'].sub(dataframe['Storage Year1'][0]).abs().drop(0).reset_index(drop = True)\n  curtailed_storage_year2 = dataframe['Storage Year2'].sub(dataframe['Storage Year2'][0]).abs().drop(0).reset_index(drop = True)\n  dataset = pd.DataFrame({'Relative storage size': pd.Series(new_storage_capacitys), 'Curtailed storage Year1': curtailed_storage_year1, 'Curtailed storage Year2': curtailed_storage_year2})\n  \n  if output:\n\n    print(dataframe)\n    print(\"\\n\")\n    print(dataset)\n\n  else:\n    return dataset\n\ncalculate_curtailment_effect(residual_load, charge_efficiency = 0.9, discharge_efficiency = 0.9, output = True)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n   Storage size  Storage Year1  Cycles Year1  Storage Year2  Cycles Year2\n0     102674.54      902678.40          8.79      902678.40          8.79\n1      92407.08      892410.95          9.66      892410.95          9.66\n2      82139.63      882143.49         10.74      882143.49         10.74\n3      71872.18      864601.21         12.03      864601.21         12.03\n4      61604.72      844066.30         13.70      844066.30         13.70\n5      51337.27      799701.77         15.58      799701.77         15.58\n\n\n   Relative storage size  Curtailed storage Year1  Curtailed storage Year2\n0                    0.9                 10267.45                 10267.45\n1                    0.8                 20534.91                 20534.91\n2                    0.7                 38077.19                 38077.19\n3                    0.6                 58612.10                 58612.10\n4                    0.5                102976.63                102976.63\n```\n:::\n:::\n\n\n:::\n\n## Determine Share of Renewable Electricity Generation\nBy integrating an electricity storage system into the power grid, excess renewable generation can be shifted to periods with a positive residual load that would otherwise need to be met by conventional power plants. This reduces the share of conventional electricity generation and increases the share of renewable electricity generation.\n\n::: {layout=\"[50, 50]\"}\n\n::: {.cell execution_count=72}\n\n::: {.cell-output .cell-output-display}\n![](energiedatenanalyse_files/figure-pdf/cell-73-output-1.pdf){fig-alt='Two charts show a simplified residual load curve over the year consisting of two bars. The x-axis represents the 365 days of the year, and the y-axis shows the residual load from minus 1 to 1. In the first half of the year, the residual load is negative at minus 0.5; in the second half of the year, it is positive at 1. This is represented by one bar for each value. The first bar with negative values is colored and hatched from bottom left to top right, indicating the required storage capacity and the charging phase. The second bar with positive values is hatched from top left to bottom right up to 0.5, representing the discharging phase, while the area from 0.5 to 1 is left unfilled, corresponding to the residual load served by conventional power plants.'}\n:::\n:::\n\n\nDetermine Share of Renewable Electricity Production\n: Storing electricity reduces the positive residual load.\n: If the stored electricity is subtracted from the positive residual load (either cumulatively or annually), the share of load that must be covered conventionally corresponds to the quotient of summed positive residual load and summed grid load, or the quotient of summed positive residual load and total electricity generation.\n: The share of renewable electricity production is 1 minus the share of load that must be covered conventionally.\n\n:::\n\nThe share of renewable electricity production can therefore be calculated as follows:\n\n::: {.cell execution_count=73}\n``` {.python .cell-code}\nresidual_load.clip(lower = 0).sum() / consumption['Gesamt (Netzlast) [MWh]'].sum()\n\nprint(f\"Sum of positive residual load [MWh]: {residual_load.clip(lower = 0).sum()}\\n\"\n      f\"Sum of grid load: {consumption['Gesamt (Netzlast) [MWh]'].sum()}\\n\"\n      f\"Quotient positive residual load / grid load: {residual_load.clip(lower = 0).sum() / consumption['Gesamt (Netzlast) [MWh]'].sum():,.2f}\\n\"\n      f\"Share of renewable generation: { ( renewable_share := 1 - (residual_load.clip(lower = 0).sum() / consumption['Gesamt (Netzlast) [MWh]'].sum()) ) :,.2f}\\n\\n\"\n\n      f\"Sum of generation: {generation.sum(numeric_only = True).sum()}\\n\"\n      f\"Quotient positive residual load / generation: {residual_load.clip(lower = 0).sum() / generation.sum(numeric_only = True).sum():,.2f}\\n\"\n      f\"Share of renewable generation: {1 - (residual_load.clip(lower = 0).sum() / generation.sum(numeric_only = True).sum()):,.2f}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nSum of positive residual load [MWh]: 207842228.25\nSum of grid load: 458271100.75\nQuotient positive residual load / grid load: 0.45\nShare of renewable generation: 0.55\n\nSum of generation: 448650448.25\nQuotient positive residual load / generation: 0.46\nShare of renewable generation: 0.54\n```\n:::\n:::\n\n\nThe grid load from the dataset `consumption` deviates slightly at 458 TWh from the summed electricity generation in the dataset `generation` at 448 TWh. As a result, the calculated shares differ slightly.\n\n#### Calculation\nThe basis for calculating the share of renewable electricity generation after discharging renewable surplus production is the annual cycle of the storage. Discharging electricity means a reduction of the state of charge between two points in time. The discharged electricity reduces the positive residual load at that time. Consequently, the ratio of positive residual load to grid load decreases, and the share of renewable electricity generation increases. This is implemented in the following function.\n\n  - Input: The function receives a residual load data series. Optionally, a grid load data series can also be provided. Additionally, an optional list of reduced storage sizes, expressed as relative fractions of 1, can be supplied. If no list is provided, the calculation is performed for the relative storage sizes [0.9, 0.8, 0.7, 0.6, 0.5].\n\n  - Processing: By calling the function `calculate_annual_storage()`, the annual cycles of the electricity storage with relative size 1 are calculated for the residual load data series. Using these annual cycles, the discharged electricity amount in the annual cycle is determined with the method `pd.Series.diff().clip(upper = 0)`. For this sliding difference calculation, a zero is prepended to the annual cycle in year 1, and the last value from year 1 is prepended to the annual cycle in year 2. The first value in the annual cycle of the discharged electricity amount is NaN, so this value is dropped and the index is reset. The complete command is: `pd.Series.diff().clip(upper = 0)[1:].reset_index(drop = True)`. The annual cycle of the discharged electricity amount is subtracted from the residual load curve, thereby determining the residual load curve after discharging. Since discharging in the annual cycle is represented by negative values, the difference is calculated by addition.  \n  If a grid load data series is provided, the realized share of renewable generation is calculated based on the residual load curve after discharging: 1 - (sum of positive residual load / sum of grid load). The calculations are repeated for smaller-sized storages.\n\n  - Output: If `output = False`, the residual load curves after discharging are returned as a DataFrame. The DataFrame consists of one column for the relative storage size 1 as well as for all supplied relatively reduced storage sizes. The residual load curves in year 1 and year 2 are stored in row 0 and row 1, respectively. If `output = True`, the summed grid load, the summed positive & negative residual load, the share of renewable generation without storage, and the realized share of renewable generation with the storage size in the base year and for all provided storage sizes are printed for year 1 and year 2 using `print()`.\n\n::: {.panel-tabset} \n\n## without efficiency\n\n::: {.cell execution_count=74}\n``` {.python .cell-code}\n# Calculate share of renewable energy (RE)\n## Input: data = pd.Series(data, dtype='float'), grid_load = -1, new_storage_capacitys = [0.9, 0.8, 0.7, 0.6, 0.5], output = False\n## Processing: Call function calculate_annual_storage(data) to determine storage size and annual storage profile for Year 1 and Year 2\n## Processing: From the annual storage profile, determine the discharged electricity, subtract it from residual load --> new residual load curve after discharge\n## Processing: If grid_load = pd.Series(grid_load, dtype='float') is provided, determine share of renewable energy based on residual load after discharge\n## Processing: Repeat calculations for smaller storage sizes, default = [0.9, 0.8, 0.7, 0.6, 0.5]\n## Output: output = False: Return DataFrame of residual load curves after discharge. Column 0 = storage size 1, subsequent columns = new storage sizes. Row 0 = residual load Year 1, Row 1 = residual load Year 2\n## Output: output = True: Print total grid load, positive/negative residual load, RE share without storage, and realized RE share for base year storage size and new_storage_capacitys for Year 1 and Year 2\n\ndef calculate_re_share(data, grid_load=-1, new_storage_capacitys=[0.9, 0.8, 0.7, 0.6, 0.5], output=False):\n\n    # Determine annual profile for base year\n    result = calculate_annual_storage(data, storage_capacity=-1, output=False)\n    base_storage_capacity = result[0]\n    annual_storage_year1 = result[1]\n    annual_storage_year2 = result[2]\n    \n    # Prepend zero to Year 1 profile, use last value of Year 1 for Year 2\n    annual_storage_year1 = pd.concat([pd.Series([0]), annual_storage_year1])\n    annual_storage_year2 = pd.concat([annual_storage_year1[-1:], annual_storage_year2])\n\n    # Calculate discharged electricity, drop first NaN\n    discharged_year1 = annual_storage_year1.diff().clip(upper=0)[1:].reset_index(drop=True)\n    discharged_year2 = annual_storage_year2.diff().clip(upper=0)[1:].reset_index(drop=True)\n\n    # Calculate residual load after discharge (discharged values are negative)\n    residual_load_year1 = data + discharged_year1\n    residual_load_year2 = data + discharged_year2\n\n    # Store residual load in DataFrame\n    residual_after_discharge = pd.DataFrame({'Storage size 1': [list(residual_load_year1), list(residual_load_year2)]})\n\n    if isinstance(grid_load, int):  # RE share cannot be calculated\n        if output:\n            print(\"Grid load was not provided. RE share cannot be calculated.\")\n        output = False\n    else:  # Calculate RE share\n        # RE share = 1 - sum of positive residual load / total grid load\n        ## Year 1\n        re_share_year1 = 1 - (residual_load_year1.clip(lower=0).sum() / grid_load.sum())\n        ## Year 2\n        re_share_year2 = 1 - (residual_load_year2.clip(lower=0).sum() / grid_load.sum())\n\n        # Store RE share in DataFrame\n        re_share_df = pd.DataFrame({\n            'Relative storage size': pd.concat([pd.Series([1]), pd.Series(new_storage_capacitys)], ignore_index=True),\n            'RE share Year1': pd.Series([re_share_year1]),\n            'RE share Year2': pd.Series([re_share_year2])\n        })\n\n    # Calculate discharged electricity and RE share for alternative storage sizes\n    count = 1\n    for i in range(len(new_storage_capacitys)):\n\n        new_storage = base_storage_capacity * new_storage_capacitys[i]\n        result = calculate_annual_storage(data, storage_capacity=new_storage, output=False)\n        annual_storage_year1 = result[1]\n        annual_storage_year2 = result[2]\n\n        # Prepend zero to Year 1 profile, use last value of Year 1 for Year 2\n        annual_storage_year1 = pd.concat([pd.Series([0]), annual_storage_year1])\n        annual_storage_year2 = pd.concat([annual_storage_year1[-1:], annual_storage_year2])\n\n        # Calculate discharged electricity\n        discharged_year1 = annual_storage_year1.diff().clip(upper=0)[1:].reset_index(drop=True)\n        discharged_year2 = annual_storage_year2.diff().clip(upper=0)[1:].reset_index(drop=True)\n\n        # Residual load after discharge\n        residual_load_year1 = data + discharged_year1\n        residual_load_year2 = data + discharged_year2\n\n        # Add column to residual_after_discharge DataFrame\n        residual_after_discharge['Storage size ' + str(new_storage)] = [list(residual_load_year1), list(residual_load_year2)]\n\n        # Calculate RE share\n        if not isinstance(grid_load, int):\n            re_share_year1 = 1 - (residual_load_year1.clip(lower=0).sum() / grid_load.sum())\n            re_share_year2 = 1 - (residual_load_year2.clip(lower=0).sum() / grid_load.sum())\n            re_share_df.loc[count, 'RE share Year1'] = re_share_year1\n            re_share_df.loc[count, 'RE share Year2'] = re_share_year2\n\n        count += 1\n\n    if output:  # Print RE share\n        print(f\"Total grid load: {grid_load.sum():,.2f}\\nTotal positive residual load: {data.clip(lower=0).sum():,.2f}\\tTotal negative residual load: {data.clip(upper=0).sum():,.2f}\\nStorage size 1: {base_storage_capacity:,.2f}\\tRE share without storage: {1 - (data.clip(lower=0).sum() / grid_load.sum()) if len(grid_load) > 1 else '--':,.2f}\\n\")\n        print(re_share_df)\n    else:  # Return residual load curves\n        return residual_after_discharge\n\ncalculate_re_share(residual_load, grid_load=consumption['Gesamt (Netzlast) [MWh]'], new_storage_capacitys=[0.9, 0.8, 0.7, 0.6, 0.5], output=True)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nTotal grid load: 458,271,100.75\nTotal positive residual load: 207,842,228.25\tTotal negative residual load: -1,002,976.00\nStorage size 1: 119,667.00\tRE share without storage: 0.55\n\n   Relative storage size  RE share Year1  RE share Year2\n0                    1.0            0.55            0.55\n1                    0.9            0.55            0.55\n2                    0.8            0.55            0.55\n3                    0.7            0.55            0.55\n4                    0.6            0.55            0.55\n5                    0.5            0.55            0.55\n```\n:::\n:::\n\n\n## with Efficiency\n\n::: {.cell execution_count=75}\n``` {.python .cell-code}\n# Calculate renewable energy share\n## Input: data = pd.Series(data, dtype='float'), grid_load = -1, charge_efficiency = 1, discharge_efficiency = 1, new_storage_capacitys = [0.9, 0.8, 0.7, 0.6, 0.5], output = False\n## Processing: Call the function calculate_annual_storage(data) to determine storage size and annual profile of storage in year 1 and year 2\n## Processing: Determine the discharged electricity in the annual storage profile, subtract it from the residual load --> new residual load curve after discharge\n## Processing: If grid_load = pd.Series(grid_load, dtype='float') is provided, determine the renewable energy share based on the residual load curve after discharge\n## Processing: Repeat calculations for smaller sized storages, default = [0.9, 0.8, 0.7, 0.6, 0.5]\n## Output: output = False: Return a DataFrame of residual load curve(s) after discharge. Column 0 corresponds to storage size = 1, subsequent columns correspond to new storage sizes. Row 0 contains residual load curve for year 1, row 1 for year 2\n## Output: output = True: Print sum of grid load, positive/negative residual load, renewable energy share without storage, and realized renewable energy share for base year storage size and new_storage_capacitys for year 1 and year 2\n\ndef calculate_renewable_share(data, grid_load=-1, charge_efficiency=1, discharge_efficiency=1, new_storage_capacitys=[0.9, 0.8, 0.7, 0.6, 0.5], output=False):\n\n    # Determine annual profile for base year\n    result = calculate_annual_storage(data, storage_capacity=-1, charge_efficiency=charge_efficiency, discharge_efficiency=discharge_efficiency, output=False)\n    base_storage_capacity = result[0]\n    storage_profile_year1 = result[1]\n    storage_profile_year2 = result[2]\n    \n    # Prepend zero to year 1, year 2 starts with last value of year 1\n    storage_profile_year1 = pd.concat([pd.Series([0]), storage_profile_year1])\n    storage_profile_year2 = pd.concat([storage_profile_year1[-1:], storage_profile_year2])\n\n    # Discharged electricity profile, first value is NaN and omitted\n    discharge_year1 = storage_profile_year1.diff().clip(upper=0)[1:].reset_index(drop=True)\n    discharge_year2 = storage_profile_year2.diff().clip(upper=0)[1:].reset_index(drop=True)\n\n    # Calculate residual load after discharge\n    residual_load_year1 = data + discharge_year1\n    residual_load_year2 = data + discharge_year2\n\n    # Store residual load in DataFrame\n    residual_load_after_discharge = pd.DataFrame({'Storage size 1': [list(residual_load_year1), list(residual_load_year2)]})\n\n    if type(grid_load) is int:  # Renewable share cannot be calculated\n        if output:\n            print(\"Grid load not provided. Renewable energy share cannot be calculated.\")\n        output = False\n    \n    else:  # Calculate renewable share\n    \n        # Renewable share = 1 - sum of positive residual load / sum of grid load\n        ## Year 1\n        renewable_share_year1 = 1 - (residual_load_year1.clip(lower=0).sum() / grid_load.sum())\n\n        ## Year 2\n        renewable_share_year2 = 1 - (residual_load_year2.clip(lower=0).sum() / grid_load.sum())\n\n        # Store renewable share in DataFrame\n        renewable_share_df = pd.DataFrame({'relative_storage_capacity': pd.concat([pd.Series([1]), pd.Series(new_storage_capacitys)], ignore_index=True), 'Renewable share Year1': pd.Series([renewable_share_year1]), 'Renewable share Year2': pd.Series([renewable_share_year2])})\n\n    # Calculate discharged electricity and renewable share for alternative storage sizes\n    count = 1\n\n    for i in range(len(new_storage_capacitys)):\n\n        new_storage_capacity = base_storage_capacity * new_storage_capacitys[i]\n        \n        result = calculate_annual_storage(data, storage_capacity=new_storage_capacity, charge_efficiency=charge_efficiency, discharge_efficiency=discharge_efficiency, output=False)\n        storage_profile_year1 = result[1]\n        storage_profile_year2 = result[2]\n\n        # Prepend zero to year 1, year 2 starts with last value of year 1\n        storage_profile_year1 = pd.concat([pd.Series([0]), storage_profile_year1])\n        storage_profile_year2 = pd.concat([storage_profile_year1[-1:], storage_profile_year2])\n\n        # Discharged electricity profile\n        discharge_year1 = storage_profile_year1.diff().clip(upper=0)[1:].reset_index(drop=True)\n        discharge_year2 = storage_profile_year2.diff().clip(upper=0)[1:].reset_index(drop=True)\n\n        # Calculate residual load after discharge\n        residual_load_year1 = data + discharge_year1\n        residual_load_year2 = data + discharge_year2\n\n        # Add column to residual load DataFrame\n        residual_load_after_discharge['Storage size ' + str(new_storage_capacity)] = [list(residual_load_year1), list(residual_load_year2)]\n\n        # Calculate renewable share\n        if type(grid_load) is not int:\n            renewable_share_year1 = 1 - (residual_load_year1.clip(lower=0).sum() / grid_load.sum())\n            renewable_share_year2 = 1 - (residual_load_year2.clip(lower=0).sum() / grid_load.sum())\n\n            renewable_share_df.loc[count, 'Renewable share Year1'] = renewable_share_year1\n            renewable_share_df.loc[count, 'Renewable share Year2'] = renewable_share_year2\n        \n        count += 1\n                              \n    if output:  # Print renewable share\n\n        print(f\"Total grid load: {grid_load.sum():,.2f}\\nSum of positive residual load: {data.clip(lower=0).sum():,.2f}\\tSum of negative residual load: {data.clip(upper=0).sum():,.2f}\\nBase storage size: {base_storage_capacity:,.2f}\\tRenewable share without storage: {1 - (data.clip(lower=0).sum() / grid_load.sum()) if len(grid_load) > 1 else '--':,.2f}\\n\")\n        print(renewable_share_df)\n    \n    else:  # Return residual load curves\n        return residual_load_after_discharge\n\ncalculate_renewable_share(residual_load, grid_load=consumption['Gesamt (Netzlast) [MWh]'], charge_efficiency=0.9, discharge_efficiency=0.9, new_storage_capacitys=[0.9, 0.8, 0.7, 0.6, 0.5], output=True)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nTotal grid load: 458,271,100.75\nSum of positive residual load: 207,842,228.25\tSum of negative residual load: -1,002,976.00\nBase storage size: 102,674.54\tRenewable share without storage: 0.55\n\n   relative_storage_capacity  Renewable share Year1  Renewable share Year2\n0                        1.0                   0.55                   0.55\n1                        0.9                   0.55                   0.55\n2                        0.8                   0.55                   0.55\n3                        0.7                   0.55                   0.55\n4                        0.6                   0.55                   0.55\n5                        0.5                   0.55                   0.55\n```\n:::\n:::\n\n\n:::\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFor the year 2023, integrating an electricity storage system into the grid to (partially) cover residual load from renewable surplus production would result in only a negligible increase in the share of renewable energy in the electricity mix. This is because the renewable surpluses to be stored amount to 1,002,976 MWh, or around 1 TWh, which is significantly smaller than the positive residual load to be covered of 207,842,228 MWh, or around 208 TWh. The renewable surplus production that can be shifted by the electricity storage corresponds to less than half a percent of the residual load to be covered.\n\nHowever, as the share of renewable generation increases, storing surplus electricity will become increasingly relevant. The required size of electricity storage systems can be estimated using the developed functions for the renewable energy expansion pathway.\n\n## Task: Final Data Analysis\n\n**Calculate the share of renewable electricity generation for the years 2030 and 2035 according to the expansion pathway specified by the federal government (see [@lst-zubaufaktoren]).**\n\n  - What is the maximum storage capacity required?\n  \n  - What share of renewable electricity generation is achieved if the storage is sized at half, one-tenth, or one-hundredth of the maximum capacity?\n  \n  - Use the projected electricity demand for the years 2030 and 2035 as the grid load (see note below).\n\n  - For the efficiency, existing pumped-storage power plants can be used as a reference. The overall efficiency was calculated at 79.10 percent. This efficiency approximately corresponds to a breakdown of storage input efficiency = 0.9 and storage output efficiency = 0.88.\n\n::: {.callout-warning appearance=\"simple\"}\n\n## Electricity Consumption Projections\n\nFuture electricity consumption is unlikely to match that of 2023. Projections estimate electricity consumption of 658 TWh (Kemmler, Wünsch, and Burret 2021, p. 4) for 2030 and 670.4 TWh in 2035 (Scenario B according to Nahmmacher et al. 2021, p. 54). The increase in electricity consumption compared to 2023 can be easily calculated:\n\n::: {.cell execution_count=76}\n``` {.python .cell-code}\nload_factor_2030_MWh = (658 * 1000 * 1000) / consumption[\"Gesamt (Netzlast) [MWh]\"].sum()\nload_factor_2035_MWh = (670.4 * 1000 * 1000) / consumption[\"Gesamt (Netzlast) [MWh]\"].sum()\n\nprint(f\"Increase in electricity consumption in 2030 compared to 2023 Factor: {load_factor_2030_MWh:,.2f}\\n\"\n      f\"Increase in electricity consumption in 2035 compared to 2023 Factor: {load_factor_2035_MWh:,.2f}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nIncrease in electricity consumption in 2030 compared to 2023 Factor: 1.44\nIncrease in electricity consumption in 2035 compared to 2023 Factor: 1.46\n```\n:::\n:::\n\n\nKemmler, Andreas, Aurel Wünsch, and Heiko Burret. 2021. \"Development of Gross Electricity Consumption until 2030. Short Study.\" <https://www.bmwk.de/Redaktion/DE/Downloads/E/prognos-bruttostromverbrauch-2018-2030.pdf?__blob=publicationFile&amp;v=2>\n\nNahmmacher, Paul, Christian Paris, Martin Ruge, Sebastian Spieker, Thomas Anderski, Sebastian Bohlen, Robin Kaiser, Caroline Podewski, Jürgen Apfelbeck, Timo Kahl, Fabian Lukas, Sven Schäfer, Paul-Steven Ganer, Max Muller, and Daniel Stützle. 2021. \"Scenario Framework for the Electricity Grid Development Plan 2035, Version 2021. Draft by the Transmission System Operators.\" <https://www.netzausbau.de/SharedDocs/Downloads/DE/Bedarfsermittlung/2035/SR/Szenariorahmen_2035_Entwurf.pdf?__blob=publicationFile>\n\n:::\n\n&nbsp;\n\n:::: {#tip-closed-data-analysis-exercise .callout-tip title=\"Sample Solution: Closed Data Analysis Exercise\" collapse=\"true\"}\n\n::: {.panel-tabset}\n\n## Complete Sample Solution\n\n:::: {.boarder}\n\n::: {.cell execution_count=77}\n``` {.python .cell-code}\nimport pandas as pd\n\n# Set number of decimal places\npd.set_option(\"display.precision\", 2)\n\n# Load datasets\n# !\n# For your own use, adjust the file path to the correct location of the downloaded .csv files.\n# !\n\ninstalled_capacity_ms = pd.read_csv(\"01-daten/Installierte_Erzeugungsleistung_202301010000_202401010000_Jahr.csv\", \\\nsep = \";\", thousands = \".\", decimal = \",\", parse_dates = [0, 1], date_format = \"%d.%m.%Y\")\n\ngeneration_ms = pd.read_csv(\"01-daten/Realisierte_Erzeugung_202301010000_202401010000_Viertelstunde.csv\", \\\nsep = \";\", thousands = \".\", decimal = \",\", parse_dates = [0, 1], date_format = \"%d.%m.%Y %H:%M\")\n\nconsumption_ms = pd.read_csv(\"01-daten/Realisierter_Stromverbrauch_202301010000_202401010000_Viertelstunde.csv\", \\\nsep = \";\", thousands = \".\", decimal = \",\", parse_dates = [0, 1], date_format = \"%d.%m.%Y %H:%M\")\n\n# Remove the string \" Originalauflösungen\" from column names\ngeneration_ms.columns = generation_ms.columns.str.replace(pat = \" Originalauflösungen\", repl = \"\")\ninstalled_capacity_ms.columns = installed_capacity_ms.columns.str.replace(pat = \" Originalauflösungen\", repl = \"\")\nconsumption_ms.columns = consumption_ms.columns.str.replace(pat = \" Originalauflösungen\", repl = \"\")\n\n# Aggregate renewable generation into a list\nrenewables_ms = ['Biomasse [MWh]', 'Wasserkraft [MWh]', 'Wind Offshore [MWh]', 'Wind Onshore [MWh]', 'Photovoltaik [MWh]', 'Sonstige Erneuerbare [MWh]']\n\npumped_storage_capacity_MWh_ms = 37.4 * 1000\n\n# Projected generation and electricity consumption for 2030 & 2035:\nprint(f\"Onshore Wind 2030:\\t{( windonshore_growth_factor_2030_ms := 115 / (installed_capacity_ms['Wind Onshore [MW]'].sum() / 1000) ):,.2f}\\n\"\n      f\"Offshore Wind 2030:\\t{( windoffshore_growth_factor_2030_ms := 30 / (installed_capacity_ms['Wind Offshore [MW]'].sum() / 1000) ):,.2f}\\n\"\n      f\"Solar 2030:\\t\\t\\t{( solar_growth_factor_2030_ms := 215 / (installed_capacity_ms['Photovoltaik [MW]'].sum() / 1000) ):,.2f}\\n\"\n      f\"Biomass 2030:\\t\\t{8.4 / (installed_capacity_ms['Biomasse [MW]'].sum() / 1000):,.2f}\")\n\nprint(f\"\\n\\nOnshore Wind 2035:\\t{( windonshore_growth_factor_2035_ms := 157 / (installed_capacity_ms['Wind Onshore [MW]'].sum() / 1000) ):,.2f}\\n\"\n      f\"Offshore Wind 2035:\\t{( windoffshore_growth_factor_2035_ms := 40 / (installed_capacity_ms['Wind Offshore [MW]'].sum() / 1000) ):,.2f}\\n\"\n      f\"Solar 2035:\\t\\t\\t{( solar_growth_factor_2035_ms := 309 / (installed_capacity_ms['Photovoltaik [MW]'].sum() / 1000) ):,.2f}\\n\"\n      f\"Biomass 2035:\\t\\t{8.4 / (installed_capacity_ms['Biomasse [MW]'].sum() / 1000):,.2f}\")\n\nload_factor_2030_MWh_ms = (658 * 1000 * 1000) / consumption_ms[\"Gesamt (Netzlast) [MWh]\"].sum()\nload_factor_2035_MWh_ms = (670.4 * 1000 * 1000) / consumption_ms[\"Gesamt (Netzlast) [MWh]\"].sum()\n\nprint(f\"\\nIncrease in electricity consumption 2030 vs 2023 factor: {load_factor_2030_MWh_ms:,.2f}\\n\"\n      f\"Increase in electricity consumption 2035 vs 2023 factor: {load_factor_2035_MWh_ms:,.2f}\")\n\n# Define residual load\nresidual_load_ms = pd.DataFrame()\nresidual_load_ms[\"Netzlast [MWh]\"] = consumption_ms[\"Gesamt (Netzlast) [MWh]\"].copy() \nresidual_load_ms[\"Erneuerbare [MWh]\"] = generation_ms[renewables_ms].sum(axis = \"columns\").copy()\nresidual_load_ms[\"Restlast [MWh]\"] = residual_load_ms[\"Netzlast [MWh]\"] - residual_load_ms[\"Erneuerbare [MWh]\"]\nresidual_load_ms = residual_load_ms[\"Restlast [MWh]\"]\n\ngeneration_2030_ms = generation_ms.copy()\ngeneration_2035_ms = generation_ms.copy()\n\ngeneration_2030_ms[\"Wind Onshore [MWh]\"] = generation_2030_ms[\"Wind Onshore [MWh]\"] * windonshore_growth_factor_2030_ms\ngeneration_2030_ms[\"Wind Offshore [MWh]\"] = generation_2030_ms[\"Wind Offshore [MWh]\"] * windoffshore_growth_factor_2030_ms\ngeneration_2030_ms[\"Photovoltaik [MWh]\"] = generation_2030_ms[\"Photovoltaik [MWh]\"] * solar_growth_factor_2030_ms\n# Biomass does not need to change (factor ~1)\ngeneration_2035_ms[\"Wind Onshore [MWh]\"] = generation_2035_ms[\"Wind Onshore [MWh]\"] * windonshore_growth_factor_2035_ms\ngeneration_2035_ms[\"Wind Offshore [MWh]\"] = generation_2035_ms[\"Wind Offshore [MWh]\"] * windoffshore_growth_factor_2035_ms\ngeneration_2035_ms[\"Photovoltaik [MWh]\"] = generation_2035_ms[\"Photovoltaik [MWh]\"] * solar_growth_factor_2035_ms\n\nconsumption_2030_ms = consumption_ms.copy()\nconsumption_2030_ms[\"Gesamt (Netzlast) [MWh]\"] = consumption_2030_ms[\"Gesamt (Netzlast) [MWh]\"] * load_factor_2030_MWh_ms\nconsumption_2035_ms = consumption_ms.copy()\nconsumption_2035_ms[\"Gesamt (Netzlast) [MWh]\"] = consumption_2035_ms[\"Gesamt (Netzlast) [MWh]\"] * load_factor_2035_MWh_ms\n\nresidual_load_2030_ms = pd.DataFrame()\nresidual_load_2030_ms[\"Netzlast [MWh]\"] = consumption_2030_ms[\"Gesamt (Netzlast) [MWh]\"].copy() \nresidual_load_2030_ms[\"Erneuerbare [MWh]\"] = generation_2030_ms[renewables_ms].sum(axis = \"columns\").copy()\nresidual_load_2030_ms[\"Restlast [MWh]\"] = residual_load_2030_ms[\"Netzlast [MWh]\"] - residual_load_2030_ms[\"Erneuerbare [MWh]\"]\nresidual_load_2030_ms = residual_load_2030_ms[\"Restlast [MWh]\"]\n\nresidual_load_2035_ms = pd.DataFrame()\nresidual_load_2035_ms[\"Netzlast [MWh]\"] = consumption_2035_ms[\"Gesamt (Netzlast) [MWh]\"].copy() \nresidual_load_2035_ms[\"Erneuerbare [MWh]\"] = generation_2035_ms[renewables_ms].sum(axis = \"columns\").copy()\nresidual_load_2035_ms[\"Restlast [MWh]\"] = residual_load_2035_ms[\"Netzlast [MWh]\"] - residual_load_2035_ms[\"Erneuerbare [MWh]\"]\nresidual_load_2035_ms = residual_load_2035_ms[\"Restlast [MWh]\"]\n\nprint(\"\\n2030\\n======================\\n\")\nstorage_2030_ms = calculate_storage_capacity(residual_load_2030_ms, charge_efficiency = 0.9, discharge_efficiency = 0.88, output = False)\nprint(f\"Required storage capacity in 2030: {storage_2030_ms:,.1f} MWh\")\n\nrenewable_share_2030_ms = calculate_renewable_share(residual_load_2030_ms, grid_load = consumption_2030_ms['Gesamt (Netzlast) [MWh]'],\n                                     charge_efficiency = 0.9, discharge_efficiency = 0.88, new_storage_capacitys = [0.5, 0.1, 0.01], output = True)\n\nprint(\"\\n2035\\n======================\\n\")\nstorage_2035_ms = calculate_storage_capacity(residual_load_2035_ms, charge_efficiency = 0.9, discharge_efficiency = 0.88, output = False)\nprint(f\"Required storage capacity in 2035: {storage_2035_ms:,.1f} MWh\")\n\nrenewable_share_2035_ms = calculate_renewable_share(residual_load_2035_ms, grid_load = consumption_2035_ms['Gesamt (Netzlast) [MWh]'],\n                                     charge_efficiency = 0.9, discharge_efficiency = 0.88, new_storage_capacitys = [0.5, 0.1, 0.01], output = True)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nOnshore Wind 2030:\t2.00\nOffshore Wind 2030:\t3.69\nSolar 2030:\t\t\t3.41\nBiomass 2030:\t\t0.99\n\n\nOnshore Wind 2035:\t2.73\nOffshore Wind 2035:\t4.92\nSolar 2035:\t\t\t4.90\nBiomass 2035:\t\t0.99\n\nIncrease in electricity consumption 2030 vs 2023 factor: 1.44\nIncrease in electricity consumption 2035 vs 2023 factor: 1.46\n\n2030\n======================\n\nRequired storage capacity in 2030: 6,170,038.0 MWh\nTotal grid load: 658,000,000.00\nSum of positive residual load: 175,897,072.30\tSum of negative residual load: -85,250,478.82\nBase storage size: 6,170,038.04\tRenewable share without storage: 0.73\n\n   relative_storage_capacity  Renewable share Year1  Renewable share Year2\n0                       1.00                   0.83                   0.84\n1                       0.50                   0.83                   0.83\n2                       0.10                   0.81                   0.81\n3                       0.01                   0.75                   0.75\n\n2035\n======================\n\nRequired storage capacity in 2035: 23,829,823.9 MWh\nTotal grid load: 670,400,000.00\nSum of positive residual load: 125,949,558.61\tSum of negative residual load: -221,510,407.41\nBase storage size: 23,829,823.85\tRenewable share without storage: 0.81\n\n   relative_storage_capacity  Renewable share Year1  Renewable share Year2\n0                       1.00                   0.98                   1.00\n1                       0.50                   0.97                   0.97\n2                       0.10                   0.94                   0.94\n3                       0.01                   0.87                   0.87\n```\n:::\n:::\n\n\nSample solution by Marc Sönnecken. For compatibility with this script, the file paths and object names have been adjusted. The definitions of the functions used have been omitted (identical to those shown in the script). The code has been extended so that the output includes some additional blank lines and markers for the year 2030 and the year 2035.\n\n::::\n\n\n## Reference 2030\n\n::: {.cell execution_count=78}\n``` {.python .cell-code}\nmy_storage_capacitys = [0.9, 0.8, 0.7, 0.6, 0.5, 0.4, 0.3, 0.2, 0.1, 0.08, 0.06, 0.04, 0.02, 0.01]\nmy_charge_efficiency = 0.9\nmy_discharge_efficiency = 0.88\n\n# Generate 2030 dataset\n## windonshore_growth_factor_2030\n## windoffshore_growth_factor_2030\n## solar_growth_factor_2030\n\ngeneration_2030 = generation.copy()\ngeneration_2030['Wind Onshore [MWh]'] *= windonshore_growth_factor_2030\ngeneration_2030['Wind Offshore [MWh]'] *= windoffshore_growth_factor_2030\ngeneration_2030['Photovoltaik [MWh]'] *= solar_growth_factor_2030\n\nrenewables_2030 = pd.Series()\nrenewables = ['Biomasse [MWh]', 'Wasserkraft [MWh]', 'Wind Offshore [MWh]', 'Wind Onshore [MWh]', 'Photovoltaik [MWh]',\n'Sonstige Erneuerbare [MWh]']\nrenewables_2030 = generation_2030[renewables].sum(axis=\"columns\").copy()\n\ngrid_load_2023 = pd.Series()\ngrid_load_2023 = consumption[\"Gesamt (Netzlast) [MWh]\"].copy()\ngrid_load_2030 = grid_load_2023 * load_factor_2030_MWh\n\nresidual_load_2030 = pd.Series()\nresidual_load_2030 = grid_load_2030 - renewables_2030\n\n# Output\nstorage_2030 = calculate_storage_capacity(residual_load_2030, charge_efficiency=my_charge_efficiency, discharge_efficiency=my_discharge_efficiency, output=False)\nprint(f\"Maximum required storage capacity 2030: {storage_2030:,.1f} MWh\\nThis corresponds to {storage_2030 / pumped_storage_capacity_MWh:,.1f} pumped storage equivalents.\")\nprint(\"\\n\")\n\ncalculate_curtailment_effect(residual_load_2030, charge_efficiency=my_charge_efficiency, discharge_efficiency=my_discharge_efficiency, new_storage_capacitys=my_storage_capacitys, output=True)\nprint(\"\\n\")\n\ncalculate_renewable_share(residual_load_2030, grid_load=grid_load_2030, charge_efficiency=my_charge_efficiency, discharge_efficiency=my_discharge_efficiency, new_storage_capacitys=my_storage_capacitys, output=True)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nMaximum required storage capacity 2030: 6,170,038.0 MWh\nThis corresponds to 165.0 pumped storage equivalents.\n\n\n    Storage size  Storage Year1  Cycles Year1  Storage Year2  Cycles Year2\n0       6.17e+06       7.67e+07         11.99       7.67e+07         12.44\n1       5.55e+06       7.67e+07         13.32       7.61e+07         13.71\n2       4.94e+06       7.61e+07         14.92       7.55e+07         15.29\n3       4.32e+06       7.55e+07         16.98       7.49e+07         17.34\n4       3.70e+06       7.49e+07         19.73       7.43e+07         20.06\n5       3.09e+06       7.43e+07         23.58       7.36e+07         23.87\n6       2.47e+06       7.35e+07         29.29       7.29e+07         29.53\n7       1.85e+06       7.17e+07         38.23       7.12e+07         38.45\n8       1.23e+06       6.79e+07         54.56       6.76e+07         54.76\n9       6.17e+05       5.90e+07         95.05       5.86e+07         94.96\n10      4.94e+05       5.59e+07        112.65       5.55e+07        112.41\n11      3.70e+05       5.13e+07        137.99       5.09e+07        137.51\n12      2.47e+05       4.28e+07        172.79       4.25e+07        172.29\n13      1.23e+05       2.66e+07        215.36       2.65e+07        214.86\n14      6.17e+04       1.51e+07        243.93       1.50e+07        243.43\n\n\n    Relative storage size  Curtailed storage Year1  Curtailed storage Year2\n0                    0.90                 1.49e-08                 6.17e+05\n1                    0.80                 5.95e+05                 1.23e+06\n2                    0.70                 1.21e+06                 1.85e+06\n3                    0.60                 1.83e+06                 2.47e+06\n4                    0.50                 2.45e+06                 3.09e+06\n5                    0.40                 3.21e+06                 3.85e+06\n6                    0.30                 5.04e+06                 5.55e+06\n7                    0.20                 8.78e+06                 9.15e+06\n8                    0.10                 1.78e+07                 1.81e+07\n9                    0.08                 2.09e+07                 2.12e+07\n10                   0.06                 2.55e+07                 2.58e+07\n11                   0.04                 3.40e+07                 3.42e+07\n12                   0.02                 5.01e+07                 5.02e+07\n13                   0.01                 6.16e+07                 6.17e+07\n\n\nTotal grid load: 658,000,000.00\nSum of positive residual load: 175,897,072.30\tSum of negative residual load: -85,250,478.82\nBase storage size: 6,170,038.04\tRenewable share without storage: 0.73\n\n    relative_storage_capacity  Renewable share Year1  Renewable share Year2\n0                        1.00                   0.83                   0.84\n1                        0.90                   0.83                   0.83\n2                        0.80                   0.83                   0.83\n3                        0.70                   0.83                   0.83\n4                        0.60                   0.83                   0.83\n5                        0.50                   0.83                   0.83\n6                        0.40                   0.83                   0.83\n7                        0.30                   0.83                   0.83\n8                        0.20                   0.82                   0.82\n9                        0.10                   0.81                   0.81\n10                       0.08                   0.81                   0.81\n11                       0.06                   0.80                   0.80\n12                       0.04                   0.79                   0.79\n13                       0.02                   0.77                   0.77\n14                       0.01                   0.75                   0.75\n```\n:::\n:::\n\n\n## Reference 2035\n\n::: {.cell execution_count=79}\n``` {.python .cell-code}\n# Generate 2035 dataset\n# ## windonshore_growth_factor_2035\n# ## windoffshore_growth_factor_2035\n# ## solar_growth_factor_2035\n\ngeneration_2035 = generation.copy()\ngeneration_2035['Wind Onshore [MWh]'] *= windonshore_growth_factor_2035\ngeneration_2035['Wind Offshore [MWh]'] *= windoffshore_growth_factor_2035\ngeneration_2035['Photovoltaik [MWh]'] *= solar_growth_factor_2035\n\nrenewables_2035 = pd.Series()\nrenewables = ['Biomasse [MWh]', 'Wasserkraft [MWh]', 'Wind Offshore [MWh]', 'Wind Onshore [MWh]', 'Photovoltaik [MWh]',\n'Sonstige Erneuerbare [MWh]']\nrenewables_2035 = generation_2035[renewables].sum(axis=\"columns\").copy()\n\ngrid_load_2023 = pd.Series()\ngrid_load_2023 = consumption[\"Gesamt (Netzlast) [MWh]\"].copy()\ngrid_load_2035 = grid_load_2023 * load_factor_2035_MWh\n\nresidual_load_2035 = pd.Series()\nresidual_load_2035 = grid_load_2035 - renewables_2035\n\n# Output\nstorage_2035 = calculate_storage_capacity(residual_load_2035, charge_efficiency=my_charge_efficiency, discharge_efficiency=my_discharge_efficiency, output=False)\nprint(f\"Maximum required storage capacity 2035: {storage_2035:,.1f} MWh\\nThis corresponds to {storage_2035 / pumped_storage_capacity_MWh:,.1f} pumped storage equivalents.\")\nprint(\"\\n\")\n\ncalculate_curtailment_effect(residual_load_2035, charge_efficiency=my_charge_efficiency, discharge_efficiency=my_discharge_efficiency, new_storage_capacitys=my_storage_capacitys, output=True)\nprint(\"\\n\")\n\ncalculate_renewable_share(residual_load_2035, grid_load=grid_load_2035, charge_efficiency=my_charge_efficiency, discharge_efficiency=my_discharge_efficiency, new_storage_capacitys=my_storage_capacitys, output=True)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nMaximum required storage capacity 2035: 23,829,823.9 MWh\nThis corresponds to 637.2 pumped storage equivalents.\n\n\n    Storage size  Storage Year1  Cycles Year1  Storage Year2  Cycles Year2\n0       2.38e+07       1.49e+08          5.84       1.43e+08          6.01\n1       2.14e+07       1.47e+08          6.44       1.41e+08          6.56\n2       1.91e+07       1.44e+08          7.17       1.38e+08          7.24\n3       1.67e+07       1.42e+08          8.05       1.33e+08          7.99\n4       1.43e+07       1.39e+08          9.19       1.29e+08          8.99\n5       1.19e+07       1.34e+08         10.73       1.24e+08         10.39\n6       9.53e+06       1.29e+08         12.99       1.19e+08         12.49\n7       7.15e+06       1.21e+08         16.49       1.14e+08         15.99\n8       4.77e+06       1.13e+08         23.15       1.08e+08         22.65\n9       2.38e+06       1.01e+08         41.76       9.83e+07         41.26\n10      1.91e+06       9.72e+07         50.47       9.53e+07         49.97\n11      1.43e+06       9.18e+07         63.73       9.04e+07         63.23\n12      9.53e+05       8.23e+07         85.86       8.14e+07         85.36\n13      4.77e+05       6.58e+07        137.54       6.53e+07        137.04\n14      2.38e+05       4.29e+07        179.40       4.26e+07        178.90\n\n\n    Relative storage size  Curtailed storage Year1  Curtailed storage Year2\n0                    0.90                 2.38e+06                 2.38e+06\n1                    0.80                 4.77e+06                 5.01e+06\n2                    0.70                 7.15e+06                 9.77e+06\n3                    0.60                 1.07e+07                 1.45e+07\n4                    0.50                 1.55e+07                 1.93e+07\n5                    0.40                 2.07e+07                 2.41e+07\n6                    0.30                 2.78e+07                 2.88e+07\n7                    0.20                 3.65e+07                 3.52e+07\n8                    0.10                 4.86e+07                 4.48e+07\n9                    0.08                 5.21e+07                 4.79e+07\n10                   0.06                 5.74e+07                 5.27e+07\n11                   0.04                 6.69e+07                 6.18e+07\n12                   0.02                 8.35e+07                 7.78e+07\n13                   0.01                 1.06e+08                 1.00e+08\n\n\nTotal grid load: 670,400,000.00\nSum of positive residual load: 125,949,558.61\tSum of negative residual load: -221,510,407.41\nBase storage size: 23,829,823.85\tRenewable share without storage: 0.81\n\n    relative_storage_capacity  Renewable share Year1  Renewable share Year2\n0                        1.00                   0.98                   1.00\n1                        0.90                   0.98                   1.00\n2                        0.80                   0.98                   0.99\n3                        0.70                   0.98                   0.99\n4                        0.60                   0.98                   0.98\n5                        0.50                   0.97                   0.97\n6                        0.40                   0.97                   0.97\n7                        0.30                   0.96                   0.96\n8                        0.20                   0.95                   0.95\n9                        0.10                   0.94                   0.94\n10                       0.08                   0.94                   0.94\n11                       0.06                   0.93                   0.93\n12                       0.04                   0.92                   0.92\n13                       0.02                   0.90                   0.90\n14                       0.01                   0.87                   0.87\n```\n:::\n:::\n\n\n:::\n\n::::\n\n### Graphical Representation of Selected Storage Configurations\nA graphical representation of the annual storage profile can be generated for different configurations relative to the maximum required storage capacity (C$_{max}$) using the function `calculate_annual_storage(output = False)`. First, a residual load curve for the years 2030 and 2035 is calculated from the projected grid load and the planned renewable expansion.\n\n::: {.cell execution_count=80}\n``` {.python .cell-code}\n# Calculate residual load 2030\n## windonshore_growth_factor_2030\n## windoffshore_growth_factor_2030\n## solar_growth_factor_2030\n\ngeneration_2030 = generation.copy()\ngeneration_2030['Wind Onshore [MWh]'] *= windonshore_growth_factor_2030\ngeneration_2030['Wind Offshore [MWh]'] *= windoffshore_growth_factor_2030\ngeneration_2030['Photovoltaik [MWh]'] *= solar_growth_factor_2030\n\nrenewables_2030 = pd.Series()\nrenewables = ['Biomasse [MWh]', 'Wasserkraft [MWh]', 'Wind Offshore [MWh]', 'Wind Onshore [MWh]', 'Photovoltaik [MWh]', 'Sonstige Erneuerbare [MWh]']\nrenewables_2030 = generation_2030[renewables].sum(axis=\"columns\").copy()\n\ngrid_load_2023 = pd.Series()\ngrid_load_2023 = consumption[\"Gesamt (Netzlast) [MWh]\"].copy()\ngrid_load_2030 = grid_load_2023 * load_factor_2030_MWh\n\nresidual_load_2030 = pd.Series()\nresidual_load_2030 = grid_load_2030 - renewables_2030\n\n# Calculate residual load 2035\n## windonshore_growth_factor_2035\n## windoffshore_growth_factor_2035\n## solar_growth_factor_2035\n\ngeneration_2035 = generation.copy()\ngeneration_2035['Wind Onshore [MWh]'] *= windonshore_growth_factor_2035\ngeneration_2035['Wind Offshore [MWh]'] *= windoffshore_growth_factor_2035\ngeneration_2035['Photovoltaik [MWh]'] *= solar_growth_factor_2035\n\nrenewables_2035 = pd.Series()\nrenewables = ['Biomasse [MWh]', 'Wasserkraft [MWh]', 'Wind Offshore [MWh]', 'Wind Onshore [MWh]', 'Photovoltaik [MWh]', 'Sonstige Erneuerbare [MWh]']\nrenewables_2035 = generation_2035[renewables].sum(axis=\"columns\").copy()\n\ngrid_load_2023 = pd.Series()\ngrid_load_2023 = consumption[\"Gesamt (Netzlast) [MWh]\"].copy()\ngrid_load_2035 = grid_load_2023 * load_factor_2035_MWh\n\nresidual_load_2035 = pd.Series()\nresidual_load_2035 = grid_load_2035 - renewables_2035\n```\n:::\n\n\n&nbsp;\n\nBased on the calculated residual load curves, 80%, 20%, and 4% configurations of the maximum required storage capacity are calculated and visualized.\n\n::: {.panel-tabset}\n\n## 80% 2030\n\n::: {.cell execution_count=81}\n\n::: {.cell-output .cell-output-display}\n![](energiedatenanalyse_files/figure-pdf/cell-82-output-1.pdf){fig-alt='The plot shows the residual load for the year 2030, which is mostly negative but subject to strong and very frequent fluctuations. It also shows the annual profiles in year 1 and year 2 of the storage with a capacity of 80% of the maximum required storage, a charge efficiency of 0.9, and a discharge efficiency of 0.88. In year 1, the storage feeds into the grid and charges continuously until mid-January. By mid-March, the storage frequently discharges strongly or completely. Then, during summer until early December, the storage remains fully or nearly fully charged. In the first half of December, the storage discharges strongly for an extended period and fully twice. By the end of December, it reaches full charge again, which carries into year 2, otherwise similar to year 1.'}\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\nNumber of cycles year 1: 14.92\nNumber of cycles year 2: 15.29\nTotal grid load: 658,000,000.00\nSum of positive residual load: 175,897,072.30\tSum of negative residual load: -85,250,478.82\nBase storage size: 6,170,038.04\tRenewable share without storage: 0.73\n\n   relative_storage_capacity  Renewable share Year1  Renewable share Year2\n0                        1.0                   0.83                   0.84\n1                        0.8                   0.83                   0.83\n\nThe storage size is 4,936,030.4 MWh\nThis corresponds to 132.0 pumped storage equivalents.\n```\n:::\n:::\n\n\n## 80% 2035\n\n::: {.cell execution_count=82}\n\n::: {.cell-output .cell-output-display}\n![](energiedatenanalyse_files/figure-pdf/cell-83-output-1.pdf){fig-alt='The plot shows the residual load for the year 2035, which is mostly negative and rarely positive despite strong and frequent fluctuations. It also shows the annual profiles in year 1 and year 2 of the storage with a capacity of 80% of the maximum required storage, a charge efficiency of 0.9, and a discharge efficiency of 0.88. In year 1, the storage feeds into the grid and charges continuously until fully charged after a few days. From mid to late January, the storage discharges strongly, reaching full depletion. From early February to early December, the storage remains nearly fully charged. In the first half of December, the storage discharges strongly but is only briefly empty. By the end of December, full charge is reached again, which carries into year 2, otherwise similar to year 1.'}\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\nNumber of cycles year 1: 7.17\nNumber of cycles year 2: 7.24\nTotal grid load: 670,400,000.00\nSum of positive residual load: 125,949,558.61\tSum of negative residual load: -221,510,407.41\nBase storage size: 23,829,823.85\tRenewable share without storage: 0.81\n\n   relative_storage_capacity  Renewable share Year1  Renewable share Year2\n0                        1.0                   0.98                   1.00\n1                        0.8                   0.98                   0.99\n\nThe storage size is 19,063,859.1 MWh\nThis corresponds to 509.7 pumped storage equivalents.\n```\n:::\n:::\n\n\n## 20% 2030\n\n::: {.cell execution_count=83}\n\n::: {.cell-output .cell-output-display}\n![](energiedatenanalyse_files/figure-pdf/cell-84-output-1.pdf){fig-alt='The plot shows the residual load for the year 2030, corresponding to the previous scenario. It also shows the annual profiles in year 1 and year 2 of the storage with a capacity of 20% of the maximum required storage, a charge efficiency of 0.9, and a discharge efficiency of 0.88. In year 1, the storage feeds into the grid and charges continuously until fully charged after a few days. From mid-January to mid-March, the storage discharges strongly four times to full depletion. From mid-March to mid-August, the storage remains nearly fully charged. This is followed by a one-month period of strong and temporarily full discharge. From mid-September to early December, pronounced charge and discharge cycles occur. At the beginning of December, the storage is empty for several days, then briefly reaches a high charge level before discharging fully again. In the second half of December, full charge is reached again, which carries into year 2, otherwise similar to year 1.'}\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\nNumber of cycles year 1: 54.56\nNumber of cycles year 2: 54.76\nTotal grid load: 658,000,000.00\nSum of positive residual load: 175,897,072.30\tSum of negative residual load: -85,250,478.82\nBase storage size: 6,170,038.04\tRenewable share without storage: 0.73\n\n   relative_storage_capacity  Renewable share Year1  Renewable share Year2\n0                        1.0                   0.83                   0.84\n1                        0.2                   0.82                   0.82\n\nThe storage size is 1,234,007.6 MWh\nThis corresponds to 33.0 pumped storage equivalents.\n```\n:::\n:::\n\n\n## 20% 2035\n\n::: {.cell execution_count=84}\n\n::: {.cell-output .cell-output-display}\n![](energiedatenanalyse_files/figure-pdf/cell-85-output-1.pdf){fig-alt='The plot shows the residual load for the year 2035, corresponding to the previous scenario. It also shows the annual profiles in year 1 and year 2 of the storage with a capacity of 20% of the maximum required storage, a charge efficiency of 0.9, and a discharge efficiency of 0.88. The annual profiles are similar to those in 2030. However, the periods of strong discharge at the beginning of the year are significantly shorter, and the storage usually reaches full charge again after a short time. The strong discharge at the end of August does not occur; the storage drops only to about half capacity. The strong discharge in early December is less drastic but still occurs fully several times.'}\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\nNumber of cycles year 1: 23.15\nNumber of cycles year 2: 22.65\nTotal grid load: 670,400,000.00\nSum of positive residual load: 125,949,558.61\tSum of negative residual load: -221,510,407.41\nBase storage size: 23,829,823.85\tRenewable share without storage: 0.81\n\n   relative_storage_capacity  Renewable share Year1  Renewable share Year2\n0                        1.0                   0.98                   1.00\n1                        0.2                   0.95                   0.95\n\nThe storage size is 4,765,964.8 MWh\nThis corresponds to 127.4 pumped storage equivalents.\n```\n:::\n:::\n\n\n## 4% 2030\n\n::: {.cell execution_count=85}\n\n::: {.cell-output .cell-output-display}\n![](energiedatenanalyse_files/figure-pdf/cell-86-output-1.pdf){fig-alt='The plot shows the residual load for the year 2030, which corresponds to the previous scenario. It also shows the annual profiles in year 1 and year 2 of the storage with a capacity of 4% of the maximum required storage, a charge efficiency of 0.9, and a discharge efficiency of 0.88. Throughout the year, short consecutive cycles of full charge and discharge occur. Only in early January and late December is the storage full for approximately 2 weeks each.'}\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\nNumber of cycles year 1: 172.79\nNumber of cycles year 2: 172.29\nTotal grid load: 658,000,000.00\nSum of positive residual load: 175,897,072.30\tSum of negative residual load: -85,250,478.82\nBase storage size: 6,170,038.04\tRenewable share without storage: 0.73\n\n   relative_storage_capacity  Renewable share Year1  Renewable share Year2\n0                       1.00                   0.83                   0.84\n1                       0.04                   0.79                   0.79\n\nThe storage size is 246,801.5 MWh\nThis corresponds to 6.6 pumped storage equivalents.\n```\n:::\n:::\n\n\n## 4% 2035\n\n::: {.cell execution_count=86}\n\n::: {.cell-output .cell-output-display}\n![](energiedatenanalyse_files/figure-pdf/cell-87-output-1.pdf){fig-alt='The plot shows the residual load for the year 2035, which corresponds to the previous scenario. It also shows the annual profiles in year 1 and year 2 of the storage with a capacity of 4% of the maximum required storage, a charge efficiency of 0.9, and a discharge efficiency of 0.88. Throughout the year, short consecutive cycles of full charge and discharge occur. Only in early January and late December is the storage full for approximately 2 weeks. During the summer, the cycle density is even higher than in 2030.'}\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\nNumber of cycles year 1: 85.86\nNumber of cycles year 2: 85.36\nTotal grid load: 670,400,000.00\nSum of positive residual load: 125,949,558.61\tSum of negative residual load: -221,510,407.41\nBase storage size: 23,829,823.85\tRenewable share without storage: 0.81\n\n   relative_storage_capacity  Renewable share Year1  Renewable share Year2\n0                       1.00                   0.98                   1.00\n1                       0.04                   0.92                   0.92\n\nThe storage size is 953,193.0 MWh\nThis corresponds to 25.5 pumped storage equivalents.\n```\n:::\n:::\n\n\n## Code Example\n\n::: {.cell execution_count=87}\n``` {.python .cell-code}\n# Generate data\n## Determine storage size and calculate 80 percent\nstorage_capacity_2030_80 = calculate_storage_capacity(residual_load_2030, charge_efficiency=0.9, discharge_efficiency=0.88, output=False) * 0.8\n\n## Determine annual storage profile\nstorage_2030_80_eff_90_88 = calculate_annual_storage(residual_load_2030, storage_capacity=storage_capacity_2030_80, charge_efficiency=0.9, discharge_efficiency=0.88, output=False)\n\nannual_storage_year1 = storage_2030_80_eff_90_88[1]\nannual_storage_year2 = storage_2030_80_eff_90_88[2]\n\n# Generate x-ticks\nmonths_index = generation[~generation[\"Datum von\"].dt.month.duplicated()].index\nmonth_names = generation[\"Datum von\"].iloc[months_index].dt.strftime(\"%B\") \n\n# Create plot with three subplots\nfig, (ax1, ax2, ax3) = plt.subplots(3, 1, figsize=(7.5, 6), height_ratios=[2, 1, 1], sharex=True, layout='tight')\nplt.suptitle('Residual Load 2030 and Annual Profile of a Storage with\\n C$_{max}$ = 0.8, η$_{charge}$ = 0.9 and η$_{discharge}$ = 0.88')\nplt.xticks(months_index, month_names, rotation=45)\nplt.minorticks_off()\nplt.setp([ax1, ax2, ax3], xlim=(residual_load.index.min() - len(residual_load.index)/100, residual_load.index.max() * 1.01))\nplt.setp([ax2, ax3], ylim=(0, max(max(annual_storage_year1), max(annual_storage_year2)) * 1.2))\n\n## Plot residual load\nax1.plot(residual_load_2030, label=\"Residual Load\")\nax1.grid()\nax1.set_ylabel('MWh')\nax1.legend()\n\n## Plot annual_storage_year1\nax2.plot(annual_storage_year1, color='black', linestyle='-', label='Storage Year 1')\nax2.grid()\nax2.set_ylabel('MWh')\nax2.legend()\n\n## Plot annual_storage_year2\nax3.plot(annual_storage_year2, color='black', linestyle='-', label='Storage Year 2')\nax3.tick_params(axis='x', rotation=45)\nax3.set_ylabel('MWh')\nax3.grid()\nax3.legend()\n\nplt.show()\n\n# Calculate number of cycles; passing tuple of efficiencies not needed\ncalculate_cycles(storage_2030_80_eff_90_88, output=True)\n\n# Calculate renewable share\ncalculate_renewable_share(residual_load_2030, grid_load=grid_load_2030, charge_efficiency=0.9, discharge_efficiency=0.88, new_storage_capacitys=[0.8], output=True)\n\n# Print storage size\nprint(f\"\\nThe storage size is {storage_2030_80_eff_90_88[0]:,.1f} MWh\\n\"\n      f\"This corresponds to {storage_2030_80_eff_90_88[0] / pumped_storage_capacity_MWh:,.1f} pumped storage equivalents.\")\n```\n:::\n\n\n:::\n\nWith an 80-percent sizing of the storage, the system appears oversized. In 2030, the storage can hardly utilize its full capacity over the course of the year. The storage rarely reaches state-of-charge levels around 50 percent. Only during the turn of the year is the maximum capacity used. In contrast, in 2035 the storage is mostly fully charged, and only minimal charging and discharging occurs. In particular, in 2035 the storage undergoes only a few full cycles.\n\nThe storage capacity required in 2030 of 4,936 GWh corresponds to 132 times the existing pumped-storage plants or 99 annual productions of the Tesla Gigafactory Berlin-Brandenburg in its first expansion stage with 50 GWh/year ([Wikipedia](https://en.wikipedia.org/wiki/List_of_battery_cell_factories_in_Germany)). The storage capacity required in 2035 of 19,064 GWh corresponds to 510 times the existing pumped-storage plants or 381 annual productions of the Tesla Gigafactory Berlin-Brandenburg.  \n**Note:** The reference to the Tesla Gigafactory Berlin-Brandenburg is only for context. The Grünheide factory currently does not produce battery cells. Plans for additional battery factories in Germany have recently been canceled.\n\nWith a 20-percent sizing, more full cycles and more extensive partial cycles are achieved. Nevertheless, in 2035 consistently high state-of-charge levels are observed from April to the end of August. In 2030, 1,234 GWh of storage capacity would be needed, and in 2035, 4,766 GWh. This corresponds to 33 and 127 times the existing pumped-storage capacity or 25 and 95 annual productions of the Tesla Gigafactory Berlin-Brandenburg in the first expansion stage.\n\nThe 4-percent sizing shows a constant up-and-down pattern. At this scale, operating a storage economically could be feasible. This would require 247 GWh in 2030 and 953 GWh in 2035. 247 GWh corresponds to 6.6 times the existing pumped-storage capacity or 5 annual productions of the Tesla Gigafactory Berlin-Brandenburg in the first expansion stage. 953 GWh corresponds to 25.5 pumped-storage equivalents and 19 annual productions of the Tesla Gigafactory Berlin-Brandenburg.\n\nIn all scenarios, it is notable that the number of cycles in year 1 and year 2 is almost identical. The difference of half a cycle arises because the storage starts the first year empty. Depending on the scenario, the storage is then first fully charged over the course of the year (80% sizing), within a few weeks (20% sizing), or almost immediately (4% sizing).\n\nIt is evident that the 80-20 rule ([Pareto principle](https://en.wikipedia.org/wiki/Pareto_principle)) applies to storage sizing: 20 percent of the effort achieves 80 percent of the result. If in 2035 the share of renewable energy without storage is 81 percent, then 19 percent must be covered by storage (or otherwise). To achieve 100 percent demand coverage from electricity storage, 23.8 TWh of storage capacity would be required. A storage 20 percent of this size achieves a total renewable share of 95 percent. A storage 20 percent of that size achieves a total share of 92 percent.\n\n## Bonus: Estimating the Required Peak Power of Backup Power Plants\nFrom the calculation of different storage sizes, it became clear that even relatively small storage systems can lead to a high share of renewable energy in the electricity mix. Nevertheless, smaller storage capacities mean that at certain times, the grid load must be met by backup load-following power plants. In this section, the required generation capacity of these backup plants is estimated. The maximum positive residual load after discharging is multiplied by four, since the dataset is based on 15-minute intervals.\n\n::: {.cell execution_count=88}\n``` {.python .cell-code}\npeak_power_2030 = calculate_renewable_share(residual_load_2030, grid_load = grid_load_2030, charge_efficiency = 0.9, discharge_efficiency = 0.88, new_storage_capacitys = [0.2, 0.04], output = False)\npeak_power_2035 = calculate_renewable_share(residual_load_2035, grid_load = grid_load_2035, charge_efficiency = 0.9, discharge_efficiency = 0.88, new_storage_capacitys = [0.2, 0.04], output = False)\n\n## Examine data structure\n## Column 0 contains storage size = 1, the following columns contain the new storage sizes. Row 0 contains the residual load curve for year 1, row 1 for year 2\n# print(peak_power_2030.shape)\n# print(peak_power_2030.head())\n\n# Row 1 contains the annual profile in year 2\n# Column 0 contains the baseline scenario with storage size = 1\nprint(f\"\\nPeak power 2030 for Cmax = 0.20: {max(peak_power_2030.iloc[1, 1]) * 4 / 1000:.2f} GW\\n\"\n      f\"Peak power 2030 for Cmax = 0.04: {max(peak_power_2030.iloc[1, 2]) * 4 / 1000:.2f} GW\\n\"\n      f\"Peak power 2035 for Cmax = 0.20: {max(peak_power_2035.iloc[1, 1]) * 4 / 1000:.2f} GW\\n\"\n      f\"Peak power 2035 for Cmax = 0.04: {max(peak_power_2035.iloc[1 , 2]) * 4 / 1000:.2f} GW\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n\nPeak power 2030 for Cmax = 0.20: 87.64 GW\nPeak power 2030 for Cmax = 0.04: 87.64 GW\nPeak power 2035 for Cmax = 0.20: 87.53 GW\nPeak power 2035 for Cmax = 0.04: 87.53 GW\n```\n:::\n:::\n\n\n# Key Takeaways\nIn the comparative analysis of generation and consumption data for Germany and Austria, it became clear that comparable datasets can be structured differently. The intention behind the compilation of a dataset does not necessarily align with the objectives of your analysis, which, for example, may justify separating power plants from energy storage systems. In this module, you have learned two general approaches for analyzing datasets that can be applied to other domains and datasets. The first approach involves reading, organizing, checking, and validating data. The second approach involves describing, exploring, and evaluating data using key metrics and data visualization techniques.\n\nMetric-based and visual methods of data analysis complement each other and help in understanding a dataset. For example, a purely metric-based approach might easily overlook the shutdown of German nuclear power plants, whereas this is clearly visible in the graphical representation of the annual profile. Conversely, when solely visualizing the generation share of different power plant types in Austria, charging and discharging of storage systems might be unintentionally summed.\n\nThe tools presented provide you with the means to make data-driven decisions and participate in climate and energy policy discussions. However, you should always keep in mind that analyzing aggregate data simplifies relationships and carries the risk of ecological misinterpretation. A comprehensive data analysis therefore also involves reflecting on and transparently communicating the blind spots in your own approach.\n\n# Learning Check\n\n\n## Skills Quiz\n<!-- (Optionally collapsible callout block, text reference for PDF, polished solutions can be decided later via Lumi) -->\n\n(@) What is the full command to convert the following string into a `datetime` object using the Python module Pandas?\n\n```{raw}\n\ndate_str = '2008-Oct-29'\ndate_pd = pd.to_datetime(date_str, format = \" ... \")\n\n```\n\n&nbsp;\n\n(@) Which method can be used to concatenate the data series a, b, and c?\n\n    a) pandas.concat(a, b, c)\n\n    b) pandas.append(a, b, c)\n\n    c) pandas.concatenate[a, b, c]\n\n    d) pandas.concat([a, b, c])\n\n&nbsp;\n\n(@) What is the purpose of descriptive data analysis?\n\n    a) Identify errors in the dataset\n\n    b) Load required modules\n\n    c) Prepare for exploratory and inferential data analysis\n\n    d) Gain an overview of the dataset\n\n&nbsp;\n\n(@) Which statements are true?\n\n    a) Exploratory data analysis is an iterative process to explore a dataset and generate new questions based on the insights gained.\n\n    b) The methods of exploratory data analysis are strictly predefined.\n\n    c) Exploratory data analysis is purely numeric.\n\n    d) Exploratory data analysis prepares for inferential data analysis.\n\n&nbsp;\n\n(@) The sizing of an electricity storage system depends on:\n\n    a) The cyclic nature of charging\n\n    b) The ratio of storable excess generation to the load to be served by the storage\n\n    c) The capping of generation peaks\n\n    d) The efficiency of the storage system\n\n::: {#tip-skills-quiz .callout-tip title=\"Solutions\" collapse=\"true\"}\n\nSolution 1: date_pd = pd.to_datetime(date_str, format = \"%Y-%b-%d\")\n\nSolution 2: pandas.concat([a, b, c])\n\nSolution 3: a, c, d\n\nSolution 4: a, d\n\nSolution 5: a, b, c, d\n\n:::\n\n## Exercises\n\nWithin the framework of inferential data analysis, it was found that by capping generation peaks in a power system dominated by renewable surplus production, the required electricity storage can be dimensioned orders of magnitude smaller. However, a few percent of the annual electricity demand would remain that cannot be covered by ongoing renewable generation or storage. One option would be to operate biomass power plants in load-following mode.\n\nCalculate the required storage size (charging efficiency = 0.9, discharging efficiency = 0.88) if the share of renewable energy in 2035 is to be 100 percent and biomass power plants are operated in load-following mode. Assume that biomass plants store gas production during periods when the electricity demand is fully met by other renewable sources and generate electricity when there is positive residual load. The production profile of biogas plants corresponds to the generation curve of 2023.\n\n  - How large would the gas storage need to be (in MWh of electrical energy)?\n\n  - What is the maximum required electricity generation capacity of the biomass plants, both absolute and relative to the installed 2023 capacity?\n\n  - How large does the required electricity storage need to be if biomass power plants are operated in load-following mode?\n\n",
    "supporting": [
      "energiedatenanalyse_files/figure-pdf"
    ],
    "filters": []
  }
}