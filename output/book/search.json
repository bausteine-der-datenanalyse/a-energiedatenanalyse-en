[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Anwendungsbaustein Energiedatenanalyse",
    "section": "",
    "text": "Preamble\n\n\n\n\n\n\n\nBausteine Computergestützter Datenanalyse von Lukas Arnold, Simone Arnold, Florian Bagemihl, Matthias Baitsch, Marc Fehr, Franca Hollmann, Maik Poetzsch und Sebastian Seipel. Anwendungsbaustein Energiedatenanalyse von Maik Poetzsch ist lizensiert unter CC BY 4.0. Das Werk ist abrufbar auf GitHub. Ausgenommen von der Lizenz sind alle Logos und anders gekennzeichneten Inhalte. 2025\n\n\n\nZitiervorschlag\nArnold, Lukas, Simone Arnold, Florian Bagemihl, Matthias Baitsch, Marc Fehr, Franca Hollmann, Maik Poetzsch, und Sebastian Seipel. 2025. „Bausteine Computergestützter Datenanalyse. Anwendungsbaustein Energiedatenanalyse“. https://github.com/bausteine-der-datenanalyse/a-energiedatenanalyse.\nBibTeX-Vorlage\n@misc{BCD-a-ernergiedatenanalyse-2025,\n title={Bausteine Computergestützter Datenanalyse. Anwendungsbaustein Energiedatenanalyse},\n author={Arnold, Lukas and Arnold, Simone and Bagemihl, Florian and Baitsch, Matthias and Fehr, Marc and Hollmann, Franca and Poetzsch, Maik and Seipel, Sebastian},\n year={2025},\n url={https://github.com/bausteine-der-datenanalyse/a-energiedatenanalyse}} \n\n\n\nPrerequisites\nThe processing time for this module is approximately placeholder. The following modules are required for completing this unit, and the listed libraries are used:\n\nTool Module: Python\n\nModule random\nModule Pandas\nModule NumPy\nModule matplotlib.pyplot\n\nMethod Module: Reading Structured Data Sets\n\nCross-reference to:\n\nMethod Module: Fundamentals of Statistics (Chapter 2 — Individual Characteristics)\n\nThis module uses electricity market data for the year 2023. Data for Germany is provided by the Federal Network Agency and can be accessed at https://www.smard.de/. Data for Austria is provided by Austrian Power Grid AG and can be accessed at https://markttransparenz.apg.at/.\n\n\nLearning Objectives\nIn this module, you will learn methods and tools for energy data analysis. Principles and procedures for the design of an electrical energy storage system form a central thematic focus.\nThe methods covered include:\n\ndescriptive data analysis\nexploratory data analysis\ninferential data analysis\ncomplementary use of indicator-based and visualization-based methods\n\nThe tools presented include:\n\nvisualization of a sorted load-duration curve\ncalculation of residual load and remaining load\nlimit-current analysis\nsizing of an electrical storage system considering efficiency and curtailment of generation peaks, calculation of the realized number of cycles, annual profiles, and the potential along the expansion pathway of renewable energies\n\nKeywords: comparative analysis of electricity market data, data visualization, storage system design",
    "crumbs": [
      "Preamble"
    ]
  },
  {
    "objectID": "skript/energiedatenanalyse.html",
    "href": "skript/energiedatenanalyse.html",
    "title": "1  Energy Data Analysis",
    "section": "",
    "text": "2 Background\nElectric power is generated in power plants and transported via the power grid to electricity consumers. Power generation and consumption must always be balanced. The share of weather-dependent renewable generation is increasing, but electricity cannot yet be stored economically on a large scale. In 2023, pumped-storage power plants in Germany, with a capacity of 37.4 GWh (Heimerl und Kohler 2017, p. 77), fed in 11.1 TWh of electricity, which corresponded to 2.4 percent of Germany’s total electricity consumption of 458.3 TWh (Fraunhofer Institut für Solare Energiesysteme ISE o. J.). Power plant scheduling and storage sizing based on generation and consumption data is therefore a relevant application area for data analysis.\nThe Federal Network Agency publishes, among other things, data on electricity generation, consumption, and wholesale prices on https://www.smard.de/. (Note: Power plant data is available for generation units with an installed generation capacity of at least 100 MW.)",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Energy Data Analysis</span>"
    ]
  },
  {
    "objectID": "skript/energiedatenanalyse.html#visualization",
    "href": "skript/energiedatenanalyse.html#visualization",
    "title": "1  Energy Data Analysis",
    "section": "5.1 Visualization",
    "text": "5.1 Visualization\nAnalyzing the descriptive statistics for 12 different types of generation requires focus. Complex information should therefore be presented graphically.\nFor a quick overview, for example of the distribution of total generation capacity by generation type, a pie or donut chart is useful. However, as explained in the Statistics Basics Module (Chapter 2: Single Variables), this type of chart has the drawback that with an increasing number of categories (or characteristics to be displayed), it quickly becomes cluttered and the angles become difficult to read accurately.\nIn the following donut chart created using the method pd.DataFrame.plot.pie(), two adjustments were made: first, the automatic annotation of the percentage values was enabled using the format string autopct='%1.1f%%'. Second, the order of the columns in the DataFrame was swapped because otherwise the percentage labels and the labels of smaller slices overlap. Additionally, the substring ” [MWh]” was removed from the column names for the slice labels. While this improves the readability of the chart, this is not the main reason why the substring was removed.\nWhat do you think is the reason for this?\n\n\n\n\n\n\nTipp 5.1: Pie Chart Solution\n\n\n\n\n\nA pie or donut chart represents proportions and is therefore dimensionless.\n\n\n\nYou can find the details of the plot creation in the second tab.\n\nPlotting with PandasCode for Pandas\n\n\n\n\n\n\n\nShare of electricity generation\n\n\n\n\n\n\n\n# plot the pie first try - Other Erneuerbare [MWh] overlaps with Kernenergie [MWh] and Pumpspeicher [MWh]\n# generation.sum(numeric_only = True).plot.pie(colormap = \"Blues\", startangle = 90, rotatelabels = True, explode = explosion)\n\n# rearrange columns, remove \" [MWh]\"\nplotting_data = generation.copy()\ncolumn_to_move = plotting_data.pop(\"Kernenergie [MWh]\")\nplotting_data.insert(4, \"Kernenergie [MWh]\", column_to_move)\n\ncolumn_to_move = plotting_data.pop(\"Pumpspeicher [MWh]\")\nplotting_data.insert(10, \"Pumpspeicher [MWh]\", column_to_move)\n\nplotting_data.columns = plotting_data.columns.str.replace(pat = \" [MWh]\", repl = \"\")\n\n# plot the pie\nax = plotting_data.sum(numeric_only = True).plot.pie(colormap = \"Blues\", startangle = 90, rotatelabels = False, autopct='%1.1f%%', pctdistance = 0.6, textprops = dict(size = 7, color = 'black'), wedgeprops = {\"linewidth\": 0.5, \"edgecolor\": \"white\"})\n\n# make a donut\ncircle = plt.Circle((0, 0), radius = 0.7, color = \"white\")\nax.add_patch(circle)\n\nplt.show()\n\n\n\n\n\nAggregating Data\nDue to the numerous features, the descriptive and visual representation of generation capacity does not necessarily yield a clear conclusion. One way to better understand the data is to group similar features together. In the following, renewable and conventional (fossil-fuel based) generation types are aggregated to display their share values in a donut chart. Both groups are also shown in a bar chart. The matplotlib.pyplot module is used for the visualization. Details of the plot creation can be found in the second tab.\n\nPlotting with matplotlibCode for matplotlib\n\n\n\n\n\n\n\nAbsolute electricity generation and relative shares by generation type\n\n\n\n\n\n\n\n# Define renewables and conventionals, sum each\n\n## Renewables\nplotting_data = generation.copy()\nplotting_data.drop(columns = ['Datum von', 'Datum bis', 'Biomasse [MWh]', 'Wasserkraft [MWh]', 'Wind Offshore [MWh]',\n'Wind Onshore [MWh]', 'Photovoltaik [MWh]',\n'Sonstige Erneuerbare [MWh]'], inplace = True)  # drop date columns; inplace=False returns a copy and does nothing without assignment\nrenewables = ['Biomasse [MWh]', 'Wasserkraft [MWh]', 'Wind Offshore [MWh]', 'Wind Onshore [MWh]', 'Photovoltaik [MWh]',\n'Sonstige Erneuerbare [MWh]']\nplotting_data[\"Erneuerbare\"] = generation[renewables].sum(axis = 'columns')\n\n## Conventionals\nplotting_data.drop(columns = ['Braunkohle [MWh]',  'Steinkohle [MWh]', 'Erdgas [MWh]', 'Sonstige Konventionelle [MWh]'], inplace = True)\nconventionals = ['Braunkohle [MWh]',  'Steinkohle [MWh]', 'Erdgas [MWh]', 'Sonstige Konventionelle [MWh]']\nplotting_data[\"Konventionelle\"] = generation[conventionals].sum(axis = 'columns')\n\n# rearrange columns, remove \" [MWh]\"\nplotting_data = plotting_data[['Erneuerbare', 'Pumpspeicher [MWh]', 'Konventionelle', 'Kernenergie [MWh]']]\nplotting_data.columns = plotting_data.columns.str.replace(pat = \" [MWh]\", repl = \"\")\n\n# for checking - axis=columns sums columns row-wise\n## print(renewables)\n## print(generation[renewables].sum(axis = 'columns'))\n## print(plotting_data.columns)\n## print(plotting_data[0:3])\n\n# create figure with three subplots\nplt.figure(figsize = (7.5, 7.5))\n\nnrows = 4\nncols = 2\nfont_size = 8\n\n# value for shared x-axis on barplots\nx_lim = generation.sum(numeric_only = True).max() * 1.1\n\n# array of colors\nmy_colors = plt.get_cmap('Blues')(np.linspace(0.2, 1, len(plotting_data.sum())))\n\n# plot the pie, use 4 out of 8 panels = middle 2 rows\nax = plt.subplot(nrows, ncols, (3, 6))\nplt.pie(x = plotting_data.sum(), colors = my_colors, startangle = 350, labels = list(plotting_data.columns), autopct='%1.1f%%', pctdistance = 0.5, textprops = dict(size = font_size + 1), wedgeprops = {\"linewidth\": 0.5, \"edgecolor\": \"white\"})\n\n# make a donut\ncircle = plt.Circle((0, 0), radius = 0.65, color = \"white\")\nax.add_patch(circle)\n\n# top row unstacked barplot \nplt.subplot(nrows, ncols, (1, 2))\ngeneration[renewables].sum().sort_values(ascending = False).plot.barh(fontsize = font_size, xlim = (0, x_lim), color = my_colors[0], edgecolor = 'darkgrey')\nplt.title(\"Renewables\", fontsize = font_size + 2)\n\n# bottom row unstacked barplot \nplt.subplot(nrows, ncols, (7, 8))\ngeneration[conventionals].sum().sort_values(ascending = False).plot.barh(fontsize = font_size, xlim = (0, x_lim), color = my_colors[2], edgecolor = 'darkgrey')\nplt.title(\"Conventionals\", fontsize = font_size + 2)\n\nplt.tight_layout()\nplt.show()\n\n\n\n\n  By aggregating similar types of electricity generation, the donut chart has been reduced to four generation categories. The generation types with only small shares of total electricity generation, pumped storage and nuclear energy, therefore stand out clearly compared to the individual representation of all generation types. Based on this, it can be discussed whether the shown aggregation is appropriate. On one hand, nuclear energy could be assigned to the conventionals if this group is defined not by fossil fuel use but by the principle of thermal steam expansion. On the other hand, generation from pumped storage should be critically examined. This aspect is discussed in the following section.\n\n\n\n\n\n\nHinweis 5.1: Note\n\n\n\nComplex graphics, like the one shown here, should generally be used sparingly because they can be difficult to understand and interpret. Therefore, the purpose of the graphic and the key conclusions should be clearly explained in the text.\nTip: Imagine you were showing the graphic spontaneously to a friend who hasn’t read your work. How would you explain the graphic to your friend? Write this explanation in your report.\n\n\n\n\nGeneration, Storage, Injection\nPumped-storage power plants are energy storage systems that do not produce primary energy but store electricity generated by other producers and feed it back into the grid when needed. Which producers supplied electricity to fill the pumped storage is analyzed in Kapitel 6. The realized grid feed-in of pumped-storage plants corresponds to the energy production of other power plants reduced by the losses incurred during charging and discharging (as well as any storage losses such as evaporation or seepage). The efficiency of pumped-storage power plants can be calculated using the available data for the year 2023.\nWhat was the efficiency of the pumped-storage power plants in 2023?\n\n\n\n\n\n\nTipp 5.2: Solution: Pumped Storage Efficiency\n\n\n\n\n\n\nprint(f\"Total Generation Pumped Storage: {generation['Pumpspeicher [MWh]'].sum():,.2f}\\n\"\n      f\"Total Consumption Pumped Storage: {consumption['Pumpspeicher [MWh]'].sum():,.2f}\\n\"\n      f\"{41 * '='}\\n\"\n      f\"Efficiency in Percent: \\t\\t\\t{(generation['Pumpspeicher [MWh]'].sum() / consumption['Pumpspeicher [MWh]'].sum()) * 100:,.2f}\")\n\nTotal Generation Pumped Storage: 11,149,398.50\nTotal Consumption Pumped Storage: 14,095,632.75\n=========================================\nEfficiency in Percent:          79.10\n\n\n\n\n\nThe actually realized electricity generation is therefore the cumulative electricity generation of the pumped-storage power plants published by the Federal Network Agency, plus the storage losses. The Federal Network Agency includes this value in the electricity consumption dataset. The following code uses the “walrus” operator :=, which allows assignments within expressions (here within the print statement). This makes the code more concise (although readability decreases). Assignments made using the walrus operator must be enclosed in parentheses:\n\nprint(f\"Storage losses:\\t\\t\\t{(storage_losses := (consumption[\"Pumpspeicher [MWh]\"].sum() - generation[\"Pumpspeicher [MWh]\"].sum()) / (1000 * 1000)):&gt;6.2f} TWh\\n\"\n      f\"Cumulative electricity generation:\\t{(cumulative_generation := generation.sum(numeric_only=True).sum() // (1000 * 1000)):,.2f} TWh\\n\"\n      f\"Total:\\t\\t\\t\\t\\t\\t{storage_losses + cumulative_generation:,.2f} TWh\\n\\n\")\n\nStorage losses:           2.95 TWh\nCumulative electricity generation:  448.00 TWh\nTotal:                      450.95 TWh\n\n\n\n\nThe difference between the actual realized and the electricity generation published by the Federal Network Agency amounts to just under 3 TWh, which is less than 1 percent of the total electricity generation. In other countries, the correct allocation of data is also materially significant. In Austria, pumped-storage power plants play an important role in the electricity mix.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Energy Data Analysis</span>"
    ]
  },
  {
    "objectID": "skript/energiedatenanalyse.html#sec-task-descriptive-data-analysis",
    "href": "skript/energiedatenanalyse.html#sec-task-descriptive-data-analysis",
    "title": "1  Energy Data Analysis",
    "section": "5.2 Task: Descriptive Data Analysis",
    "text": "5.2 Task: Descriptive Data Analysis\n\n\n\n\n \n\n\nView of the Schlegeisspeicher from Höhenweg. Photo by Klaus Kettner is licensed under CC BY-SA 3.0 and available on Wikimedia. The image was cropped and saved in PNG format. 2012.\n\n \nSimilar to the Federal Network Agency, the Austrian Power Grid AG (APG) publishes electricity market data at https://markttransparenz.apg.at/. Generation data for the year 2023 can be downloaded via this link.\nThe following file is attached to this script.\n\n\n\n\n\n\n\n\nData\nFilename\n\n\n\n\nRealized Electricity Generation 2023\nAGPT_2022-12-31T23_00_00Z_2023-12-31T23_00_00Z_15M_en_2024-06-10T09_32_38Z.csv\n\n\n\n\n \nLoad the Austrian generation data and visualize the shares of generation types. What do you notice in the dataset?\n\n\n\n\n\n\nHinweis 5.2: Download Austria Market Transparency Data\n\n\n\n\n\nAfter selecting the time period, click Export, then the Download button will appear.\n\n\n\n \n\n\n\n\n\n \n\n\nThe date format of the files depends on the language setting on the website (German/English).\n\n\n\n \n\n\n\n\n\n\nTipp 5.3: Tip for Generation Data and Sample Solution\n\n\n\n\n\nThe Austrian dataset differs in that it reports power (capacity) instead of generated energy. (This does not affect the visualization of generation shares.) The dataset also differs in another aspect.\nTip: If not all columns appear in the output of the .describe() method, try printing the DataFrame in two or more parts. For example:\n\nprint(df.iloc[:, 0:5].describe(include=np.number))\nprint(df.iloc[:, 5:10].describe(include=np.number))\nprint(df.iloc[:, 10:15].describe(include=np.number))\n\n\n\n\n\n\n\nTippMusterlösung Strommarktdaten Österreich\n\n\n\n\n\n\n\nimport pandas as pd\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# Set decimal precision for display\npd.set_option(\"display.precision\", 2)\n\n# Load dataset into variable generation0\n\n# !\n# Adjust the file path to the correct location of the downloaded .csv file for your own use.\n# !\n\ngeneration0_austria_ms = pd.read_csv(\"01-daten/AGPT_2022-12-31T23_00_00Z_2023-12-31T23_00_00Z_15M_de_2024-06-10T09_32_38Z.csv\", \n                                     sep = \";\", thousands = \".\", decimal = \",\", parse_dates = [0, 1], date_format = \"%d.%m.%Y\")\n\nprint(generation0_austria_ms.head(10))\n\nprint(f\"The DataFrame generation0_austria_ms has {generation0_austria_ms.shape[0]} rows and {generation0_austria_ms.shape[1]} columns.\")\n\n# Brief summary statistics of dataset\nprint(generation0_austria_ms.describe(include=[np.number]))\n\n# If the dataset has many columns, some may be truncated in output.\n# Print descriptive stats in chunks if needed:\nprint(generation0_austria_ms.iloc[:, 0:5].describe(include=[np.number]))\nprint(generation0_austria_ms.iloc[:, 5:10].describe(include=[np.number]))\nprint(generation0_austria_ms.iloc[:, 10:15].describe(include=[np.number]))\n\n# Create a copy of the dataset\ngeneration_austria_ms_c = generation0_austria_ms.copy()\n\n# Drop columns with time data\ngeneration_austria_ms_c = generation_austria_ms_c.drop(columns=[\"Zeit von [CET/CEST]\", \"Zeit bis [CET/CEST]\"])\nprint(generation_austria_ms_c.head(5))\n\n# Remove the string \" [MW]\" from column names\ngeneration_austria_ms_c.columns = generation_austria_ms_c.columns.str.replace(pat=\" [MW]\", repl=\"\")\nprint(generation_austria_ms_c.head(5))\n\n# Plausibility check: the .csv file in Excel shows that the \"Pumpspeicher\" column contains both positive and negative values.\n# This is also visible in the .describe() output.\n# Check for negative values in generation columns:\ncheck_negative_values = (generation_austria_ms_c &lt; 0).any().any()\nif check_negative_values:\n    print(\"ERROR: Negative values detected in generation data.\")\n\n# Set negative values in \"Pumpspeicher\" column to 0\ngeneration_austria_ms_c[\"Pumpspeicher\"] = generation_austria_ms_c[\"Pumpspeicher\"].clip(lower=0)\n\n# Remove columns with a sum of zero\n# Approach: drop any column where the sum of all values is zero\ncolumns_to_drop = [col for col in generation_austria_ms_c.columns if generation_austria_ms_c[col].sum() == 0]\ngeneration_austria_ms_c = generation_austria_ms_c.drop(columns=columns_to_drop)\nprint(generation_austria_ms_c.head(10))\n\n# To improve readability of very small pie chart segments, rearrange columns:\n# alternate between largest and smallest segment, second largest and second smallest, etc.\nsorted_columns = generation_austria_ms_c.sum().sort_values().index\n\nnew_order = []\nfor i in range(len(sorted_columns) // 2):\n    new_order.append(sorted_columns[i])\n    new_order.append(sorted_columns[-(i + 1)])\n\n# If odd number of columns, append the middle one last\nif len(sorted_columns) % 2 != 0:\n    new_order.append(sorted_columns[len(sorted_columns) // 2])\n\ngeneration_austria_ms_c = generation_austria_ms_c[new_order]\n\nplt.figure(figsize=(7, 7))\npie_plot = generation_austria_ms_c.sum(numeric_only=True).plot.pie(\n    colormap=\"Blues\",\n    startangle=90,\n    rotatelabels=False,\n    wedgeprops={\"linewidth\": 1, \"edgecolor\": \"white\"},\n    autopct='%1.1f%%',\n    pctdistance=0.6,\n    textprops=dict(size=7),\n)\n\n# Make a donut chart by adding a white circle at the center\ncircle = plt.Circle((0, 0), radius=0.7, color=\"white\")\npie_plot.add_patch(circle)\n\nplt.show()\n\n   Zeit von [CET/CEST]  Zeit bis [CET/CEST]  Wind [MW]  Solar [MW]  \\\n0  01.01.2023 00:00:00  01.01.2023 00:15:00     1000.0         0.0   \n1  01.01.2023 00:15:00  01.01.2023 00:30:00      964.0         0.0   \n2  01.01.2023 00:30:00  01.01.2023 00:45:00      956.0         0.0   \n3  01.01.2023 00:45:00  01.01.2023 01:00:00      992.0         0.0   \n4  01.01.2023 01:00:00  01.01.2023 01:15:00      880.0         0.0   \n5  01.01.2023 01:15:00  01.01.2023 01:30:00      888.0         0.0   \n6  01.01.2023 01:30:00  01.01.2023 01:45:00      948.0         0.0   \n7  01.01.2023 01:45:00  01.01.2023 02:00:00      968.0         0.0   \n8  01.01.2023 02:00:00  01.01.2023 02:15:00      956.0         0.0   \n9  01.01.2023 02:15:00  01.01.2023 02:30:00      952.0         0.0   \n\n   Biomasse [MW]  Gas [MW]  Kohle [MW]  Öl [MW]  Geothermie [MW]  \\\n0          240.0      27.6         0.0      0.0             0.07   \n1          240.0      27.6         0.0      0.0             0.07   \n2          240.0      28.0         0.0      0.0             0.07   \n3          240.0      27.6         0.0      0.0             0.07   \n4          240.0      27.6         0.0      0.0             0.07   \n5          240.0      28.4         0.0      0.0             0.07   \n6          240.0      28.8         0.0      0.0             0.07   \n7          240.0      28.0         0.0      0.0             0.07   \n8          240.0      28.8         0.0      0.0             0.07   \n9          240.0      28.4         0.0      0.0             0.07   \n\n   Pumpspeicher [MW]  Lauf- und Schwellwasser [MW]  Speicher [MW]  \\\n0            -1404.8                        2291.6           70.4   \n1            -1532.8                        2283.2           66.8   \n2            -1544.4                        2240.0          100.4   \n3            -1579.6                        2199.6           77.6   \n4            -1590.8                        2234.8           63.2   \n5            -1602.8                        2229.2           73.6   \n6            -1572.0                        2211.2           69.2   \n7            -1579.2                        2194.8           70.8   \n8            -1649.6                        2202.8           75.2   \n9            -1702.0                        2172.4           65.6   \n\n   Sonstige Erneuerbare [MW]  Müll [MW]  Andere [MW]  \n0                        0.0      100.0         22.0  \n1                        0.0      100.0         22.0  \n2                        0.0      100.0         22.0  \n3                        0.0      100.0         22.0  \n4                        0.0      100.0         22.0  \n5                        0.0      100.0         22.0  \n6                        0.0      100.0         22.0  \n7                        0.0      100.0         22.0  \n8                        0.0      100.0         22.0  \n9                        0.0      100.0         22.0  \nThe DataFrame generation0_austria_ms has 35040 rows and 15 columns.\n       Wind [MW]  Solar [MW]  Biomasse [MW]  Gas [MW]  Kohle [MW]  Öl [MW]  \\\ncount   35040.00    35040.00       35040.00  35040.00     35040.0  35040.0   \nmean      942.84      268.01         159.94    736.68         0.0      0.0   \nstd       884.56      421.28          64.30    799.65         0.0      0.0   \nmin         4.00        0.00          52.00      0.00         0.0      0.0   \n25%       204.00        0.00         100.00      0.40         0.0      0.0   \n50%       644.00       20.00         156.00    472.00         0.0      0.0   \n75%      1484.00      392.00         216.00   1273.60         0.0      0.0   \nmax      3400.00     2028.00         312.00   3599.60         0.0      0.0   \n\n       Geothermie [MW]  Pumpspeicher [MW]  Lauf- und Schwellwasser [MW]  \\\ncount         3.50e+04           35040.00                      35040.00   \nmean          7.20e-02             283.53                       3477.12   \nstd           1.39e-17            1101.68                       1032.45   \nmin           7.20e-02           -2082.80                       1375.60   \n25%           7.20e-02            -451.20                       2591.60   \n50%           7.20e-02             181.60                       3516.00   \n75%           7.20e-02            1010.40                       4131.20   \nmax           7.20e-02            3160.80                       6290.40   \n\n       Speicher [MW]  Sonstige Erneuerbare [MW]  Müll [MW]  Andere [MW]  \ncount       35040.00                    35040.0    35040.0      35040.0  \nmean          488.40                        0.0      100.0         22.0  \nstd           301.89                        0.0        0.0          0.0  \nmin            16.00                        0.0      100.0         22.0  \n25%           248.00                        0.0      100.0         22.0  \n50%           424.40                        0.0      100.0         22.0  \n75%           686.00                        0.0      100.0         22.0  \nmax          1434.40                        0.0      100.0         22.0  \n       Wind [MW]  Solar [MW]  Biomasse [MW]\ncount   35040.00    35040.00       35040.00\nmean      942.84      268.01         159.94\nstd       884.56      421.28          64.30\nmin         4.00        0.00          52.00\n25%       204.00        0.00         100.00\n50%       644.00       20.00         156.00\n75%      1484.00      392.00         216.00\nmax      3400.00     2028.00         312.00\n       Gas [MW]  Kohle [MW]  Öl [MW]  Geothermie [MW]  Pumpspeicher [MW]\ncount  35040.00     35040.0  35040.0         3.50e+04           35040.00\nmean     736.68         0.0      0.0         7.20e-02             283.53\nstd      799.65         0.0      0.0         1.39e-17            1101.68\nmin        0.00         0.0      0.0         7.20e-02           -2082.80\n25%        0.40         0.0      0.0         7.20e-02            -451.20\n50%      472.00         0.0      0.0         7.20e-02             181.60\n75%     1273.60         0.0      0.0         7.20e-02            1010.40\nmax     3599.60         0.0      0.0         7.20e-02            3160.80\n       Lauf- und Schwellwasser [MW]  Speicher [MW]  Sonstige Erneuerbare [MW]  \\\ncount                      35040.00       35040.00                    35040.0   \nmean                        3477.12         488.40                        0.0   \nstd                         1032.45         301.89                        0.0   \nmin                         1375.60          16.00                        0.0   \n25%                         2591.60         248.00                        0.0   \n50%                         3516.00         424.40                        0.0   \n75%                         4131.20         686.00                        0.0   \nmax                         6290.40        1434.40                        0.0   \n\n       Müll [MW]  Andere [MW]  \ncount    35040.0      35040.0  \nmean       100.0         22.0  \nstd          0.0          0.0  \nmin        100.0         22.0  \n25%        100.0         22.0  \n50%        100.0         22.0  \n75%        100.0         22.0  \nmax        100.0         22.0  \n   Wind [MW]  Solar [MW]  Biomasse [MW]  Gas [MW]  Kohle [MW]  Öl [MW]  \\\n0     1000.0         0.0          240.0      27.6         0.0      0.0   \n1      964.0         0.0          240.0      27.6         0.0      0.0   \n2      956.0         0.0          240.0      28.0         0.0      0.0   \n3      992.0         0.0          240.0      27.6         0.0      0.0   \n4      880.0         0.0          240.0      27.6         0.0      0.0   \n\n   Geothermie [MW]  Pumpspeicher [MW]  Lauf- und Schwellwasser [MW]  \\\n0             0.07            -1404.8                        2291.6   \n1             0.07            -1532.8                        2283.2   \n2             0.07            -1544.4                        2240.0   \n3             0.07            -1579.6                        2199.6   \n4             0.07            -1590.8                        2234.8   \n\n   Speicher [MW]  Sonstige Erneuerbare [MW]  Müll [MW]  Andere [MW]  \n0           70.4                        0.0      100.0         22.0  \n1           66.8                        0.0      100.0         22.0  \n2          100.4                        0.0      100.0         22.0  \n3           77.6                        0.0      100.0         22.0  \n4           63.2                        0.0      100.0         22.0  \n     Wind  Solar  Biomasse   Gas  Kohle   Öl  Geothermie  Pumpspeicher  \\\n0  1000.0    0.0     240.0  27.6    0.0  0.0        0.07       -1404.8   \n1   964.0    0.0     240.0  27.6    0.0  0.0        0.07       -1532.8   \n2   956.0    0.0     240.0  28.0    0.0  0.0        0.07       -1544.4   \n3   992.0    0.0     240.0  27.6    0.0  0.0        0.07       -1579.6   \n4   880.0    0.0     240.0  27.6    0.0  0.0        0.07       -1590.8   \n\n   Lauf- und Schwellwasser  Speicher  Sonstige Erneuerbare   Müll  Andere  \n0                   2291.6      70.4                   0.0  100.0    22.0  \n1                   2283.2      66.8                   0.0  100.0    22.0  \n2                   2240.0     100.4                   0.0  100.0    22.0  \n3                   2199.6      77.6                   0.0  100.0    22.0  \n4                   2234.8      63.2                   0.0  100.0    22.0  \nERROR: Negative values detected in generation data.\n     Wind  Solar  Biomasse   Gas  Geothermie  Pumpspeicher  \\\n0  1000.0    0.0     240.0  27.6        0.07           0.0   \n1   964.0    0.0     240.0  27.6        0.07           0.0   \n2   956.0    0.0     240.0  28.0        0.07           0.0   \n3   992.0    0.0     240.0  27.6        0.07           0.0   \n4   880.0    0.0     240.0  27.6        0.07           0.0   \n5   888.0    0.0     240.0  28.4        0.07           0.0   \n6   948.0    0.0     240.0  28.8        0.07           0.0   \n7   968.0    0.0     240.0  28.0        0.07           0.0   \n8   956.0    0.0     240.0  28.8        0.07           0.0   \n9   952.0    0.0     240.0  28.4        0.07           0.0   \n\n   Lauf- und Schwellwasser  Speicher   Müll  Andere  \n0                   2291.6      70.4  100.0    22.0  \n1                   2283.2      66.8  100.0    22.0  \n2                   2240.0     100.4  100.0    22.0  \n3                   2199.6      77.6  100.0    22.0  \n4                   2234.8      63.2  100.0    22.0  \n5                   2229.2      73.6  100.0    22.0  \n6                   2211.2      69.2  100.0    22.0  \n7                   2194.8      70.8  100.0    22.0  \n8                   2202.8      75.2  100.0    22.0  \n9                   2172.4      65.6  100.0    22.0  \n\n\n\n\n\nShare of electricity generation in Austria\n\n\n\n\nSample solution by Marc Sönnecken. For compatibility with this script, file paths and object names were adjusted. For accessibility, figure size and color palette were changed, a white inner circle added, and percentage labels repositioned.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Energy Data Analysis</span>"
    ]
  },
  {
    "objectID": "skript/energiedatenanalyse.html#background-marginal-electricity-analysis",
    "href": "skript/energiedatenanalyse.html#background-marginal-electricity-analysis",
    "title": "1  Energy Data Analysis",
    "section": "6.1 Background: Marginal Electricity Analysis",
    "text": "6.1 Background: Marginal Electricity Analysis\nIn the present case, the exploratory examination of the dataset is guided by the question of which producers supplied electricity to additionally fill the pumped storage facilities beyond meeting the grid demand. The aim is to determine which electricity producers, at the times when the pumped storage plants were being filled, were capable of providing additional output. This additional electricity can be referred to briefly as marginal electricity.\n\n\n\n\n\n\nDefinition 6.1: Marginal Electricity\n\n\n\nMarginal analysis examines the conditions prevailing when producing or consuming an additional unit. This differs from an average analysis, which examines the effect of a change in quantity across all units. Marginal electricity refers to an additional unit of electricity.\nFor example, suppose the current electricity generation is 100 units, consisting of 60 units of solar power and, because solar production is insufficient, an additional 40 units of coal power. In this case, each unit of electricity contains, on average, 0.4 parts coal power. Now, if an additional 20 units of electricity are demanded, these must be supplied through additional coal-fired generation. In the average view, the electricity mix now consists of 60 units of solar power and 40 + 20 = 60 units of coal power. This changes the average coal share in electricity production from 0.4 to 0.5.\nIn the marginal view, the coal share of the additionally consumed electricity is 20 out of 20 units, i.e., 1.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Energy Data Analysis</span>"
    ]
  },
  {
    "objectID": "skript/energiedatenanalyse.html#background-priority-feed-in-of-renewable-energy",
    "href": "skript/energiedatenanalyse.html#background-priority-feed-in-of-renewable-energy",
    "title": "1  Energy Data Analysis",
    "section": "6.2 Background: Priority Feed-in of Renewable Energy",
    "text": "6.2 Background: Priority Feed-in of Renewable Energy\nIn Germany, since the year 2000, the Renewable Energy Sources Act has been in effect, originally introduced as the Act on the Priority of Renewable Energy Sources Documentation and Information System for Parliamentary Materials. This act stipulated in § 3 the priority feed-in of renewable energies:\n\n\n\n \n\n\nObligation to Purchase and Remunerate\n(1) Grid operators are obliged to connect installations for the generation of electricity according to § 2 to their grid, to purchase all electricity offered from these installations with priority, and to remunerate the fed-in electricity in accordance with §§ 4 to 8.\n\n\n \n\n\n\n\n \nAct on the Priority of Renewable Energy Sources (Renewable Energy Sources Act – EEG) as well as amendments to the Energy Industry Act and the Mineral Oil Tax Act. Federal Law Gazette Year 2000 Part I No. 13, issued in Bonn on March 31, 2000. Federal Gazette\n\n\n\n \nProducers classified as renewable energy have priority feed-in to the grid. According to the current version of the law, these are:\n\n\nHydropower, including wave, tidal, salinity gradient, and current energy,\nWind energy,\nSolar radiation energy,\nGeothermal energy,\nEnergy from biomass, including biogas, biomethane, landfill gas, and sewage gas, as well as from the biodegradable fraction of waste from households and industry\n\nAct for the Expansion of Renewable Energy Sources (Renewable Energy Sources Act – EEG 2023). § 3 Definitions. https://www.gesetze-im-internet.de/eeg_2014/__3.html\n\n \nNon-renewable producers operate in load-following mode to cover the residual load, i.e., the grid load minus the renewable generation output. This means that two scenarios can be distinguished:\n\nSurplus of renewable energy: Electricity demand is fully met by renewable energy generation, and there is a generation surplus (or generators have been curtailed), which can serve additional electricity consumption.\nElectricity mix from renewable feed-in and load-following non-renewable producers: Renewable energy sources feed in at full capacity, and the residual load and additional electricity consumption are met by non-renewable producers.\n\nWhich scenario applies in the power grid at a given moment can thus be determined by looking at the residual load.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Energy Data Analysis</span>"
    ]
  },
  {
    "objectID": "skript/energiedatenanalyse.html#determine-residual-load-and-remaining-load",
    "href": "skript/energiedatenanalyse.html#determine-residual-load-and-remaining-load",
    "title": "1  Energy Data Analysis",
    "section": "6.3 Determine residual load and remaining load",
    "text": "6.3 Determine residual load and remaining load\nThe Federal Network Agency publishes, in its dataset on realized electricity consumption, the grid load, residual load, and electricity consumption by pumped storage power plants.\n\nprint(consumption.sum(numeric_only = True))\n\nGesamt (Netzlast) [MWh]    4.58e+08\nResiduallast [MWh]         2.60e+08\nPumpspeicher [MWh]         1.41e+07\ndtype: float64\n\n\n\n\n\n\n\n\nDefinition 6.2: Residual Load\n\n\n\n“Residual load […] corresponds to the total realized electricity consumption, minus the feed-in from photovoltaic, onshore wind, and offshore wind plants.” SMARD.de User Manual (p. 53)\n\n\n \nThe residual load not covered by renewable energies is the difference between electricity consumption and generation from renewable sources. Consequently, this residual load is smaller than the residual load published by the Federal Network Agency. Both residual load and this remaining load can be calculated from the difference between grid load and the corresponding renewable electricity generation.\n\nrenewables = ['Biomasse [MWh]', 'Wasserkraft [MWh]', 'Wind Offshore [MWh]', 'Wind Onshore [MWh]', 'Photovoltaik [MWh]', 'Sonstige Erneuerbare [MWh]']\nPV_WindOnshore_WindOffshore = ['Wind Offshore [MWh]', 'Wind Onshore [MWh]', 'Photovoltaik [MWh]'] \n\nplotting_data = pd.DataFrame()\nplotting_data[\"Netzlast [MWh]\"] = consumption[\"Gesamt (Netzlast) [MWh]\"].copy() \nplotting_data[\"volatile EE [MWh]\"] = generation[PV_WindOnshore_WindOffshore].sum(axis=\"columns\").copy()\nplotting_data[\"Erneuerbare [MWh]\"] = generation[renewables].sum(axis=\"columns\").copy()\n\nplotting_data[\"Residuallast BNetzA [MWh]\"] = consumption[\"Residuallast [MWh]\"].copy()\nplotting_data[\"Residuallast [MWh]\"] = plotting_data[\"Netzlast [MWh]\"] - plotting_data[\"volatile EE [MWh]\"]\nplotting_data[\"Restlast [MWh]\"] = plotting_data[\"Netzlast [MWh]\"] - plotting_data[\"Erneuerbare [MWh]\"]\n\nplotting_data.head()\n\n\n\n\n\n\n\n\nNetzlast [MWh]\nvolatile EE [MWh]\nErneuerbare [MWh]\nResiduallast BNetzA [MWh]\nResiduallast [MWh]\nRestlast [MWh]\n\n\n\n\n0\n9720.75\n7830.50\n9277.00\n1890.25\n1890.25\n443.75\n\n\n1\n9641.25\n7902.00\n9343.00\n1739.25\n1739.25\n298.25\n\n\n2\n9609.50\n8119.50\n9559.50\n1490.00\n1490.00\n50.00\n\n\n3\n9565.00\n7919.00\n9362.25\n1646.00\n1646.00\n202.75\n\n\n4\n9473.50\n8107.75\n9540.50\n1365.75\n1365.75\n-67.00\n\n\n\n\n\n\n\n \nThe residual load published by the Federal Network Agency Residual Load BNetzA [MWh] corresponds, based on the inspection of the first few rows, to the self-calculated residual load Residual Load [MWh]. Whether this holds true for the entire time series can be easily checked using the method pd.Series.equals(), which returns a boolean value, i.e., True or False.\n\nplotting_data['Residuallast BNetzA [MWh]'].equals(plotting_data['Residuallast [MWh]'])\n\nTrue\n\n\nThis allows the redundant column to be removed.\n\nplotting_data.drop(['Residuallast BNetzA [MWh]'], axis='columns', inplace=True)",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Energy Data Analysis</span>"
    ]
  },
  {
    "objectID": "skript/energiedatenanalyse.html#visualizing-the-annual-cycle",
    "href": "skript/energiedatenanalyse.html#visualizing-the-annual-cycle",
    "title": "1  Energy Data Analysis",
    "section": "6.4 Visualizing the Annual Cycle",
    "text": "6.4 Visualizing the Annual Cycle\nThe network load, renewable energy generation, as well as the residual and remaining load should be visualized over the course of a year. For better clarity, only every 100th value will be plotted.\n\nNetwork Load Throughout the YearCode for the Plot\n\n\n\n\n\n\n\nNetwork Load Throughout the Year\n\n\n\n\n\n\n\n# Find position and content for x-axis labels\nmonths = generation[\"Datum von\"].dt.month.unique().tolist() # gives numbers 1-12\n\n## using Pandas\nmonths_index = generation[~generation[\"Datum von\"].dt.month.duplicated()].index\nmonth_names = generation[\"Datum von\"].iloc[months_index].dt.strftime(\"%B\") \n\n## alternatively using a list operation\n# months_index = []\n# month_names = []\n\n# for i in months:\n#   months_index.append(generation.index[generation[\"Datum von\"].dt.month == i].min())\n#   month_names.append(generation[\"Datum von\"].iloc[months_index[i - 1]].strftime(\"%B\"))\n\n\n# plot every 100th value\nplotting_data[::100].plot(figsize = (9, 8), subplots = True, sharey = True, xlim = (plotting_data.index.min() - (len(plotting_data.index) / 100), plotting_data.index.max() * 1.01), rot = 45, grid = True)\nplt.ylim(top = 20000)\nplt.minorticks_off()\nplt.xticks(months_index, month_names);\n\nplt.show()\n\n\n\n\nIt can be observed that the grid load consistently remains above 9,000 MWh. Furthermore, the grid load fluctuates strongly on a monthly basis, reaching values of up to 19,000 MWh. Each month sees performance near the absolute minimum and maximum. In summer, the grid load is generally somewhat lower than in winter.\nThe electricity generation from renewable energy, shown in the second subplot (volatile RE [MWh]), is highly volatile. Periods of high production alternate with periods of low production, each lasting only a few days and at most two weeks. This is mainly due to electricity generation from photovoltaics and offshore/onshore wind, whose combined nationwide output in Germany often drops close to zero before reaching a (local) production maximum. In the third subplot (Renewables [MWh]), it can be seen that the additional feed-in from less volatile renewable sources such as biomass and hydropower is comparatively low. Therefore, while the total electricity generation summed across all renewable sources is never zero, it often reaches a low overall output. Nevertheless, there are also short periods of full renewable supply or surplus production, as can be seen from the annual curve of non-renewable residual load.\nRegarding the question of the origin of the electricity stored in pumped-storage plants, the graphical representation already indicates that it was predominantly generated by non-renewable sources, as the residual load is rarely zero or negative.\nThe annual curve of the residual load mirrors the generation pattern of volatile renewable energy. This poses a challenge for conventional power plants. This aspect will be explored in more detail in the next section.\nBut first, a small task:\nHow would a doubling of renewable generation affect the residual load? Display the effect graphically in a comparable manner (e.g., by adding an extra column ‘Grid Load - 2x RE’).\n\n\n\n\n\n\nTipp 6.1: Sample Solution Doubling RE\n\n\n\n\n\n\nPlotCodePossible Interpretation\n\n\n\n\n\n\n\nExample solution doubling Renewable Energy (RE)\n\n\n\n\n\n\n\nplotting_data_2xRE = plotting_data.copy()\nplotting_data_2xRE[\"2x EE\"] = plotting_data_2xRE[\"Erneuerbare [MWh]\"] * 2\nplotting_data_2xRE[\"Netzlast - 2x EE\"] = plotting_data_2xRE[\"Netzlast [MWh]\"] - plotting_data_2xRE[\"2x EE\"]\nplotting_data_2xRE = plotting_data_2xRE[[\"Netzlast [MWh]\", \"Netzlast - 2x EE\"]]\n\n# plot every 100th value\nplotting_data_2xRE[::100].plot(figsize=(9, 6), subplots=True, sharey=True,\n                               xlim=(plotting_data_2xRE.index.min() - (len(plotting_data_2xRE.index)) / 100,\n                                     plotting_data_2xRE.index.max() * 1.01),\n                               rot=45, grid=True)\nplt.minorticks_off()\nplt.xticks(months_index, month_names)\n\nplt.show()\n\n\n\nThe grid load minus the doubled renewable power generation approaches a symmetric distribution around the zero line. This means that periods of renewable overproduction and underproduction roughly balance each other out.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Energy Data Analysis</span>"
    ]
  },
  {
    "objectID": "skript/energiedatenanalyse.html#background-base-medium-and-peak-load",
    "href": "skript/energiedatenanalyse.html#background-base-medium-and-peak-load",
    "title": "1  Energy Data Analysis",
    "section": "6.5 Background: Base, Medium, and Peak Load",
    "text": "6.5 Background: Base, Medium, and Peak Load\nNot all power plants are equally suitable for load-following operation due to technical or economic reasons. For example, coal-fired power plants are less flexibly controllable than gas-fired plants. Nuclear power plants are preferred for base load operation due to their high fixed and low variable costs. In the power grid, three operational profiles for power plants are distinguished: base load, medium load, and peak load.\n\n\n\n\n\n\nDefinition 6.3: Base, Medium, and Peak Load\n\n\n\n\n\nBase load: The power continuously demanded throughout the year.\nPlant types: Lignite, Nuclear, Run-of-river hydro\nMedium load: Power demanded beyond the base load, planable on a daily and yearly basis.\nPlant types: Combined cycle gas plants, Hard coal\nPeak load: Power demanded beyond the medium load, only briefly or unexpectedly during the day or year.\nPlant types: Gas turbines, Pumped-storage hydro\n\nISPEX AG: Base load, Medium load, Peak load\nGrünwald, Reinhard / Caviezel, Claudio 2017: Load-following capability of German nuclear power plants. Monitoring. Office for Technology Assessment at the German Bundestag (TAB). doi: 10.5445/IR/1000102277. Page 16.\n\n\n\nFor the question of which power plants supply the marginal power for filling the pumped-storage hydro plants, the distinction between base-load plants on the one hand, and medium- and peak-load plants on the other hand, is particularly relevant. Base-load plants operate at full capacity 24 hours a day. For example, in 2021, nuclear energy reached nearly continuous full-load operation with 8,070 annual full-load hours statista. Plants running at full load can no longer respond to additional electricity demand. This is left to plants operating in medium and peak load.\nThus, by distinguishing between power plant types operating in base load and those in medium or peak load, one can narrow down which plant types supplied the electricity required to fill the pumped-storage plants.\nThe utilization of a power plant (or group of plants) can be quantified using its annual full-load hours.\n\n\n\n\n\n\nDefinition 6.4: Annual Full-Load Hours\n\n\n\nThe annual full-load hours indicate how many of the 8,760 hours in a year a power plant would need to operate at maximum capacity to produce its annual output. statista\n\\[\nAnnual~Full\\text{-}Load~Hours~(h) = \\frac{Total~electricity~generated~in~MWh}{Installed~capacity~in~MW}\n\\]\n\n\nThe annual full-load hours can be calculated as follows. Applying the .sum method to the dataset installed_capacity is not necessary since it contains only one row. However, the .sum method allows you to exclude date columns using the parameter numeric_only = True.\n\n# print(f\"{generation.sum(numeric_only=True)}\\n\")\n# print(installed_capacity.sum(numeric_only=True), \"\\n\")\n\n# For the division, indices need to be reset\nfull_load_hours_per_year = generation.sum(numeric_only=True).reset_index(drop=True).divide(installed_capacity.sum(numeric_only=True).reset_index(drop=True))\n\n# Reset index\nfull_load_hours_per_year.index = generation.sum(numeric_only=True).index.str.replace(pat=\" [MWh]\", repl=\" [h]\")\n\nprint(f\"\\n\\nFull load hours per year\\n\\n{full_load_hours_per_year.sort_values(ascending=False)}\")\n\n\n\nFull load hours per year\n\nBiomasse [h]                   4467.41\nBraunkohle [h]                 4399.96\nWind Offshore [h]              2893.34\nWasserkraft [h]                2855.83\nSonstige Erneuerbare [h]       2653.47\nSteinkohle [h]                 2192.86\nWind Onshore [h]               2062.55\nKernenergie [h]                1661.92\nErdgas [h]                     1576.42\nSonstige Konventionelle [h]    1293.98\nPumpspeicher [h]               1188.76\nPhotovoltaik [h]                883.48\ndtype: float64\n\n\nThe calculation of annual operating hours shows that no type of power plant ran even close to full capacity. The highest utilization is observed for biomass and lignite. Biomass operated at full load for the equivalent of 51 percent of the 8,760 annual hours, while lignite did so for 50 percent. In contrast, the classic base-load generator, nuclear energy, reached only 25 percent. Hard coal, mainly used in Germany for mid-load operation, reached 19 percent. The year 2023 was particularly unusual for nuclear energy.\nTherefore, the annual profile of selected conventional generators is presented. To achieve high resolution, a monthly representation is chosen.\n\nExample Code: Nuclear EnergyNuclear EnergyLigniteHard CoalNatural Gas\n\n\n\nplotting_data = generation.copy()\n\nproducer = \"Kernenergie\"\n\nfig = plt.figure(figsize = (8, 12))\nfig.suptitle(producer, fontsize = 12)\nfor i in range(1, 13):\n    plotting_data_monthly = plotting_data[plotting_data['Datum von'].dt.month == i]\n    ax = fig.add_subplot(12, 1, i)\n    ax.plot(plotting_data_monthly[producer + \" [MWh]\"])\n    plt.margins(x = 0.01)\n    ax.set_ylabel(\"MWh\")\n    \n    # Generate title\n    plt.title(plotting_data_monthly['Datum von'].head(1).dt.strftime('%B').item(), fontsize = 10)\n    \n    # Generate xticks\n    day_index = plotting_data_monthly[~plotting_data_monthly['Datum von'].dt.day.duplicated()].index\n    day_names = plotting_data_monthly['Datum von'].dt.day.unique()\n    plt.xticks(day_index, day_names, fontsize = 8)\n\nplt.tight_layout()\nplt.show()\n\n\n\n\n\n\n\n\nAnnual Pattern of Nuclear Energy\n\n\n\n\n\n\n\n\n\n\n\nAnnual Profile Lignite\n\n\n\n\n\n\n\n\n\n\n\nAnnual Profile Hard Coal\n\n\n\n\n\n\n\n\n\n\n\nAnnual Profile Natural Gas\n\n\n\n\n\n\n\nIn the Nuclear Energy tab, it can be seen that in 2023 the last German nuclear power plants Emsland, Isar 2, and Neckarwestheim 2 were taken off the grid. In autumn 2022, due to the energy crisis, an extended stretch operation was decided for these plants beyond the original shutdown date of December 31, 2022. BMWK\nUntil which day was the stretch operation approved? Determine the shutdown date using the dataset generation. Output the shutdown time from the column 'Datum bis' in German date formatting DD. Month YYYY um HH:MM Uhr.\n\n\n\n\n\n\nTipp 6.3: Hint and Sample Solution\n\n\n\n\n\nWhen the shutdown occurred, electricity production from nuclear energy reached the value 0. The shutdown was completed in the period preceding the first period in which nuclear power generation had the value 0.\nYou can format the output of a column as datetime using the method pandas.Series.dt.strftime.\n\n\n\n\n\n\nTipp 6.2: Sample Solution\n\n\n\n\n\nIn the graphical representation of the annual profile, only every 100th value was plotted, so it is possible that electricity generation reached zero before the final shutdown. Therefore, it is more reliable to search the dataset backwards.\nIn the forward search, the position of the first occurrence of the value 0 is determined with the .eq() method, and 1 is subtracted. In the backward search, the position of the first value greater than 0 is determined using the .gt() method.\n\nprint(f\"Forward search: generation['Kernenergie [MWh]'].eq(0).idxmax() - 1\\n{generation['Kernenergie [MWh]'].eq(0).idxmax() - 1}\\n\")\n\n# backward search\nprint(f\"Backward search: position := generation['Kernenergie [MWh]'].iloc[::-1].gt(0).idxmax()\\n{ ( position := generation['Kernenergie [MWh]'].iloc[::-1].gt(0).idxmax() ) }\\n\")\n\nprint(f\"generation['Datum bis'].iloc[position].strftime('%d. %B %Y um %H:%M Uhr')\\n{generation['Datum bis'].iloc[position].strftime('%d. %B %Y um %H:%M Uhr')}\")\n\nForward search: generation['Kernenergie [MWh]'].eq(0).idxmax() - 1\n10075\n\nBackward search: position := generation['Kernenergie [MWh]'].iloc[::-1].gt(0).idxmax()\n10075\n\ngeneration['Datum bis'].iloc[position].strftime('%d. %B %Y um %H:%M Uhr')\n16. April 2023 um 00:00 Uhr\n\n\n\n\n\n\n\n\nThe calculation of annual full-load hours and the visualization of annual profiles show that, due to the high share of volatile renewable electricity generation in the German power system, there is no longer any baseload that can be served by conventional generators. This means that all non-renewable generators operate in load-following mode. This can be illustrated by the example of hard coal, whose achieved annual full-load hours are closer to the classic peak load generation from natural gas than to the mid-load generation from lignite. The utilization of a power generator can be represented using a sorted annual duration curve.\n\n\n\n\n\n\nDefinition 6.5: Sorted Annual Duration Curve\n\n\n\nThe sorted annual duration curve is a diagram of the data sorted in descending order.\n\n\nEnergy Technology. 2 Introduction. 2.13 Sorted Annual Duration Curve by Henrik te Heesen is licensed under CC BY-SA 3.0 and available on YouTube.\n\n\n\n\nPlotCode for the Plot\n\n\n\n\n\n\n\nsorted annual duration curve of selected conventional generators\n\n\n\n\n\n\n\n# Group data by day and aggregate by daily mean.\nlignite_daily = generation['Braunkohle [MWh]'].groupby(generation[\"Datum von\"].dt.dayofyear).mean()\nhardcoal_daily = generation['Steinkohle [MWh]'].groupby(generation[\"Datum von\"].dt.dayofyear).mean()\nnaturalgas_daily = generation['Erdgas [MWh]'].groupby(generation[\"Datum von\"].dt.dayofyear).mean()\n\n## For verification\n## print(generation[\"Datum von\"].dt.dayofyear)\n## print(f\"\\n\\nlignite_daily.head()\\n{lignite_daily.head()}\\n\\n\"\n##       f\"For comparison:\\ngeneration['Braunkohle [MWh]'].iloc[[0, 1, 95, 96]]\\n{generation['Braunkohle [MWh]'].iloc[[0, 1, 95, 96]]}\\n\\n\"\n##       f\"generation['Braunkohle [MWh]'].iloc[0:96].mean()\\n{generation['Braunkohle [MWh]'].iloc[0:96].mean()}\") \n\n# Plot line chart\n# Shift index by 1 because index starts at 0 but represents day count.\nline_width = 5\nplt.figure(figsize = (8, 4))\n\nlignite_daily = lignite_daily.sort_values(ascending = False, ignore_index = True)\nlignite_daily.index += 1\nlignite_daily.plot.line(lw = line_width, color = 'brown', alpha = 0.5, label = 'Lignite')\n\nhardcoal_daily = hardcoal_daily.sort_values(ascending = False, ignore_index = True)\nhardcoal_daily.index += 1\nhardcoal_daily.plot.line(lw = line_width, color = 'black', alpha = 0.5, label = 'Hard Coal')\n\nnaturalgas_daily = naturalgas_daily.sort_values(ascending = False, ignore_index = True)\nnaturalgas_daily.index += 1\nnaturalgas_daily.plot.line(lw = line_width, color = 'lightskyblue', alpha = 0.5, label = 'Natural Gas')\n\nplt.title(label = \"sorted load duration curve for selected conventional generators\")\nplt.grid()\nplt.legend()\nplt.ylabel('average electricity generation in MWh\\n(on a quarter-hour basis)')\nplt.xlabel('number of days per year')\n\nplt.margins(x = 0.02)\nplt.show()\n\n\n\n\nWhen comparing the achieved annual full-load hours, it was observed that the utilization of hard coal more closely resembles that of the peak load generator natural gas rather than the mid-load generator lignite. Furthermore, the graphical representation of the sorted annual duration curves shows that the generation profile of hard coal even resembles that of lignite less than that of natural gas.\nSo far, only the generation from conventional power plants has been considered. Biomass and lignite reach comparable annual full-load hours, making a comparison of the two generators interesting.\nDisplay the annual profile and the annual duration curves for biomass and lignite.\n\n\n\n\n\n\nTipp 6.4: Sample Solution: Generation Profiles of Biomass and Lignite\n\n\n\n\n\n\n\nCodeText-OutputAnnual Biomass ProfileAnnual Profile of LigniteSorted Annual Duration Curves\n\n\n\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Set the number of decimal places for display\npd.set_option(\"display.precision\", 2)\n\n# Load datasets\n\n# !\n# For your own use, adjust the file path to the correct location of the downloaded .csv file.\n# !\n\ngeneration0_ms = pd.read_csv(\n    \"01-daten/Realisierte_Erzeugung_202301010000_202401010000_Viertelstunde.csv\",\n    sep=\";\", thousands=\".\", decimal=\",\", parse_dates=[0, 1], date_format=\"%d.%m.%Y %H:%M\"\n)\n\n# Remove string \" Originalauflösungen\" from column names\ngeneration0_ms.columns = generation0_ms.columns.str.replace(pat=\" Originalauflösungen\", repl=\"\")\n\nprint(generation0_ms.head(10))\n\n# Group data of selected generation types by day and aggregate by daily mean\nlignite_daily_qtr = generation0_ms['Braunkohle [MWh]'].groupby(generation0_ms[\"Datum von\"].dt.dayofyear).mean()\nbiomass_daily_qtr = generation0_ms['Biomasse [MWh]'].groupby(generation0_ms[\"Datum von\"].dt.dayofyear).mean()\n\n# Plot line chart\nline_width = 5\nplt.figure(figsize=(8, 4))\n\nlignite_daily_qtr = lignite_daily_qtr.sort_values(ascending=False, ignore_index=True)\nlignite_daily_qtr.index += 1\nlignite_daily_qtr.plot.line(lw=line_width, color='brown', alpha=0.5, label='Lignite')\n\nbiomass_daily_qtr = biomass_daily_qtr.sort_values(ascending=False, ignore_index=True)\nbiomass_daily_qtr.index += 1\nbiomass_daily_qtr.plot.line(lw=line_width, color='greenyellow', alpha=0.5, label='Biomass')\n\nplt.title(label=\"Sorted annual duration curve for selected generators\")\nplt.grid()\nplt.legend()\nplt.ylabel('Average electricity generation in MWh\\n(quarter-hourly basis)')\nplt.xlabel('Number of days per year')\n\nplt.margins(x=0.02)\n\n# Load profile: Select the generator type here for which load profile should be plotted. Comment out the other.\ngenerator = \"Biomasse\"\n#generator = \"Braunkohle\"\n\nfig = plt.figure(figsize=(8, 12))\nfig.suptitle(generator, fontsize=12)\nfor i in range(1, 13):\n    monthly_data = generation0_ms[generation0_ms['Datum von'].dt.month == i]\n    ax = fig.add_subplot(12, 1, i)\n    ax.plot(monthly_data[generator + \" [MWh]\"])\n    plt.margins(x=0.01)\n    ax.set_ylabel(ylabel=\"MWh\")\n    \n    # Create title\n    plt.title(label=monthly_data['Datum von'].head(1).dt.strftime('%B').item(), fontsize=10)\n    \n    # Generate xticks\n    day_index = monthly_data[~monthly_data[\"Datum von\"].dt.day.duplicated()].index\n    day_numbers = monthly_data[\"Datum von\"].dt.day.unique()\n    plt.xticks(day_index, day_numbers, fontsize=8)\n\nplt.tight_layout()\nplt.show()\n\n\n\n\n\n            Datum von           Datum bis  Biomasse [MWh]  Wasserkraft [MWh]  \\\n0 2023-01-01 00:00:00 2023-01-01 00:15:00         1094.25             320.00   \n1 2023-01-01 00:15:00 2023-01-01 00:30:00         1091.25             317.50   \n2 2023-01-01 00:30:00 2023-01-01 00:45:00         1090.25             317.25   \n3 2023-01-01 00:45:00 2023-01-01 01:00:00         1089.25             321.50   \n4 2023-01-01 01:00:00 2023-01-01 01:15:00         1085.25             315.25   \n5 2023-01-01 01:15:00 2023-01-01 01:30:00         1087.75             304.75   \n6 2023-01-01 01:30:00 2023-01-01 01:45:00         1086.50             303.50   \n7 2023-01-01 01:45:00 2023-01-01 02:00:00         1085.25             304.25   \n8 2023-01-01 02:00:00 2023-01-01 02:15:00         1080.25             308.25   \n9 2023-01-01 02:15:00 2023-01-01 02:30:00         1084.25             305.50   \n\n   Wind Offshore [MWh]  Wind Onshore [MWh]  Photovoltaik [MWh]  \\\n0               684.25             7145.75                0.50   \n1               743.50             7158.25                0.25   \n2               817.00             7302.25                0.25   \n3               814.50             7104.25                0.25   \n4               785.50             7322.00                0.25   \n5               898.50             7332.75                0.25   \n6               943.75             7259.75                0.25   \n7               958.25             7390.50                0.25   \n8              1009.75             7229.00                0.50   \n9               967.00             7421.75                0.25   \n\n   Sonstige Erneuerbare [MWh]  Kernenergie [MWh]  Braunkohle [MWh]  \\\n0                       32.25             615.25            962.75   \n1                       32.25             614.75            963.25   \n2                       32.50             615.00            966.50   \n3                       32.50             614.50            966.75   \n4                       32.25             614.50            969.00   \n5                       32.25             614.75            965.75   \n6                       32.25             614.75            967.50   \n7                       32.25             614.75            964.25   \n8                       32.25             615.00            963.00   \n9                       32.25             614.75            967.00   \n\n   Steinkohle [MWh]  Erdgas [MWh]  Pumpspeicher [MWh]  \\\n0            517.00        429.75               13.50   \n1            518.00        429.50                9.75   \n2            517.00        432.00                9.75   \n3            515.50        430.50                9.75   \n4            513.25        391.25               26.50   \n5            514.00        389.50               45.00   \n6            513.75        393.75               50.50   \n7            511.00        393.50               50.50   \n8            509.75        391.50               41.25   \n9            509.00        394.50               40.75   \n\n   Sonstige Konventionelle [MWh]  \n0                         307.25  \n1                         307.25  \n2                         308.25  \n3                         306.00  \n4                         306.75  \n5                         305.00  \n6                         302.00  \n7                         304.50  \n8                         303.00  \n9                         303.75  \n\n\n\n\n\n\n\n\n\nAnnual Biomass Profile\n\n\n\n\n\n\n\n\n\n\n\nAnnual Profile of Biomass\n\n\n\n\n\n\n\n\n\n\n\nSorted annual duration curves for selected generators\n\n\n\n\n\n\n\nSolution template by Marc Sönnecken. The code and the outputs generated by sections of the code have been separated into tabs. For compatibility with this script, the file path and object names have been adjusted. Colors used have been adapted for accessibility.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Energy Data Analysis</span>"
    ]
  },
  {
    "objectID": "skript/energiedatenanalyse.html#sec-PumpedStorageContent",
    "href": "skript/energiedatenanalyse.html#sec-PumpedStorageContent",
    "title": "1  Energy Data Analysis",
    "section": "6.6 Determining the Electricity Stored in Pumped Storage Plants",
    "text": "6.6 Determining the Electricity Stored in Pumped Storage Plants\nPrevious analyses have shown that two fundamental scenarios in the power grid must be distinguished:\n\nResidual load zero or negative: Marginal electricity is produced by renewable energy sources.\nResidual load positive: Marginal electricity is produced by conventional energy sources operating in load-following mode.\n\nThe annual course of electricity consumption through pumped storage plants and the corresponding scenario is shown in the following graph, which displays every 100th value of the data series verbrauch['Pumpspeicher [MWh]'].\n\nPlotCode for the Plot\n\n\n\n\n\n\n\nPumped-Storage Feed-in 2023\n\n\n\n\n\n\n\n# Calculate residual load\nrenewables = ['Biomasse [MWh]', 'Wasserkraft [MWh]', 'Wind Offshore [MWh]', 'Wind Onshore [MWh]', 'Photovoltaik [MWh]', 'Sonstige Erneuerbare [MWh]']\n\nresidual_load = pd.DataFrame()\nresidual_load[\"Netzlast [MWh]\"] = consumption[\"Gesamt (Netzlast) [MWh]\"].copy() \nresidual_load[\"Erneuerbare [MWh]\"] = generation[renewables].sum(axis=\"columns\").copy()\nresidual_load[\"Restlast [MWh]\"] = residual_load[\"Netzlast [MWh]\"] - residual_load[\"Erneuerbare [MWh]\"]\nresidual_load = residual_load[\"Restlast [MWh]\"]\n\n# Calculate xticks\nmonths_index = generation[~generation[\"Datum von\"].dt.month.duplicated()].index\nmonth_names = generation[\"Datum von\"].iloc[months_index].dt.strftime(\"%B\") \n\n# Plot every n-th value\nstep = 100\nconsumption['Pumpspeicher [MWh]'][::step].plot(\n    figsize=(9, 6),\n    xlim=(consumption.index.min() - (len(consumption.index) / 100), consumption.index.max() * 1.01),\n    rot=45,\n    grid=True,\n    label=\"\"\n)\nplt.ylabel('Storage [MWh]', fontsize=12)\nplt.suptitle('Pumped Storage in 2023')\n\n# Set xticks\nplt.minorticks_off()\nplt.xticks(months_index, month_names)\n\n# Fill under the curve: plt.fill_between has a convenient \"where\" parameter\nplt.fill_between(\n    x=consumption['Pumpspeicher [MWh]'].index[::step],\n    y1=consumption['Pumpspeicher [MWh]'][::step],\n    label='conventional storage'\n)  # , where=residual_load[::step] &gt; 0 would leave white spaces\nplt.fill_between(\n    x=consumption['Pumpspeicher [MWh]'].index[::step],\n    y1=consumption['Pumpspeicher [MWh]'][::step],\n    where=residual_load[::step] &lt;= 0,\n    color='greenyellow',\n    label='renewable storage'\n)\n\nplt.legend()\nplt.show()\n\n\n\n\nThe graphic reflects the insight gained in determining the residual and remaining load, namely that with the electricity mix realized in 2023, additional electricity demand is primarily met by conventional sources.\nWhat would the graphic look like if the feed-in from renewable energies were twice as high?\n\n\n\n\n\n\nTipp 6.5: Sample solution: Storage with double renewable generation\n\n\n\n\n\nFor the calculation, it is sufficient to multiply the total electricity generation from renewable energies by 2.\nresidual_load = pd.DataFrame()\nresidual_load[\"Netzlast [MWh]\"] = consumption[\"Gesamt (Netzlast) [MWh]\"].copy()\nresidual_load[\"Erneuerbare [MWh]\"] = generation[renewables].sum(axis=\"columns\").copy()\nresidual_load[\"Restlast [MWh]\"] = residual_load[\"Netzlast [MWh]\"] - 2 * residual_load[\"Erneuerbare [MWh]\"]\nresidual_load = residual_load[\"Restlast [MWh]\"]\n\n\n\n\n\nEnergy Storage in Pumped-Storage Hydropower Plants 2023",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Energy Data Analysis</span>"
    ]
  },
  {
    "objectID": "skript/energiedatenanalyse.html#task-exploratory-data-analysis",
    "href": "skript/energiedatenanalyse.html#task-exploratory-data-analysis",
    "title": "1  Energy Data Analysis",
    "section": "6.7 Task: Exploratory Data Analysis",
    "text": "6.7 Task: Exploratory Data Analysis\n\n\n\n\n \n\n\nUpper and main stages of the power plant group: Mooser- and Wasserfallboden with Karlingerkees at the top left, in the background on the right the Großvenediger. Image by Tigerente is licensed under CC BY-SA 3.0 and available on wikimedia.org. 2008\n\n \nVisualize the annual pattern of pumped storage in Austria for 2023. Notes on downloading the data can be found in section Kapitel 5.2.\n\n\n\n\n\n\nHinweis 6.1: Time Change in the Austrian Dataset\n\n\n\n\n\nIn the Austrian dataset, due to the switch from summer to winter time on the last Sunday in October, the 2 AM hour is recorded twice (and one hour is missing during the switch from winter to summer time on the last Sunday in March). The duplicated hour is marked in the dataset as 2A and 2B. (Notification from Austrian Power Grid AG, 13.08.2024)\n\n\n\nTime change in the Austrian dataset\n\n\nTo read the date columns correctly, the entries need to be cleaned. One option is to replace the strings “2A” and “2B” with “02” using the str.replace() method (which will create a duplicate in the dataset).\n\n\n\n\n\n\nTippExample Solution: Correct Reading Using str.replace()\n\n\n\n\n\n\naustria_generation = pd.read_csv(\n    filepath_or_buffer=\"01-daten/AGPT_2022-12-31T23_00_00Z_2023-12-31T23_00_00Z_15M_de_2024-06-10T09_32_38Z.csv\",\n    sep=\";\", \n    decimal=\",\", \n    thousands=\".\"\n)\n\n# String replace & convert to datetime\n## Column 'Zeit von [CET/CEST]'\naustria_generation['Zeit von [CET/CEST]'] = austria_generation['Zeit von [CET/CEST]'].str.replace(pat='2A', repl='02')\naustria_generation['Zeit von [CET/CEST]'] = austria_generation['Zeit von [CET/CEST]'].str.replace(pat='2B', repl='02')\n\naustria_generation['Zeit von [CET/CEST]'] = pd.to_datetime(austria_generation['Zeit von [CET/CEST]'], format=\"%d.%m.%Y %H:%M:%S\")\n\n## Column 'Zeit bis [CET/CEST]'\naustria_generation['Zeit bis [CET/CEST]'] = austria_generation['Zeit bis [CET/CEST]'].str.replace(pat='2A', repl='02')\naustria_generation['Zeit bis [CET/CEST]'] = austria_generation['Zeit bis [CET/CEST]'].str.replace(pat='2B', repl='02')\n\naustria_generation['Zeit bis [CET/CEST]'] = pd.to_datetime(austria_generation['Zeit bis [CET/CEST]'], format=\"%d.%m.%Y %H:%M:%S\")\n\nprint(austria_generation.dtypes)\n\nZeit von [CET/CEST]             datetime64[ns]\nZeit bis [CET/CEST]             datetime64[ns]\nWind [MW]                              float64\nSolar [MW]                             float64\nBiomasse [MW]                          float64\nGas [MW]                               float64\nKohle [MW]                             float64\nÖl [MW]                                float64\nGeothermie [MW]                        float64\nPumpspeicher [MW]                      float64\nLauf- und Schwellwasser [MW]           float64\nSpeicher [MW]                          float64\nSonstige Erneuerbare [MW]              float64\nMüll [MW]                              float64\nAndere [MW]                            float64\ndtype: object\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nTippMusterlösung Aufgabe explorative Datenanalyse\n\n\n\n\n\n\n\nCodePlot\n\n\n\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Set the number of decimal places\npd.set_option(\"display.precision\", 2)\n\n# Load dataset into variable generation0_austria_ms\n\n# !\n# For your own use, adjust the file path to the correct location of the downloaded .csv file.\n# !\ngeneration0_austria_ms = pd.read_csv(\n    \"01-daten/AGPT_2022-12-31T23_00_00Z_2023-12-31T23_00_00Z_15M_de_2024-06-10T09_32_38Z.csv\", \n    sep=\";\", thousands=\".\", decimal=\",\", parse_dates=[0, 1], date_format=\"%d.%m.%Y %H:%M\"\n)\n\n# String replace & convert to datetime\n## Column \"Zeit von [CET/CEST]\"\ngeneration0_austria_ms['Zeit von [CET/CEST]'] = generation0_austria_ms['Zeit von [CET/CEST]'].str.replace(pat='2A', repl='02')\ngeneration0_austria_ms['Zeit von [CET/CEST]'] = generation0_austria_ms['Zeit von [CET/CEST]'].str.replace(pat='2B', repl='02')\n\ngeneration0_austria_ms['Zeit von [CET/CEST]'] = pd.to_datetime(\n    generation0_austria_ms['Zeit von [CET/CEST]'], format=\"%d.%m.%Y %H:%M:%S\"\n)\n\n## Column \"Time to [CET/CEST]\"\ngeneration0_austria_ms['Zeit bis [CET/CEST]'] = generation0_austria_ms['Zeit bis [CET/CEST]'].str.replace(pat='2A', repl='02')\ngeneration0_austria_ms['Zeit bis [CET/CEST]'] = generation0_austria_ms['Zeit bis [CET/CEST]'].str.replace(pat='2B', repl='02')\n\ngeneration0_austria_ms['Zeit bis [CET/CEST]'] = pd.to_datetime(\n    generation0_austria_ms['Zeit bis [CET/CEST]'], format=\"%d.%m.%Y %H:%M:%S\"\n)\n\nprint(generation0_austria_ms.dtypes)\nprint(generation0_austria_ms.head(10))\n\n# Create a copy of the dataset\ngeneration_c_austria_ms = generation0_austria_ms.copy()\n\nplotting_data_ms = generation_c_austria_ms.copy()\n\ngenerator_type = \"Pumpspeicher\"\n\nfig = plt.figure(figsize=(7.5, 12))\nfig.suptitle(generator_type, fontsize=12)\n\nfor i in range(1, 13):\n    plotting_data_monthly_ms = plotting_data_ms[plotting_data_ms[\"Zeit von [CET/CEST]\"].dt.month == i]\n    ax = fig.add_subplot(12, 1, i)\n    ax.plot(plotting_data_monthly_ms[generator_type + \" [MW]\"])\n    plt.margins(x=0.01)\n    ax.set_ylabel(\"MW\")\n    \n    # Create title\n    plt.title(\n        plotting_data_monthly_ms[\"Zeit von [CET/CEST]\"].head(1).dt.strftime('%B').item(), \n        fontsize=10\n    )\n    \n    # Create xticks\n    day_index = plotting_data_monthly_ms[~plotting_data_monthly_ms[\"Zeit von [CET/CEST]\"].dt.day.duplicated()].index\n    day_labels = plotting_data_monthly_ms[\"Zeit von [CET/CEST]\"].dt.day.unique()\n    plt.xticks(day_index, day_labels, fontsize=8)\n\nplt.tight_layout()\nplt.show()\n\n\n\n\n\nZeit von [CET/CEST]             datetime64[ns]\nZeit bis [CET/CEST]             datetime64[ns]\nWind [MW]                              float64\nSolar [MW]                             float64\nBiomasse [MW]                          float64\nGas [MW]                               float64\nKohle [MW]                             float64\nÖl [MW]                                float64\nGeothermie [MW]                        float64\nPumpspeicher [MW]                      float64\nLauf- und Schwellwasser [MW]           float64\nSpeicher [MW]                          float64\nSonstige Erneuerbare [MW]              float64\nMüll [MW]                              float64\nAndere [MW]                            float64\ndtype: object\n  Zeit von [CET/CEST] Zeit bis [CET/CEST]  Wind [MW]  Solar [MW]  \\\n0 2023-01-01 00:00:00 2023-01-01 00:15:00     1000.0         0.0   \n1 2023-01-01 00:15:00 2023-01-01 00:30:00      964.0         0.0   \n2 2023-01-01 00:30:00 2023-01-01 00:45:00      956.0         0.0   \n3 2023-01-01 00:45:00 2023-01-01 01:00:00      992.0         0.0   \n4 2023-01-01 01:00:00 2023-01-01 01:15:00      880.0         0.0   \n5 2023-01-01 01:15:00 2023-01-01 01:30:00      888.0         0.0   \n6 2023-01-01 01:30:00 2023-01-01 01:45:00      948.0         0.0   \n7 2023-01-01 01:45:00 2023-01-01 02:00:00      968.0         0.0   \n8 2023-01-01 02:00:00 2023-01-01 02:15:00      956.0         0.0   \n9 2023-01-01 02:15:00 2023-01-01 02:30:00      952.0         0.0   \n\n   Biomasse [MW]  Gas [MW]  Kohle [MW]  Öl [MW]  Geothermie [MW]  \\\n0          240.0      27.6         0.0      0.0             0.07   \n1          240.0      27.6         0.0      0.0             0.07   \n2          240.0      28.0         0.0      0.0             0.07   \n3          240.0      27.6         0.0      0.0             0.07   \n4          240.0      27.6         0.0      0.0             0.07   \n5          240.0      28.4         0.0      0.0             0.07   \n6          240.0      28.8         0.0      0.0             0.07   \n7          240.0      28.0         0.0      0.0             0.07   \n8          240.0      28.8         0.0      0.0             0.07   \n9          240.0      28.4         0.0      0.0             0.07   \n\n   Pumpspeicher [MW]  Lauf- und Schwellwasser [MW]  Speicher [MW]  \\\n0            -1404.8                        2291.6           70.4   \n1            -1532.8                        2283.2           66.8   \n2            -1544.4                        2240.0          100.4   \n3            -1579.6                        2199.6           77.6   \n4            -1590.8                        2234.8           63.2   \n5            -1602.8                        2229.2           73.6   \n6            -1572.0                        2211.2           69.2   \n7            -1579.2                        2194.8           70.8   \n8            -1649.6                        2202.8           75.2   \n9            -1702.0                        2172.4           65.6   \n\n   Sonstige Erneuerbare [MW]  Müll [MW]  Andere [MW]  \n0                        0.0      100.0         22.0  \n1                        0.0      100.0         22.0  \n2                        0.0      100.0         22.0  \n3                        0.0      100.0         22.0  \n4                        0.0      100.0         22.0  \n5                        0.0      100.0         22.0  \n6                        0.0      100.0         22.0  \n7                        0.0      100.0         22.0  \n8                        0.0      100.0         22.0  \n9                        0.0      100.0         22.0  \n\n\n\n\n\nAnnual profile of pumped storage in Austria 2023\n\n\n\n\n\n\n\nSample solution by Marc Sönnecken. For compatibility with this script, the file paths and object names have been adjusted, and the graphic width reduced.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Energy Data Analysis</span>"
    ]
  },
  {
    "objectID": "skript/energiedatenanalyse.html#background-renewable-energy-expansion-path",
    "href": "skript/energiedatenanalyse.html#background-renewable-energy-expansion-path",
    "title": "1  Energy Data Analysis",
    "section": "7.1 Background: Renewable Energy Expansion Path",
    "text": "7.1 Background: Renewable Energy Expansion Path\nIn Germany, the expansion of renewable energies began in the 1990s. Since the early 2000s, renewable electricity generation has increased largely continuously.\n\n\n\n\nRenewable electricity generation in Germany since 1990\n\n\nRenewable electricity generation in Germany since 1990 by Volker Quaschning based on data from AG Energiebilanzen (Electricity generation by energy source (electricity mix) from 1990 to 2022 (in TWh) Germany total (XLSX)) is licensed under CC BY-SA 4.0 and available at https://www.volker-quaschning.de/datserv/ren-Strom-D/index.php. 2023\n\n \nThe Renewable Energy Sources Act (EEG) defines in Section 4 expansion paths for the installed capacity of solar energy, onshore wind, and biomass. The expansion path for offshore wind is regulated in Section 1 of the Offshore Wind Energy Act.\n\n\n\n\n\n\nWarnungLegal Basis for the Renewable Expansion Path\n\n\n\n\n\n\n\n\n \n\n\n§ 4 Expansion Path\n[…]\n1. an increase in the installed capacity of onshore wind turbines to\na) 69 gigawatts by 2024,\nb) 84 gigawatts by 2026,\nc) 99 gigawatts by 2028,\nd) 115 gigawatts by 2030,\ne) 157 gigawatts by 2035, and\nf) 160 gigawatts by 2040\n[…]\n2. an increase in the installed capacity of offshore wind turbines according to the Offshore Wind Energy Act,\n3. an increase in the installed capacity of solar power plants to\na) 88 gigawatts by 2024,\nb) 128 gigawatts by 2026,\nc) 172 gigawatts by 2028,\nd) 215 gigawatts by 2030,\ne) 309 gigawatts by 2035, and\nf) 400 gigawatts by 2040\n[…]\n4. an installed capacity of biomass plants of 8,400 megawatts by 2030.\n\n\n \n\n\n\n\nRenewable Energy Sources Act (EEG 2023) Federal Ministry of Justice\n\n\n\n\n \n\n\n\n\n \n\n\n§ 1 Purpose and Objective of the Act\n[…]\n(2) The objective of this Act is to increase the installed capacity of offshore wind turbines connected to the grid to at least 30 gigawatts by 2030, at least 40 gigawatts by 2035, and at least 70 gigawatts by 2045.\n\n\n \n\n\n\n\nOffshore Wind Energy Development and Promotion Act (WindSeeG) Federal Ministry of Justice\n\n\n\n\n\n\nThe federal government’s expansion targets specify installed capacities for 2030 and 2035 as:\n\n115 GW onshore wind by 2030, 157 GW by 2035,\n30 GW offshore wind by 2030, 40 GW by 2035,\n215 GW solar by 2030, 309 GW by 2035, and\n8.4 GW biomass.\n\nThis implies a planned increase in installed capacity compared to the 2023 installed capacity of:\n\n\n\nCode-Block 7.1\n\n\n\n# Calculate expansion factors for 2030 and 2035 based on installed capacity\n\nprint(f\"Onshore Wind 2030:\\t{( windonshore_growth_factor_2030 := 115 / (installed_capacity['Wind Onshore [MW]'].sum() / 1000) ):,.2f}\\n\"\n      f\"Offshore Wind 2030:\\t{( windoffshore_growth_factor_2030 := 30 / (installed_capacity['Wind Offshore [MW]'].sum() / 1000) ):,.2f}\\n\"\n      f\"Solar 2030:\\t\\t\\t{( solar_growth_factor_2030 := 215 / (installed_capacity['Photovoltaik [MW]'].sum() / 1000) ):,.2f}\\n\"\n      f\"Biomass 2030:\\t\\t{8.4 / (installed_capacity['Biomasse [MW]'].sum() / 1000):,.2f}\")\n\nprint(f\"\\n\\nOnshore Wind 2035:\\t{( windonshore_growth_factor_2035 := 157 / (installed_capacity['Wind Onshore [MW]'].sum() / 1000) ):,.2f}\\n\"\n      f\"Offshore Wind 2035:\\t{( windoffshore_growth_factor_2035 := 40 / (installed_capacity['Wind Offshore [MW]'].sum() / 1000) ):,.2f}\\n\"\n      f\"Solar 2035:\\t\\t\\t{( solar_growth_factor_2035 := 309 / (installed_capacity['Photovoltaik [MW]'].sum() / 1000) ):,.2f}\\n\"\n      f\"Biomass 2035:\\t\\t{8.4 / (installed_capacity['Biomasse [MW]'].sum() / 1000):,.2f}\")\n\nOnshore Wind 2030:  2.00\nOffshore Wind 2030: 3.69\nSolar 2030:         3.41\nBiomass 2030:       0.99\n\n\nOnshore Wind 2035:  2.73\nOffshore Wind 2035: 4.92\nSolar 2035:         4.90\nBiomass 2035:       0.99\n\n\n\n\n\nBy 2030, onshore wind power production is planned to be doubled, while offshore wind and photovoltaic production are planned to increase by a factor of 3.5. By 2035, onshore wind is expected to nearly triple, and offshore wind and photovoltaic production are expected to quintuple. Biomass expansion is not planned. The growth factors are stored in an object.\n\n\n\n\n\n\nWarnungPower Grid Development Plan\n\n\n\nIn addition to generation capacity, the electricity transmission grid is also to be expanded. These plans are documented in the Power Grid Development Plan, which is updated every two years by the four transmission system operators in coordination with the Federal Network Agency.\nThe current and previous grid development plans can be accessed at https://www.netzentwicklungsplan.de/.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Energy Data Analysis</span>"
    ]
  },
  {
    "objectID": "skript/energiedatenanalyse.html#background-energy-storage",
    "href": "skript/energiedatenanalyse.html#background-energy-storage",
    "title": "1  Energy Data Analysis",
    "section": "7.2 Background: Energy Storage",
    "text": "7.2 Background: Energy Storage\nEnergy storage systems store electricity during periods of surplus and release it during periods of deficit. Different types of energy storage and their applications are presented in the following video. Storage types differ fundamentally in terms of capacity and charge/discharge power.\n\n\nEnergy Technology. 14 Energy Storage. 14.02 Key Figures by Henrik te Heesen is licensed under CC BY-SA 3.0 and available on YouTube. 2020\n\n\n\n\n\n\n\nDefinition 7.1: Selected Key Figures of Energy Storage Systems\n\n\n\n\n\nNominal Storage Capacity: The total amount of energy that can be withdrawn from the storage system.\nUsable Storage Capacity: The portion of nominal capacity that can be used without causing damage.\nDepth of Discharge (DoD): Difference between the maximum and minimum allowed state of charge.\nState of Charge (SoC): Ratio of currently stored energy to nominal capacity, usually expressed as a percentage.\nEfficiency: Effectiveness of storage considering charging, discharging, and losses (such as self-discharge).\n\nFurther key figures are introduced in the following video:\n\nEnergy Technology. 14 Energy Storage. 14.03 Key Figures and Definitions by Henrik te Heesen is licensed under CC BY-SA 3.0 and available on YouTube. 2020",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Energy Data Analysis</span>"
    ]
  },
  {
    "objectID": "skript/energiedatenanalyse.html#calculating-storage-size",
    "href": "skript/energiedatenanalyse.html#calculating-storage-size",
    "title": "1  Energy Data Analysis",
    "section": "7.3 Calculating Storage Size",
    "text": "7.3 Calculating Storage Size\nThe following section develops the basic principles of storage design and the methods for calculating storage size. All considerations are based on the residual load curve. Values below zero correspond to a surplus of renewable generation, while values above zero correspond to a grid load that must be served by dispatchable power plants or storage. The residual load is determined as follows:\n\nrenewables = ['Biomasse [MWh]', 'Wasserkraft [MWh]', 'Wind Offshore [MWh]', 'Wind Onshore [MWh]', 'Photovoltaik [MWh]', 'Sonstige Erneuerbare [MWh]']\n\nresidual_load = pd.DataFrame()\nresidual_load[\"Netzlast [MWh]\"] = consumption[\"Gesamt (Netzlast) [MWh]\"].copy()\nresidual_load[\"Erneuerbare [MWh]\"] = generation[renewables].sum(axis=\"columns\").copy()\nresidual_load[\"Restlast [MWh]\"] = residual_load[\"Netzlast [MWh]\"] - residual_load[\"Erneuerbare [MWh]\"]\nresidual_load = residual_load[\"Restlast [MWh]\"]\n\nTo better understand the scale of the calculations, the storage size is put in relation to the existing pumped-storage capacity of 37.4 GWh.\n\npumped_storage_capacity_MWh = 37.4 * 1000\n\n \n\n\n\n\n\n\nTipp 7.1: Funktionsentwicklung mit Testdaten\n\n\n\n\n\nThe functions developed below generally offer an option to output calculation results, but due to the length of the data series, displaying the residual load is not meaningful. As a result, the data series itself as well as intermediate and final results of the calculations, including any existing errors, cannot be easily reviewed. Therefore, for function development, it is recommended to work with test data. This allows calculations to be performed more quickly, and intermediate results and final outputs can be displayed for verification if needed. The following functions were developed using randomly generated test data.\nIn the following code block, a residual load curve of ten random values is generated. By adjusting the values for a and b, the outcome can be controlled. The output records the sum of the data series. A negative value indicates that the simulated residual load curve shows a surplus production of renewable energy. A positive value indicates that the positive residual load along the simulated curve exceeds the renewable surplus production.\nThe code block also creates a static data series. This serves to store test data that led to errors. The random_data series is output as a list so that it can be copied and pasted into the static data series for further testing.\n\nimport random as rd\nimport pandas as pd\n\n# Generate a list of 10 random integers between -20 and 20\nrandom_data = []\nfor i in range(10):\n    random_data.append(rd.randint(a=-20, b=20))\n\n# Convert the list to a pandas Series with float type\nrandom_data = pd.Series(random_data, dtype='float')\nprint(f\"random_data: {list(random_data)}\\nSum of random_data: {random_data.sum()}\\n\")\n\n# Define a static dataset as a pandas Series with float type\nstatic_data = pd.Series([8, -14, -7, 1, 3, -6, 5, -20, -2, 12], dtype='float')\n\nrandom_data: [-3.0, -8.0, 7.0, -14.0, -6.0, -8.0, 9.0, -6.0, -9.0, -12.0]\nSum of random_data: -50.0\n\n\n\n\n\n\n\nSurplus or Deficit of Renewable Energy\nThe required size of the electricity storage depends, on one hand, on the ratio of the amount of renewable surplus production to the residual load that must be served from the storage. On the other hand, the efficiency η (Greek letter Eta) of the storage during charging and discharging plays a role.\n\n\n\n\n\n\n\n\n\n\n\n\n\nRenewable Electricity Production: Surplus or Deficit?\n\nIf the sum of renewable surplus production is smaller than the residual load to be served from storage, the required storage capacity corresponds to the sum of the renewable surplus production.\n\n\nIf the sum of renewable surplus production is larger than the residual load to be served from storage, the required storage capacity corresponds to the sum of the residual load to be served.\n\n\nWhether there is a surplus or a deficit of renewable electricity production can be determined from the sign of the summed residual load. A negative sign indicates a renewable electricity surplus, while a positive sign indicates a renewable electricity deficit.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nEfficiency\n\nThe charging efficiency reduces the available surplus power. If the sum of renewable surplus production is smaller than the residual load to be met from the storage, the storage can be sized smaller by the charging efficiency.\n\n\nThe discharging efficiency (including storage losses) increases the load to be met by the storage. If the sum of renewable surplus production is greater than the residual load to be met from the storage, the storage must be sized larger by the discharging efficiency.\n\n\n\n\n\n\nCalculation\nWhether phases of renewable overproduction or phases of positive residual load dominate over the course of a year can be determined using the following functions.\n\nwithout efficiencywith efficiency\n\n\n\n# Detect excess renewable energy\n## Input: data = pd.Series(data, dtype='float')\n## Processing: sum is calculated over the pd.Series\n## Output: returns the boolean value of data.sum() &lt; 0\n\ndef check_renewable_excess(data):\n  \n  return data.sum() &lt; 0\n\ncheck_renewable_excess(residual_load)\n\nnp.False_\n\n\n\n\n\n# Determine renewable energy surplus, given a charge and discharge efficiency\n## Input: data = pd.Series(data, dtype='float'), charge_efficiency = 1, discharge_efficiency = 1\n## Processing: values less than 0 are multiplied by the charge efficiency\n## Processing: values greater than 0 are divided by the discharge efficiency\n## Processing: the sum is computed over the pd.Series\n## Output: returns True if data_efficiency_adjusted.sum() &lt; 0, otherwise False\n\ndef check_RE_surplus(data, charge_efficiency=1, discharge_efficiency=1):\n    data_efficiency_adjusted = data.copy()\n    \n    data_efficiency_adjusted[data_efficiency_adjusted &lt; 0] = (\n        data_efficiency_adjusted[data_efficiency_adjusted &lt; 0] * charge_efficiency\n    )\n    data_efficiency_adjusted[data_efficiency_adjusted &gt; 0] = (\n        data_efficiency_adjusted[data_efficiency_adjusted &gt; 0] / discharge_efficiency\n    )\n    \n    return data_efficiency_adjusted.sum() &lt; 0\n\ncheck_RE_surplus(residual_load, charge_efficiency=0.9, discharge_efficiency=0.9)\n\nnp.False_\n\n\n\n\n\nAs known from the marginal electricity analysis in section Kapitel 6.6, there was no surplus of renewable electricity production in 2023.\n\n\n\nCyclicality\nOver the course of a year, the sequence of periods with renewable surpluses and periods with positive residual load affects how large a storage system needs to be.\n\n\n\n\n\n\n\n\n\n\n\n\n\nOrder Dependence\n\nIf only a single year is considered, the order of renewable over- and underproduction determines how much electricity can be stored. In the worst-case scenario, there is a positive residual load in the first half of the year (but the storage is still empty) and renewable overproduction occurs in the second half of the year (which would no longer be absorbed in the second half).\n\n\nOrder dependence can be resolved by considering two consecutive years. In the first year, the storage is connected to the grid empty. The second year begins with the storage filled by the surplus production from the previous year.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nNumber of Full Cycles\n\nThe required size of the energy storage depends on the distribution of the residual load and the number of full cycles achieved. A full cycle means that a storage system is completely charged and then fully discharged.\n\n\nIn the worst-case scenario, only a single charge/discharge cycle occurs. In this case, the required storage size equals the sum of the renewable surplus production.\n\n\nThe more frequently charging and discharging cycles alternate, the smaller the required storage size. This corresponds to the sum of the renewable surplus production divided by the number of full cycles.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nPartial Cycles\n\nThe distribution of occurring partial cycles also reduces the required storage capacity.\n\n\nIf the sum of renewable surplus production is smaller than the residual load that the storage needs to cover, the required storage capacity corresponds to the minimum of the cumulative sum of the residual load, provided it is never set above 0 (exceeding this point would indicate the moment when the storage is empty).\n\n\nIf the sum of renewable surplus production is greater than the residual load that the storage needs to cover, the required storage capacity corresponds to the maximum of the cumulative sum of the residual load, provided it is never set below 0 (falling below this point would indicate the moment when the storage is oversized).\n\n\n\n\n\n\nCalculation\nThe storage capacity is calculated from the annual profile of the residual load. To avoid dependency on the time at which the storage is connected to the grid, the dataset is iterated twice (resolving any order-dependency). The required storage capacity is calculated using the cumulative sum of the residual load. If the sum of renewable surplus production is smaller than the sum of residual load that the storage needs to cover, the cumulative sum is never set above 0. Exceeding this upper limit would be the moment when the storage is empty and positive residual load can no longer be served. Conversely, if the sum of renewable surplus production is greater than the sum of residual load to be covered, the cumulative sum is never set below 0. Falling below this limit would be the moment when the storage is oversized and energy is held that is never consumed by positive residual load throughout the year.\n\nwithout efficiencywith Efficiency\n\n\n\n# Calculate storage size\n## Input: data = pd.Series(data, dtype='float'), output = False\n## Processing: call the function check_RE_surplus to distinguish between upper limit = 0 (storage empty) and lower limit = 0 (storage oversized)\n## Processing: data is concatenated twice into data_x2. For data_x2, the capped cumulative sum at 0 is calculated and storage size is determined.\n## Output: if output = False, the storage size (float) is returned; if output = True, the sum of data and the storage size are printed\n\ndef calculate_storage_capacity(data, output=False):\n\n    data_x2 = pd.concat([data, data])\n\n    surplus = check_RE_surplus(data)\n    \n    if surplus:\n        \n        # calculate capped cumulative sum\n        capped_cumsum = []\n        total = 0\n\n        for i in data_x2:\n            total += i \n\n            # check lower limit\n            if total &lt; 0:\n                total = 0\n            \n            capped_cumsum.append(total)\n\n        storage_capacity = max(capped_cumsum)\n    \n    else:\n\n        # calculate capped cumulative sum\n        capped_cumsum = []\n        total = 0\n\n        for i in data_x2:\n            total += i\n\n            # check upper limit\n            if total &gt; 0:\n                total = 0\n            \n            capped_cumsum.append(total)\n\n        storage_capacity = abs(min(capped_cumsum))\n\n    if output:  # output = True\n        print(f\"\\nSum of data: {data.sum()}\\nStorage size: {storage_capacity}\")\n        \n    else:  # output = False\n        return storage_capacity\n\nstorage_2023 = calculate_storage_capacity(residual_load, output=False)\n\nprint(f\"Required storage size 2023: {storage_2023:,.1f} MWh\\nThis corresponds to {storage_2023 / pumped_storage_capacity_MWh:,.1f} pumped-storage equivalents.\")\n\nRequired storage size 2023: 119,667.0 MWh\nThis corresponds to 3.2 pumped-storage equivalents.\n\n\n\n\n\n# Calculate storage size\n## Input: data = pd.Series(data, dtype='float'), charge_efficiency = 1, discharge_efficiency = 1, output = False\n## Processing: call the function check_RE_surplus to distinguish between upper limit = 0 (storage empty) and lower limit = 0 (storage oversized)\n## Processing: data is concatenated twice to data_x2. For data_x2, the capped cumulative sum at 0 is calculated and the storage size is determined.\n## Output: if output = False, the storage size (float) is returned; if output = True, the sum of data and the storage size are printed\n\ndef calculate_storage_capacity(data, charge_efficiency=1, discharge_efficiency=1, output=False):\n\n    data_x2 = pd.concat([data, data])\n\n    surplus = check_RE_surplus(data, charge_efficiency, discharge_efficiency)\n    \n    if surplus:\n        \n        # Calculate capped cumulative sum\n        capped_cumsum = []\n        total = 0\n\n        for i in data_x2:\n            if i &lt; 0:\n                total += i * charge_efficiency\n            else:\n                total += i / discharge_efficiency\n\n            # Check lower limit\n            if total &lt; 0:\n                total = 0\n            \n            capped_cumsum.append(total)\n\n        storage_capacity = max(capped_cumsum)\n    \n    else:  # Underproduction\n\n        # Calculate capped cumulative sum\n        capped_cumsum = []\n        total = 0\n\n        for i in data_x2:\n            if i &lt; 0:\n                total += i * charge_efficiency\n            else:\n                total += i / discharge_efficiency\n\n            # Check upper limit\n            if total &gt; 0:\n                total = 0\n            \n            capped_cumsum.append(total)\n\n        storage_capacity = abs(min(capped_cumsum))\n\n    if output:  # output = True\n        print(f\"\\nSum of data: {data.sum()}\\nStorage size: {storage_capacity}\")\n\n    else:  # output = False\n        return storage_capacity\n\nstorage_2023capacity = calculate_storage_capacity(residual_load, charge_efficiency=0.9, discharge_efficiency=0.9, output=False)\n\nprint(f\"Required storage size 2023: {storage_2023:,.1f} MWh\\nThis corresponds to {storage_2023 / pumped_storage_capacity_MWh:,.1f} pumped-storage equivalents.\")   \n\nRequired storage size 2023: 119,667.0 MWh\nThis corresponds to 3.2 pumped-storage equivalents.\n\n\n\n\n\n\n\nAnnual Storage Profile\nAfter determining the storage capacity, the annual storage profile for the first and second year can be calculated and visualized. The annual storage profile for the second year represents the stable equilibrium, which can be repeated indefinitely for a given residual load curve.\n\nInput: The function receives a residual load curve as input. Additionally, a storage capacity can be provided; otherwise, it is determined by calling the function calculate_storage_capacity().\nProcessing: Starting with an empty storage, the residual load series is traversed element by element twice. Negative values are stored until the storage capacity is reached. Positive values are withdrawn from the storage until the storage level reaches zero. In the function extended with charge and discharge efficiencies, stored values are multiplied by the charge efficiency (0.9) and withdrawn values are divided by the discharge efficiency (0.9).\nOutput: If output = False, the function returns a tuple. Position 0 contains the storage capacity, position 1 the annual profile for year 1 as a pd.Series, and position 2 the annual profile for year 2 as a pd.Series. The annual profiles are subsequently visualized in a panel. If output = True, the cumulative sum of the residual load and the storage capacity, as well as the provided residual load curve, storage levels, and available capacity for year 1 and year 2, are printed with print()—this is typically useful only for test data.\n\n\nwithout efficiencyPlot without EfficiencyCode for the plot without efficiencyWith EfficiencyPlot with EfficiencyCode for the plot with efficiency\n\n\n\n# Calculate annual storage profile\n## Input: data = pd.Series(data, dtype='float'), storage_capacity=-1, output=False\n## Processing: If storage_capacity=-1, the storage size is determined with the functicapacity(data)\n## Processing: data is concatenated twice to data_x2.\n## Processing: Based on the storage capacity, the storage level and free capacity are calculated for all data values for year 1 and all following years.\n## Output: If output=False, returns a tuple with storage_capacity (float), storage_level_year1 (pd.Series), storage_level_year2 (pd.Series)\n## Output: If output=True, also returns cumulative residual load, storage capacity, residual load curve, storage levels, and free storage capacity for year 1 and year 2\n\ndef calculate_annual_storage(data, storage_capacity=-1, output=False):\n\n    data_x2 = pd.concat([data, data])\n\n    if storage_capacity == -1:\n        storage_capacity = calculate_storage_capacity(data) \n\n    # Calculate annual storage profile\n    annual_storage = []\n    storage_level = []\n    free_capacity = storage_capacity  # storage is empty\n    for i in data_x2:\n\n        if (storage_capacity - free_capacity) - i &lt; 0:  # load without prior storage cannot be supplied\n            free_capacity = storage_capacity\n\n        elif free_capacity + i &lt; 0:  # if storage is full, surplus must be discarded\n            free_capacity = 0\n\n        else:  # charging/discharging\n            free_capacity += i\n\n        annual_storage.append(free_capacity)\n        storage_level.append(storage_capacity - free_capacity)\n\n    if output:  # output=True\n        dataset = pd.DataFrame({\n            'Residual Load': data,\n            'Storage Level Year1': storage_level[:len(annual_storage)//2],\n            'Free Capacity Year1': annual_storage[:len(annual_storage)//2],\n            'Storage Level Following Years': storage_level[len(annual_storage)//2:],\n            'Free Capacity Following Years': annual_storage[len(annual_storage)//2:]\n        })\n\n        print(f\"\\nSum of data: {data.sum()}\\nStorage Capacity: {storage_capacity}\")\n        print(dataset)\n\n    else:  # output=False\n        return storage_capacity, pd.Series(storage_level[:len(annual_storage)//2]), pd.Series(storage_level[len(annual_storage)//2:])\n\nstorage_2023 = calculate_annual_storage(residual_load, output=False)\n\n\n\n\n\n\n\n\nResidual load 2023 and annual cycle of a storage with efficiency 1\n\n\n\n\n\n\n\n# Load data\nannual_storage_year1 = storage_2023[1]\nannual_storage_year2 = storage_2023[2]\n\n# Create xticks\nmonth_index = generation[~generation[\"Datum von\"].dt.month.duplicated()].index\nmonth_names = generation[\"Datum von\"].iloc[month_index].dt.strftime(\"%B\") \n\n# Create graphic with three subplots\nfont_size = 10\n\nfig, (ax1, ax2, ax3) = plt.subplots(3, 1, figsize = (7.5, 6), height_ratios = [2, 1, 1], sharex = True, layout = 'tight')\nplt.suptitle('Residual load 2023 and annual cycle of a storage with efficiency 1')\nplt.xticks(month_index, month_names, rotation = 45);\nplt.minorticks_off()\nplt.setp([ax1, ax2, ax3], xlim = (residual_load.index.min() - len(residual_load.index) / 100, residual_load.index.max() * 1.01))\nplt.setp([ax2, ax3], ylim = (0, max(max(annual_storage_year1), max(annual_storage_year2)) * 1.1))\n\n## plot residual load\nax1.plot(residual_load, label = \"Residual load\")\nax1.grid()\nax1.set_ylabel('MWh')\nax1.legend()\n\n## plot annual_storage_year1\nax2.plot(annual_storage_year1, color = 'black', linestyle = '-', label = 'Battery Year 1')\nax2.grid()\nax2.set_ylabel('MWh')\nax2.legend()\n\n## plot annual_storage_year2\nax3.plot(annual_storage_year2, color = 'black', linestyle = '-', label = 'Battery Year 2')\nax3.tick_params(axis = 'x', rotation = 45)\nax3.set_ylabel('MWh')\nax3.grid()\nax3.legend()\n\nplt.show()\n\n\n\n\n# Calculate annual storage cycle\n## Input: data = pd.Series(data, dtype = 'float'), storage_capacity = -1, charge_efficiency = 1, discharge_efficiency = 1, output = False\n## Processing: If storage_capacity = -1, the storage size is calculated with the functicapacity(data).\n## Processing: data is concatenated twice to data_x2.\n## Processing: Based on the storage size, the state of charge and free capacity are calculated for all values of data for Year1 and all following years.\n## Output: If output is False, a tuple of storage_capacity (float), state of charge Year1 (pd.Series), state of charge Year2 (pd.Series) is returned.\n## Output: If output is True, the cumulative sum of the residual load, the storage size, the residual load curve, the states of charge and free capacities for Year1 and Year2 are returned.\n\ndef calculate_annual_storage(data, storage_capacity = -1, charge_efficiency = 1, discharge_efficiency = 1, output = False):\n\n  data_x2 = pd.concat([data, data])\n\n  if storage_capacity == -1:\n    storage_capacity = calculate_storage_capacity(data, charge_efficiency, discharge_efficiency) \n\n  annual_storage = []\n  storage_state = []\n  free_capacity = storage_capacity # storage is empty \n  for i in data_x2:\n\n    if i &gt; 0: # residual load\n\n      # demand without corresponding previous charging cannot be fully supplied, storage then empty\n      if (storage_capacity - free_capacity) - i / discharge_efficiency &lt; 0:\n        free_capacity = storage_capacity\n\n      else: # discharging\n        free_capacity += i / discharge_efficiency # here too much can be discharged\n        if free_capacity &gt; storage_capacity:\n          free_capacity = storage_capacity\n    \n    else: # i &lt;= 0 renewable surplus\n      \n      # if storage is full, surplus must be discarded\n      if free_capacity + i * charge_efficiency &lt; 0: \n        free_capacity = 0\n      \n      else: # charging\n        free_capacity += i * charge_efficiency\n\n    annual_storage.append(free_capacity)\n    storage_state.append(storage_capacity - free_capacity)\n\n  if output: # output = True\n\n    dataset = pd.DataFrame({'Residual load': data, 'State of charge Year1': storage_state[ : len(annual_storage) // 2 ], 'Free capacity Year1': annual_storage[ : len(annual_storage) // 2 ], 'State of charge following years': storage_state[ len(annual_storage) // 2 : ], 'Free capacity following years': annual_storage[ len(annual_storage) // 2 : ]})\n\n    print(f\"\\nSum data: {data.sum()}\\nStorage size: {storage_capacity}\")\n    print(dataset)\n\n  else: # output = False\n    return storage_capacity, pd.Series(storage_state[ : len(annual_storage) // 2 ]), pd.Series(storage_state[ len(annual_storage) // 2 : ])\n\nstorage_2023_eff_90_90 = calculate_annual_storage(residual_load, charge_efficiency = 0.9, discharge_efficiency = 0.9, output = False)\n\n\n\n\n\n\n\n\nResidual load 2023 and annual cycle of a storage with charge and discharge efficiency 0.9\n\n\n\n\n\n\n\n# Load data\nannual_storage_year1 = storage_2023_eff_90_90[1]\nannual_storage_year2 = storage_2023_eff_90_90[2]\n\n# Create xticks\nmonth_index = generation[~generation[\"Datum von\"].dt.month.duplicated()].index\nmonth_names = generation[\"Datum von\"].iloc[month_index].dt.strftime(\"%B\") \n\n# Create graphic with three subplots\nfont_size = 10\n\nfig, (ax1, ax2, ax3) = plt.subplots(3, 1, figsize = (7.5, 6), height_ratios = [2, 1, 1], sharex = True, layout = 'tight')\nplt.suptitle('Residual load 2023 and annual cycle of a storage with charge and discharge efficiency 0.9')\nplt.xticks(month_index, month_names, rotation = 45);\nplt.minorticks_off()\nplt.setp([ax1, ax2, ax3], xlim = (residual_load.index.min() - len(residual_load.index) / 100, residual_load.index.max() * 1.01))\nplt.setp([ax2, ax3], ylim = (0, max(max(annual_storage_year1), max(annual_storage_year2)) * 1.1))\n\n## plot residual load\nax1.plot(residual_load, label = \"Residual load\")\nax1.grid()\nax1.set_ylabel('MWh')\nax1.legend()\n\n## plot annual_storage_year1\nax2.plot(annual_storage_year1, color = 'black', linestyle = '-', label = 'Battery Year 1')\nax2.grid()\nax2.set_ylabel('MWh')\nax2.legend()\n\n## plot annual_storage_year2\nax3.plot(annual_storage_year2, color = 'black', linestyle = '-', label = 'Battery Year 2')\nax3.tick_params(axis = 'x', rotation = 45)\nax3.set_ylabel('MWh')\nax3.grid()\nax3.legend()\n\nplt.show()\n\n\n\n\nThe required storage capacity results from the renewable generation surpluses during the Christmas holidays. These capacities are hardly used during the rest of the year, so the storage remains empty most of the time. The annual profile for the first and second year is visually identical. This can easily be checked with pd.Series1.equals(pd.Series2). If charging and discharging efficiencies are considered, the charged and discharged energy – and thus the required storage capacity – are reduced.\n\n\nCalculate number of cycles\nBased on the storage size and the annual profile of the storage, the number of cycles can be calculated for the first year and for all subsequent years. One cycle corresponds to a complete charge and discharge of the storage or an equivalent number of partial charge cycles. The number of cycles therefore results from the sum of the charged and discharged energy in the annual profile of the storage, divided by the storage size and by 2.\n\nInput: The function can be provided with a tuple consisting of a storage size at position 0 and storage annual profiles for year 1 and year 2 at positions 1 and 2. Otherwise, these are determined by calling the function calculate_storage_annual_profile (without or with charging and discharging efficiency).\nProcessing: To determine the charged and discharged energy, the method pd.Series.diff() is used for the storage annual profiles to compute the element-wise difference of each value to its predecessor (sliding difference). For example, for the sequence 1, 4, -6, 2, the element-wise difference is NaN, 3, -10, 8. Since the first value has no predecessor, the difference is NaN. Therefore, a zero is prepended to the annual profile in year 1 (because the storage starts empty when connected to the grid), and for year 2 the last value from year 1 is prepended (because the storage starts into the second year with that charge level). The sequence for year 2 would then look like this: 2, 1, 4, -6, 2. The element-wise difference would be: NaN, -1, 3, -10, 8. Afterwards, the values are converted to absolute values and summed. The instruction is thus: pd.Series.diff().abs().sum(). To calculate the number of cycles, the sum of the charged and discharged energy is divided by the storage size and by 2.\nOutput: If output = False, the function returns a tuple with the number of cycles for year 1 and year 2. If output = True, the output is printed using print().\n\n\nwithout efficiencywith Efficiency\n\n\n\n# Calculate number of cycles\n## Input: data = pd.Series(data, dtype='float'), output = False\n## Input: If the input is a tuple {'storage_capacity': float, 'storage_profile_year1': pd.Series, 'storage_profile_year2': pd.Series}, the number of cycles is calculated directly.\n## Input: If the input is data = pd.Series(data, dtype='float'), then storage_profile_calculate(data, storage_capacity = -1, output = False) is called.\n## Processing: Element-wise, for year 1 and year 2, the difference between consecutive values is computed, absolute values are taken, and summed.\n## Processing: For sliding difference calculation, a zero must be prepended to the profile in year 1, and the last value from year 1 must be prepended to the profile in year 2.\n## Processing: The sum of storage charging and discharging is divided by the storage capacity and by 2.\n## Output: Number of cycles for year 1 and year 2 – if output = False, returned as a tuple; if output = True, printed.\n\ndef calculate_cycles(data, output = False):\n  \n  if type(data) is tuple: # storage capacity and profiles were provided\n    storage_capacity = data[0]\n    storage_profile_year1 = data[1]\n    storage_profile_year2 = data[2]\n  \n  else: # residual load was provided\n    result = storage_profile_calculate(data, storage_capacity = -1, output = False)\n    storage_capacity = result[0]\n    storage_profile_year1 = result[1]\n    storage_profile_year2 = result[2]\n  \n  # Prepend a zero to year 1 profile, prepend the last value of year 1 to year 2 profile\n  storage_profile_year1 = pd.concat([pd.Series(0), storage_profile_year1])\n  storage_profile_year2 = pd.concat([storage_profile_year1[-1:], storage_profile_year2])\n\n  # Calculate number of cycles\n  cycles_year1 = storage_profile_year1.diff().abs().sum() / (storage_capacity * 2) # one cycle = full charge and discharge --&gt; divide by 2\n  cycles_year2 = storage_profile_year2.diff().abs().sum() / (storage_capacity * 2) # one cycle = full charge and discharge --&gt; divide by 2\n  \n  if output:\n    print(f\"Number of cycles year 1: {cycles_year1:,.2f}\\n\"\n          f\"Number of cycles year 2: {cycles_year2:,.2f}\")\n  \n  else:\n    return cycles_year1, cycles_year2\n  \ncalculate_cycles(storage_2023, output = True)\n\nNumber of cycles year 1: 8.38\nNumber of cycles year 2: 8.38\n\n\n\n\n\n# Calculate number of cycles with efficiency\n## Input: data = pd.Series(data, dtype = 'float'), charge_efficiency = 1, discharge_efficiency = 1, output = False\n## Input: If the input is a tuple {'storage_capacity': float, 'storage_profile_year1': pd.Series, 'storage_profile_year2': pd.Series}, the number of cycles is calculated directly.\n## Input: If the input is data = pd.Series(data, dtype = 'float'), then calculate_annual_storage(data, storage_capacity = -1, charge_efficiency = 1, discharge_efficiency = 1, output = False) is called.\n## Processing: For year 1 and year 2, the element-wise difference of consecutive values is computed, taken as absolute, and summed.\n## Processing: For the sliding difference calculation, prepend a zero to the storage profile in year 1, and prepend the last value from year 1 to the storage profile of year 2.\n## Processing: The sum of storage charging and discharging is divided by the storage capacity and then by 2.\n## Output: Number of cycles for year 1 and year 2 – if output = False as return value (tuple), if output = True via print()\n\ndef calculate_cycles(data, charge_efficiency = 1, discharge_efficiency = 1, output = False):\n  \n  if type(data) is tuple: # storage capacity and storage profiles were passed\n    storage_capacity = data[0]\n    storage_profile_year1 = data[1]\n    storage_profile_year2 = data[2]\n  \n  else: # residual load was passed\n    result = calculate_annual_storage(data, storage_capacity = -1, charge_efficiency = charge_efficiency, discharge_efficiency = discharge_efficiency, output = False)\n    storage_capacity = result[0]\n    storage_profile_year1 = result[1]\n    storage_profile_year2 = result[2]\n  \n  # prepend zero to storage profile year 1, prepend last value from year 1 to storage profile year 2\n  storage_profile_year1 = pd.concat([pd.Series(0), storage_profile_year1])\n  storage_profile_year2 = pd.concat([storage_profile_year1[ - 1: ], storage_profile_year2])\n\n  # calculate number of cycles  \n  cycles_year1 = storage_profile_year1.diff().abs().sum() / (storage_capacity * 2) # one cycle = full charge and discharge --&gt; divide by 2\n  cycles_year2 = storage_profile_year2.diff().abs().sum() / (storage_capacity * 2) # one cycle = full charge and discharge --&gt; divide by 2\n  \n  if output:\n    print(f\"Number of cycles year 1: {cycles_year1:,.2f}\\n\"\n          f\"Number of cycles year 2: {cycles_year2:,.2f}\")\n  \n  else:\n    return cycles_year1, cycles_year2\n  \ncalculate_cycles(residual_load, charge_efficiency = 0.9, discharge_efficiency = 0.9, output = True)\n\nNumber of cycles year 1: 8.79\nNumber of cycles year 2: 8.79\n\n\n\n\n\nDue to the low renewable generation surpluses in 2023, the number of cycles in Year 1 and Year 2 is identical. When efficiency is considered, the number of cycles increases because the storage size is smaller.\n\n\n\nCapping\n\n\n\n\n\n\n\n\n\n\n\n\n\nCapping of Generation Peaks\n\nCapping of generation peaks is a way to reduce the required storage size. Limiting the charging leads to better utilization of storage capacity and a higher number of cycles.\n\n\nIn the upper example, the storage size is dimensioned according to the maximum renewable surplus production. The storage thus reaches 1.5 cycles.\n\n\nIn the lower example, the storage is dimensioned smaller. The storage reaches 2 cycles.\n\n\n\n\n\n\nCalculation\nBased on the annual profile of the storage, the effect of capping generation peaks on the stored electricity amount and the achieved number of storage cycles can be calculated. For this purpose, the annual profile of the storage is computed for various reduced storage sizes, along with the achieved cycle number and the amount of electricity not stored.\n\nInput: The function is given a residual load data series as a pd.Series and optionally a list of reduced storage sizes, expressed as relative fractions of 1. If no list is provided, the calculation is performed for the relative storage sizes [0.9, 0.8, 0.7, 0.6, 0.5].\nProcessing: For the residual load, the uncapped storage size and annual profiles in year 1 and year 2 are calculated by calling the function calculate_storage_annual_profile. Then the achieved cycle number is determined by calling the function calculate_cycles. Based on the annual profiles, the stored electricity amount is calculated. For this, the method pd.Series.diff() is used to compute the elementwise difference between each value and its predecessor (sliding difference). As with the cycle calculation, a zero is prepended to the annual profile in year 1, and the last value of year 1 is prepended to year 2. The stored electricity amount is the sum of all positive values in this series. Negative values indicate a reduction of the charge between two points in time, i.e. discharging phases. Therefore, negative values are set to zero with the .clip method. The instruction is: pd.Series.diff().clip(lower = 0).sum().\nThese steps are repeated for all elements in the variable new_storage_capacitys. For this, the uncapped storage size is multiplied by one of the relative storage sizes, and the achieved cycle number as well as the stored electricity amount are calculated. From the difference of the stored electricity amount for each new storage size compared to the baseline year, the capped electricity amount is determined.\nOutput: If output = False, a DataFrame with three columns is returned. The column with index 0 contains the relative storage size, columns 1 and 2 contain the capped electricity amounts in year 1 and year 2. If output = True, this DataFrame is printed with print(). Additionally, a five-column DataFrame with the intermediate results (including the baseline year in row 0) is printed. This contains in the column with index 0 the absolute storage size, and in the following columns the stored electricity amount in year 1 (column with index 1), the cycle number in year 1 (column with index 2), the stored electricity amount in year 2 (column with index 3), and the cycle number in year 2 (column with index 4).\n\n\nwithout efficiencywith Efficiency\n\n\n\n# Curtailment calculation: How much renewable energy (RE) is discarded when storage size is limited?\n## Input: Residual load curve data = pd.Series(data, dtype='float', new_storage_capacitys = [0.9, 0.8, 0.7, 0.6, 0.5], output = False)\n## Processing: For data, the function calculate_annual_storage() determines the storage size and the storage profiles for Year 1 and Year 2 without additional curtailment\n## Processing: For data, the function calculate_cycles() determines the number of cycles in Year 1 and Year 2 without additional curtailment\n## Processing: Based on the storage profiles, the stored electricity amount without additional curtailment is determined\n## Processing: The processing steps are repeated for all elements provided in the variable new_storage_capacitys\n## Processing: The storage size of the base residual load curve data is multiplied by the values provided in new_storage_capacitys\n## Processing: From the difference between the stored electricity amounts for each new storage size and the base year, the curtailed electricity amount is determined\n## Output: If output = False, a DataFrame with three columns is returned. Column with index 0 contains the relative storage size, Columns 1 and 2 contain the curtailed electricity amounts in Year 1 and Year 2.\n## Output: If output = True, the three-column DataFrame is printed using print().\n## Output: Additionally, a five-column DataFrame with intermediate results (including base year) is printed.\n## Output: (Index information): 0 = absolute storage size, 1 = stored electricity Year 1, 2 = cycle number Year 1, 3 = stored electricity Year 2, 4 = cycle number Year 2\n\ndef calculate_curtailment_effect(data, new_storage_capacitys = [0.9, 0.8, 0.7, 0.6, 0.5], output = False):\n\n  # Determine base year storage size\n  result = calculate_annual_storage(data, storage_capacity = -1, output = False)\n  storage_capacity0 = result[0]\n  storage_profile_year1 = result[1]\n  storage_profile_year2 = result[2]\n\n  # Determine number of cycles in base year, pass tuple\n  cycles = calculate_cycles(result, output = False)\n  cycles_year1 = cycles[0]\n  cycles_year2 = cycles[1]\n  \n  # Add a zero in front of storage profile Year 1, append last value of Year 1 to Year 2\n  storage_profile_year1 = pd.concat([pd.Series([0]), storage_profile_year1])\n  storage_profile_year2 = pd.concat([storage_profile_year1[-1:], storage_profile_year2])\n\n  # Determine stored electricity in base year\n  storage_amount_year1 = storage_profile_year1.diff().clip(lower = 0).sum()\n  storage_amount_year2 = storage_profile_year2.diff().clip(lower = 0).sum()\n\n  # Save results in DataFrame\n  dataframe = pd.DataFrame({'Storage size': [storage_capacity0], 'Storage amount Year1': [storage_amount_year1], 'Cycles Year1': cycles_year1, 'Storage amount Year2': [storage_amount_year2], 'Cycles Year2': cycles_year2})\n  \n  # Determine stored electricity with alternative storage sizes\n  count = 1\n\n  for i in range(len(new_storage_capacitys)):\n\n    storage_capacity_new = storage_capacity0 * new_storage_capacitys[i]\n    \n    result = calculate_annual_storage(data, storage_capacity = storage_capacity_new, output = False)\n    storage_profile_year1 = result[1]\n    storage_profile_year2 = result[2]\n\n    # Determine number of cycles in base year, pass tuple\n    cycles = calculate_cycles(result, output = False)\n    cycles_year1 = cycles[0]\n    cycles_year2 = cycles[1]\n\n    # Add a zero in front of storage profile Year 1, append last value of Year 1 to Year 2\n    storage_profile_year1 = pd.concat([pd.Series([0]), storage_profile_year1])\n    storage_profile_year2 = pd.concat([storage_profile_year1[-1:], storage_profile_year2])\n\n    # Determine stored electricity with new storage size\n    storage_amount_year1 = storage_profile_year1.diff().clip(lower = 0).sum()\n    storage_amount_year2 = storage_profile_year2.diff().clip(lower = 0).sum()\n\n    new_row = [storage_capacity_new, storage_amount_year1, cycles_year1, storage_amount_year2, cycles_year2]\n    dataframe.loc[count] = new_row\n  \n    count += 1\n  \n  # Calculate curtailed amount data.sub(data[0]).drop(0)\n  curtailed_storage_year1 = dataframe['Storage amount Year1'].sub(dataframe['Storage amount Year1'][0]).abs().drop(0).reset_index(drop = True)\n  curtailed_storage_year2 = dataframe['Storage amount Year2'].sub(dataframe['Storage amount Year2'][0]).abs().drop(0).reset_index(drop = True)\n  dataset = pd.DataFrame({'Relative storage size': pd.Series(new_storage_capacitys), 'Curtailed storage Year1': curtailed_storage_year1, 'Curtailed storage Year2': curtailed_storage_year2})\n  \n  if output:\n\n    print(dataframe)\n    print(\"\\n\")\n    print(dataset)\n\n  else:\n    return dataset\n\ncalculate_curtailment_effect(residual_load, output = True)\n\n   Storage size  Storage amount Year1  Cycles Year1  Storage amount Year2  \\\n0      119667.0              1.00e+06          8.38              1.00e+06   \n1      107700.3              9.91e+05          9.20              9.91e+05   \n2       95733.6              9.79e+05         10.23              9.79e+05   \n3       83766.9              9.63e+05         11.49              9.63e+05   \n4       71800.2              9.39e+05         13.07              9.39e+05   \n5       59833.5              8.99e+05         15.03              8.99e+05   \n\n   Cycles Year2  \n0          8.38  \n1          9.20  \n2         10.23  \n3         11.49  \n4         13.07  \n5         15.03  \n\n\n   Relative storage size  Curtailed storage Year1  Curtailed storage Year2\n0                    0.9                  11966.7                  11966.7\n1                    0.8                  23933.4                  23933.4\n2                    0.7                  40443.7                  40443.7\n3                    0.6                  64377.1                  64377.1\n4                    0.5                 103619.5                 103619.5\n\n\n\n\n\n# Calculate curtailment: How much renewable energy is discarded when storage size is limited?\n## Input: Residual load curve data = pd.Series(data, dtype = 'float', charge_efficiency = 1, discharge_efficiency = 1, new_storage_capacitys = [0.9, 0.8, 0.7, 0.6, 0.5], output = False)\n## Processing: For data, the function calculate_annual_storage() determines the storage size and the annual profiles for Year 1 and Year 2 without additional curtailment\n## Processing: For data, the function calculate_cycles() determines the number of cycles in Year 1 and Year 2 without additional curtailment\n## Processing: Based on the annual profiles, the stored electricity amount without additional curtailment is determined\n## Processing: These steps are repeated for all elements passed in the variable new_storage_capacitys\n## Processing: The storage size of the base residual load curve data is multiplied by the values passed in new_storage_capacitys\n## Processing: From the difference between stored electricity for each new storage size and the base year, the curtailed electricity is determined\n## Output: If output = False a DataFrame with three columns is returned. Column 0 contains the relative storage size, columns 1 and 2 contain the curtailed electricity in Year 1 and Year 2.\n## Output: If output = True the three-column DataFrame is printed with print().\n## Output: Additionally, a five-column DataFrame with intermediate results (including the base year) is printed with print().\n## Output: (Index references): 0 = absolute storage size, 1 = stored electricity Year 1, 2 = cycles Year 1, 3 = stored electricity Year 2, 4 = cycles Year 2\n\ndef calculate_curtailment_effect(data, charge_efficiency = 1, discharge_efficiency = 1, new_storage_capacitys = [0.9, 0.8, 0.7, 0.6, 0.5], output = False):\n\n  # Determine storage size in the base year\n  result = calculate_annual_storage(data, storage_capacity = -1, charge_efficiency = charge_efficiency, discharge_efficiency = discharge_efficiency, output = False)\n  base_storage_capacity = result[0]\n  storage_profile_year1 = result[1]\n  storage_profile_year2 = result[2]\n\n  # Determine number of cycles in the base year, pass tuple\n  cycles = calculate_cycles(result, charge_efficiency = charge_efficiency, discharge_efficiency = discharge_efficiency, output = False)\n  cycles_year1 = cycles[0]\n  cycles_year2 = cycles[1]\n  \n  # Prepend zero to annual profile Year 1, add last value of Year 1 to start of Year 2\n  storage_profile_year1 = pd.concat([pd.Series([0]), storage_profile_year1])\n  storage_profile_year2 = pd.concat([storage_profile_year1[ - 1: ], storage_profile_year2])\n\n  # Determine stored electricity in the base year\n  storage_year1 = storage_profile_year1.diff().clip(lower = 0).sum()\n  storage_year2 = storage_profile_year2.diff().clip(lower = 0).sum()\n\n  # Save results in DataFrame\n  dataframe = pd.DataFrame({'Storage size': [base_storage_capacity], 'Storage Year1': [storage_year1], 'Cycles Year1': cycles_year1, 'Storage Year2': [storage_year2], 'Cycles Year2': cycles_year2})\n  \n  # Determine stored electricity for alternative storage sizes\n  count = 1\n\n  for i in range(len(new_storage_capacitys)):\n\n    new_storage_capacity = base_storage_capacity * new_storage_capacitys[i]\n    \n    result = calculate_annual_storage(data, storage_capacity = new_storage_capacity, charge_efficiency = charge_efficiency, discharge_efficiency = discharge_efficiency, output = False)\n    storage_profile_year1 = result[1]\n    storage_profile_year2 = result[2]\n\n    # Determine number of cycles for new storage size\n    cycles = calculate_cycles(result, charge_efficiency = charge_efficiency, discharge_efficiency = discharge_efficiency, output = False)\n    cycles_year1 = cycles[0]\n    cycles_year2 = cycles[1]\n\n    # Prepend zero to annual profile Year 1, add last value of Year 1 to start of Year 2\n    storage_profile_year1 = pd.concat([pd.Series([0]), storage_profile_year1])\n    storage_profile_year2 = pd.concat([storage_profile_year1[ - 1: ], storage_profile_year2])\n\n    # Determine stored electricity for new storage size\n    storage_year1 = storage_profile_year1.diff().clip(lower = 0).sum()\n    storage_year2 = storage_profile_year2.diff().clip(lower = 0).sum()\n\n    new_row = [new_storage_capacity, storage_year1, cycles_year1, storage_year2, cycles_year2]\n    dataframe.loc[count] = new_row\n  \n    count += 1\n  \n  # Calculate curtailed amounts data.sub(data[0]).drop(0)\n  curtailed_storage_year1 = dataframe['Storage Year1'].sub(dataframe['Storage Year1'][0]).abs().drop(0).reset_index(drop = True)\n  curtailed_storage_year2 = dataframe['Storage Year2'].sub(dataframe['Storage Year2'][0]).abs().drop(0).reset_index(drop = True)\n  dataset = pd.DataFrame({'Relative storage size': pd.Series(new_storage_capacitys), 'Curtailed storage Year1': curtailed_storage_year1, 'Curtailed storage Year2': curtailed_storage_year2})\n  \n  if output:\n\n    print(dataframe)\n    print(\"\\n\")\n    print(dataset)\n\n  else:\n    return dataset\n\ncalculate_curtailment_effect(residual_load, charge_efficiency = 0.9, discharge_efficiency = 0.9, output = True)\n\n   Storage size  Storage Year1  Cycles Year1  Storage Year2  Cycles Year2\n0     102674.54      902678.40          8.79      902678.40          8.79\n1      92407.08      892410.95          9.66      892410.95          9.66\n2      82139.63      882143.49         10.74      882143.49         10.74\n3      71872.18      864601.21         12.03      864601.21         12.03\n4      61604.72      844066.30         13.70      844066.30         13.70\n5      51337.27      799701.77         15.58      799701.77         15.58\n\n\n   Relative storage size  Curtailed storage Year1  Curtailed storage Year2\n0                    0.9                 10267.45                 10267.45\n1                    0.8                 20534.91                 20534.91\n2                    0.7                 38077.19                 38077.19\n3                    0.6                 58612.10                 58612.10\n4                    0.5                102976.63                102976.63",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Energy Data Analysis</span>"
    ]
  },
  {
    "objectID": "skript/energiedatenanalyse.html#determine-share-of-renewable-electricity-generation",
    "href": "skript/energiedatenanalyse.html#determine-share-of-renewable-electricity-generation",
    "title": "1  Energy Data Analysis",
    "section": "7.4 Determine Share of Renewable Electricity Generation",
    "text": "7.4 Determine Share of Renewable Electricity Generation\nBy integrating an electricity storage system into the power grid, excess renewable generation can be shifted to periods with a positive residual load that would otherwise need to be met by conventional power plants. This reduces the share of conventional electricity generation and increases the share of renewable electricity generation.\n\n\n\n\n\n\n\n\n\n\n\n\n\nDetermine Share of Renewable Electricity Production\n\nStoring electricity reduces the positive residual load.\n\n\nIf the stored electricity is subtracted from the positive residual load (either cumulatively or annually), the share of load that must be covered conventionally corresponds to the quotient of summed positive residual load and summed grid load, or the quotient of summed positive residual load and total electricity generation.\n\n\nThe share of renewable electricity production is 1 minus the share of load that must be covered conventionally.\n\n\n\n\n\nThe share of renewable electricity production can therefore be calculated as follows:\n\nresidual_load.clip(lower = 0).sum() / consumption['Gesamt (Netzlast) [MWh]'].sum()\n\nprint(f\"Sum of positive residual load [MWh]: {residual_load.clip(lower = 0).sum()}\\n\"\n      f\"Sum of grid load: {consumption['Gesamt (Netzlast) [MWh]'].sum()}\\n\"\n      f\"Quotient positive residual load / grid load: {residual_load.clip(lower = 0).sum() / consumption['Gesamt (Netzlast) [MWh]'].sum():,.2f}\\n\"\n      f\"Share of renewable generation: { ( renewable_share := 1 - (residual_load.clip(lower = 0).sum() / consumption['Gesamt (Netzlast) [MWh]'].sum()) ) :,.2f}\\n\\n\"\n\n      f\"Sum of generation: {generation.sum(numeric_only = True).sum()}\\n\"\n      f\"Quotient positive residual load / generation: {residual_load.clip(lower = 0).sum() / generation.sum(numeric_only = True).sum():,.2f}\\n\"\n      f\"Share of renewable generation: {1 - (residual_load.clip(lower = 0).sum() / generation.sum(numeric_only = True).sum()):,.2f}\")\n\nSum of positive residual load [MWh]: 207842228.25\nSum of grid load: 458271100.75\nQuotient positive residual load / grid load: 0.45\nShare of renewable generation: 0.55\n\nSum of generation: 448650448.25\nQuotient positive residual load / generation: 0.46\nShare of renewable generation: 0.54\n\n\nThe grid load from the dataset consumption deviates slightly at 458 TWh from the summed electricity generation in the dataset generation at 448 TWh. As a result, the calculated shares differ slightly.\n\nCalculation\nThe basis for calculating the share of renewable electricity generation after discharging renewable surplus production is the annual cycle of the storage. Discharging electricity means a reduction of the state of charge between two points in time. The discharged electricity reduces the positive residual load at that time. Consequently, the ratio of positive residual load to grid load decreases, and the share of renewable electricity generation increases. This is implemented in the following function.\n\nInput: The function receives a residual load data series. Optionally, a grid load data series can also be provided. Additionally, an optional list of reduced storage sizes, expressed as relative fractions of 1, can be supplied. If no list is provided, the calculation is performed for the relative storage sizes [0.9, 0.8, 0.7, 0.6, 0.5].\nProcessing: By calling the function calculate_annual_storage(), the annual cycles of the electricity storage with relative size 1 are calculated for the residual load data series. Using these annual cycles, the discharged electricity amount in the annual cycle is determined with the method pd.Series.diff().clip(upper = 0). For this sliding difference calculation, a zero is prepended to the annual cycle in year 1, and the last value from year 1 is prepended to the annual cycle in year 2. The first value in the annual cycle of the discharged electricity amount is NaN, so this value is dropped and the index is reset. The complete command is: pd.Series.diff().clip(upper = 0)[1:].reset_index(drop = True). The annual cycle of the discharged electricity amount is subtracted from the residual load curve, thereby determining the residual load curve after discharging. Since discharging in the annual cycle is represented by negative values, the difference is calculated by addition.\nIf a grid load data series is provided, the realized share of renewable generation is calculated based on the residual load curve after discharging: 1 - (sum of positive residual load / sum of grid load). The calculations are repeated for smaller-sized storages.\nOutput: If output = False, the residual load curves after discharging are returned as a DataFrame. The DataFrame consists of one column for the relative storage size 1 as well as for all supplied relatively reduced storage sizes. The residual load curves in year 1 and year 2 are stored in row 0 and row 1, respectively. If output = True, the summed grid load, the summed positive & negative residual load, the share of renewable generation without storage, and the realized share of renewable generation with the storage size in the base year and for all provided storage sizes are printed for year 1 and year 2 using print().\n\n\nwithout efficiencywith Efficiency\n\n\n\n# Calculate share of renewable energy (RE)\n## Input: data = pd.Series(data, dtype='float'), grid_load = -1, new_storage_capacitys = [0.9, 0.8, 0.7, 0.6, 0.5], output = False\n## Processing: Call function calculate_annual_storage(data) to determine storage size and annual storage profile for Year 1 and Year 2\n## Processing: From the annual storage profile, determine the discharged electricity, subtract it from residual load --&gt; new residual load curve after discharge\n## Processing: If grid_load = pd.Series(grid_load, dtype='float') is provided, determine share of renewable energy based on residual load after discharge\n## Processing: Repeat calculations for smaller storage sizes, default = [0.9, 0.8, 0.7, 0.6, 0.5]\n## Output: output = False: Return DataFrame of residual load curves after discharge. Column 0 = storage size 1, subsequent columns = new storage sizes. Row 0 = residual load Year 1, Row 1 = residual load Year 2\n## Output: output = True: Print total grid load, positive/negative residual load, RE share without storage, and realized RE share for base year storage size and new_storage_capacitys for Year 1 and Year 2\n\ndef calculate_re_share(data, grid_load=-1, new_storage_capacitys=[0.9, 0.8, 0.7, 0.6, 0.5], output=False):\n\n    # Determine annual profile for base year\n    result = calculate_annual_storage(data, storage_capacity=-1, output=False)\n    base_storage_capacity = result[0]\n    annual_storage_year1 = result[1]\n    annual_storage_year2 = result[2]\n    \n    # Prepend zero to Year 1 profile, use last value of Year 1 for Year 2\n    annual_storage_year1 = pd.concat([pd.Series([0]), annual_storage_year1])\n    annual_storage_year2 = pd.concat([annual_storage_year1[-1:], annual_storage_year2])\n\n    # Calculate discharged electricity, drop first NaN\n    discharged_year1 = annual_storage_year1.diff().clip(upper=0)[1:].reset_index(drop=True)\n    discharged_year2 = annual_storage_year2.diff().clip(upper=0)[1:].reset_index(drop=True)\n\n    # Calculate residual load after discharge (discharged values are negative)\n    residual_load_year1 = data + discharged_year1\n    residual_load_year2 = data + discharged_year2\n\n    # Store residual load in DataFrame\n    residual_after_discharge = pd.DataFrame({'Storage size 1': [list(residual_load_year1), list(residual_load_year2)]})\n\n    if isinstance(grid_load, int):  # RE share cannot be calculated\n        if output:\n            print(\"Grid load was not provided. RE share cannot be calculated.\")\n        output = False\n    else:  # Calculate RE share\n        # RE share = 1 - sum of positive residual load / total grid load\n        ## Year 1\n        re_share_year1 = 1 - (residual_load_year1.clip(lower=0).sum() / grid_load.sum())\n        ## Year 2\n        re_share_year2 = 1 - (residual_load_year2.clip(lower=0).sum() / grid_load.sum())\n\n        # Store RE share in DataFrame\n        re_share_df = pd.DataFrame({\n            'Relative storage size': pd.concat([pd.Series([1]), pd.Series(new_storage_capacitys)], ignore_index=True),\n            'RE share Year1': pd.Series([re_share_year1]),\n            'RE share Year2': pd.Series([re_share_year2])\n        })\n\n    # Calculate discharged electricity and RE share for alternative storage sizes\n    count = 1\n    for i in range(len(new_storage_capacitys)):\n\n        new_storage = base_storage_capacity * new_storage_capacitys[i]\n        result = calculate_annual_storage(data, storage_capacity=new_storage, output=False)\n        annual_storage_year1 = result[1]\n        annual_storage_year2 = result[2]\n\n        # Prepend zero to Year 1 profile, use last value of Year 1 for Year 2\n        annual_storage_year1 = pd.concat([pd.Series([0]), annual_storage_year1])\n        annual_storage_year2 = pd.concat([annual_storage_year1[-1:], annual_storage_year2])\n\n        # Calculate discharged electricity\n        discharged_year1 = annual_storage_year1.diff().clip(upper=0)[1:].reset_index(drop=True)\n        discharged_year2 = annual_storage_year2.diff().clip(upper=0)[1:].reset_index(drop=True)\n\n        # Residual load after discharge\n        residual_load_year1 = data + discharged_year1\n        residual_load_year2 = data + discharged_year2\n\n        # Add column to residual_after_discharge DataFrame\n        residual_after_discharge['Storage size ' + str(new_storage)] = [list(residual_load_year1), list(residual_load_year2)]\n\n        # Calculate RE share\n        if not isinstance(grid_load, int):\n            re_share_year1 = 1 - (residual_load_year1.clip(lower=0).sum() / grid_load.sum())\n            re_share_year2 = 1 - (residual_load_year2.clip(lower=0).sum() / grid_load.sum())\n            re_share_df.loc[count, 'RE share Year1'] = re_share_year1\n            re_share_df.loc[count, 'RE share Year2'] = re_share_year2\n\n        count += 1\n\n    if output:  # Print RE share\n        print(f\"Total grid load: {grid_load.sum():,.2f}\\nTotal positive residual load: {data.clip(lower=0).sum():,.2f}\\tTotal negative residual load: {data.clip(upper=0).sum():,.2f}\\nStorage size 1: {base_storage_capacity:,.2f}\\tRE share without storage: {1 - (data.clip(lower=0).sum() / grid_load.sum()) if len(grid_load) &gt; 1 else '--':,.2f}\\n\")\n        print(re_share_df)\n    else:  # Return residual load curves\n        return residual_after_discharge\n\ncalculate_re_share(residual_load, grid_load=consumption['Gesamt (Netzlast) [MWh]'], new_storage_capacitys=[0.9, 0.8, 0.7, 0.6, 0.5], output=True)\n\nTotal grid load: 458,271,100.75\nTotal positive residual load: 207,842,228.25    Total negative residual load: -1,002,976.00\nStorage size 1: 119,667.00  RE share without storage: 0.55\n\n   Relative storage size  RE share Year1  RE share Year2\n0                    1.0            0.55            0.55\n1                    0.9            0.55            0.55\n2                    0.8            0.55            0.55\n3                    0.7            0.55            0.55\n4                    0.6            0.55            0.55\n5                    0.5            0.55            0.55\n\n\n\n\n\n# Calculate renewable energy share\n## Input: data = pd.Series(data, dtype='float'), grid_load = -1, charge_efficiency = 1, discharge_efficiency = 1, new_storage_capacitys = [0.9, 0.8, 0.7, 0.6, 0.5], output = False\n## Processing: Call the function calculate_annual_storage(data) to determine storage size and annual profile of storage in year 1 and year 2\n## Processing: Determine the discharged electricity in the annual storage profile, subtract it from the residual load --&gt; new residual load curve after discharge\n## Processing: If grid_load = pd.Series(grid_load, dtype='float') is provided, determine the renewable energy share based on the residual load curve after discharge\n## Processing: Repeat calculations for smaller sized storages, default = [0.9, 0.8, 0.7, 0.6, 0.5]\n## Output: output = False: Return a DataFrame of residual load curve(s) after discharge. Column 0 corresponds to storage size = 1, subsequent columns correspond to new storage sizes. Row 0 contains residual load curve for year 1, row 1 for year 2\n## Output: output = True: Print sum of grid load, positive/negative residual load, renewable energy share without storage, and realized renewable energy share for base year storage size and new_storage_capacitys for year 1 and year 2\n\ndef calculate_renewable_share(data, grid_load=-1, charge_efficiency=1, discharge_efficiency=1, new_storage_capacitys=[0.9, 0.8, 0.7, 0.6, 0.5], output=False):\n\n    # Determine annual profile for base year\n    result = calculate_annual_storage(data, storage_capacity=-1, charge_efficiency=charge_efficiency, discharge_efficiency=discharge_efficiency, output=False)\n    base_storage_capacity = result[0]\n    storage_profile_year1 = result[1]\n    storage_profile_year2 = result[2]\n    \n    # Prepend zero to year 1, year 2 starts with last value of year 1\n    storage_profile_year1 = pd.concat([pd.Series([0]), storage_profile_year1])\n    storage_profile_year2 = pd.concat([storage_profile_year1[-1:], storage_profile_year2])\n\n    # Discharged electricity profile, first value is NaN and omitted\n    discharge_year1 = storage_profile_year1.diff().clip(upper=0)[1:].reset_index(drop=True)\n    discharge_year2 = storage_profile_year2.diff().clip(upper=0)[1:].reset_index(drop=True)\n\n    # Calculate residual load after discharge\n    residual_load_year1 = data + discharge_year1\n    residual_load_year2 = data + discharge_year2\n\n    # Store residual load in DataFrame\n    residual_load_after_discharge = pd.DataFrame({'Storage size 1': [list(residual_load_year1), list(residual_load_year2)]})\n\n    if type(grid_load) is int:  # Renewable share cannot be calculated\n        if output:\n            print(\"Grid load not provided. Renewable energy share cannot be calculated.\")\n        output = False\n    \n    else:  # Calculate renewable share\n    \n        # Renewable share = 1 - sum of positive residual load / sum of grid load\n        ## Year 1\n        renewable_share_year1 = 1 - (residual_load_year1.clip(lower=0).sum() / grid_load.sum())\n\n        ## Year 2\n        renewable_share_year2 = 1 - (residual_load_year2.clip(lower=0).sum() / grid_load.sum())\n\n        # Store renewable share in DataFrame\n        renewable_share_df = pd.DataFrame({'relative_storage_capacity': pd.concat([pd.Series([1]), pd.Series(new_storage_capacitys)], ignore_index=True), 'Renewable share Year1': pd.Series([renewable_share_year1]), 'Renewable share Year2': pd.Series([renewable_share_year2])})\n\n    # Calculate discharged electricity and renewable share for alternative storage sizes\n    count = 1\n\n    for i in range(len(new_storage_capacitys)):\n\n        new_storage_capacity = base_storage_capacity * new_storage_capacitys[i]\n        \n        result = calculate_annual_storage(data, storage_capacity=new_storage_capacity, charge_efficiency=charge_efficiency, discharge_efficiency=discharge_efficiency, output=False)\n        storage_profile_year1 = result[1]\n        storage_profile_year2 = result[2]\n\n        # Prepend zero to year 1, year 2 starts with last value of year 1\n        storage_profile_year1 = pd.concat([pd.Series([0]), storage_profile_year1])\n        storage_profile_year2 = pd.concat([storage_profile_year1[-1:], storage_profile_year2])\n\n        # Discharged electricity profile\n        discharge_year1 = storage_profile_year1.diff().clip(upper=0)[1:].reset_index(drop=True)\n        discharge_year2 = storage_profile_year2.diff().clip(upper=0)[1:].reset_index(drop=True)\n\n        # Calculate residual load after discharge\n        residual_load_year1 = data + discharge_year1\n        residual_load_year2 = data + discharge_year2\n\n        # Add column to residual load DataFrame\n        residual_load_after_discharge['Storage size ' + str(new_storage_capacity)] = [list(residual_load_year1), list(residual_load_year2)]\n\n        # Calculate renewable share\n        if type(grid_load) is not int:\n            renewable_share_year1 = 1 - (residual_load_year1.clip(lower=0).sum() / grid_load.sum())\n            renewable_share_year2 = 1 - (residual_load_year2.clip(lower=0).sum() / grid_load.sum())\n\n            renewable_share_df.loc[count, 'Renewable share Year1'] = renewable_share_year1\n            renewable_share_df.loc[count, 'Renewable share Year2'] = renewable_share_year2\n        \n        count += 1\n                              \n    if output:  # Print renewable share\n\n        print(f\"Total grid load: {grid_load.sum():,.2f}\\nSum of positive residual load: {data.clip(lower=0).sum():,.2f}\\tSum of negative residual load: {data.clip(upper=0).sum():,.2f}\\nBase storage size: {base_storage_capacity:,.2f}\\tRenewable share without storage: {1 - (data.clip(lower=0).sum() / grid_load.sum()) if len(grid_load) &gt; 1 else '--':,.2f}\\n\")\n        print(renewable_share_df)\n    \n    else:  # Return residual load curves\n        return residual_load_after_discharge\n\ncalculate_renewable_share(residual_load, grid_load=consumption['Gesamt (Netzlast) [MWh]'], charge_efficiency=0.9, discharge_efficiency=0.9, new_storage_capacitys=[0.9, 0.8, 0.7, 0.6, 0.5], output=True)\n\nTotal grid load: 458,271,100.75\nSum of positive residual load: 207,842,228.25   Sum of negative residual load: -1,002,976.00\nBase storage size: 102,674.54   Renewable share without storage: 0.55\n\n   relative_storage_capacity  Renewable share Year1  Renewable share Year2\n0                        1.0                   0.55                   0.55\n1                        0.9                   0.55                   0.55\n2                        0.8                   0.55                   0.55\n3                        0.7                   0.55                   0.55\n4                        0.6                   0.55                   0.55\n5                        0.5                   0.55                   0.55\n\n\n\n\n\nFor the year 2023, integrating an electricity storage system into the grid to (partially) cover residual load from renewable surplus production would result in only a negligible increase in the share of renewable energy in the electricity mix. This is because the renewable surpluses to be stored amount to 1,002,976 MWh, or around 1 TWh, which is significantly smaller than the positive residual load to be covered of 207,842,228 MWh, or around 208 TWh. The renewable surplus production that can be shifted by the electricity storage corresponds to less than half a percent of the residual load to be covered.\nHowever, as the share of renewable generation increases, storing surplus electricity will become increasingly relevant. The required size of electricity storage systems can be estimated using the developed functions for the renewable energy expansion pathway.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Energy Data Analysis</span>"
    ]
  },
  {
    "objectID": "skript/energiedatenanalyse.html#task-final-data-analysis",
    "href": "skript/energiedatenanalyse.html#task-final-data-analysis",
    "title": "1  Energy Data Analysis",
    "section": "7.5 Task: Final Data Analysis",
    "text": "7.5 Task: Final Data Analysis\nCalculate the share of renewable electricity generation for the years 2030 and 2035 according to the expansion pathway specified by the federal government (see Code-Block 7.1).\n\nWhat is the maximum storage capacity required?\nWhat share of renewable electricity generation is achieved if the storage is sized at half, one-tenth, or one-hundredth of the maximum capacity?\nUse the projected electricity demand for the years 2030 and 2035 as the grid load (see note below).\nFor the efficiency, existing pumped-storage power plants can be used as a reference. The overall efficiency was calculated at 79.10 percent. This efficiency approximately corresponds to a breakdown of storage input efficiency = 0.9 and storage output efficiency = 0.88.\n\n\n\n\n\n\n\nWarnungElectricity Consumption Projections\n\n\n\nFuture electricity consumption is unlikely to match that of 2023. Projections estimate electricity consumption of 658 TWh (Kemmler, Wünsch, and Burret 2021, p. 4) for 2030 and 670.4 TWh in 2035 (Scenario B according to Nahmmacher et al. 2021, p. 54). The increase in electricity consumption compared to 2023 can be easily calculated:\n\nload_factor_2030_MWh = (658 * 1000 * 1000) / consumption[\"Gesamt (Netzlast) [MWh]\"].sum()\nload_factor_2035_MWh = (670.4 * 1000 * 1000) / consumption[\"Gesamt (Netzlast) [MWh]\"].sum()\n\nprint(f\"Increase in electricity consumption in 2030 compared to 2023 Factor: {load_factor_2030_MWh:,.2f}\\n\"\n      f\"Increase in electricity consumption in 2035 compared to 2023 Factor: {load_factor_2035_MWh:,.2f}\")\n\nIncrease in electricity consumption in 2030 compared to 2023 Factor: 1.44\nIncrease in electricity consumption in 2035 compared to 2023 Factor: 1.46\n\n\nKemmler, Andreas, Aurel Wünsch, and Heiko Burret. 2021. “Development of Gross Electricity Consumption until 2030. Short Study.” https://www.bmwk.de/Redaktion/DE/Downloads/E/prognos-bruttostromverbrauch-2018-2030.pdf?__blob=publicationFile&v=2\nNahmmacher, Paul, Christian Paris, Martin Ruge, Sebastian Spieker, Thomas Anderski, Sebastian Bohlen, Robin Kaiser, Caroline Podewski, Jürgen Apfelbeck, Timo Kahl, Fabian Lukas, Sven Schäfer, Paul-Steven Ganer, Max Muller, and Daniel Stützle. 2021. “Scenario Framework for the Electricity Grid Development Plan 2035, Version 2021. Draft by the Transmission System Operators.” https://www.netzausbau.de/SharedDocs/Downloads/DE/Bedarfsermittlung/2035/SR/Szenariorahmen_2035_Entwurf.pdf?__blob=publicationFile\n\n\n \n\n\n\n\n\n\nTipp 7.2: Sample Solution: Closed Data Analysis Exercise\n\n\n\n\n\n\nComplete Sample SolutionReference 2030Reference 2035\n\n\n\n\nimport pandas as pd\n\n# Set number of decimal places\npd.set_option(\"display.precision\", 2)\n\n# Load datasets\n# !\n# For your own use, adjust the file path to the correct location of the downloaded .csv files.\n# !\n\ninstalled_capacity_ms = pd.read_csv(\"01-daten/Installierte_Erzeugungsleistung_202301010000_202401010000_Jahr.csv\", \\\nsep = \";\", thousands = \".\", decimal = \",\", parse_dates = [0, 1], date_format = \"%d.%m.%Y\")\n\ngeneration_ms = pd.read_csv(\"01-daten/Realisierte_Erzeugung_202301010000_202401010000_Viertelstunde.csv\", \\\nsep = \";\", thousands = \".\", decimal = \",\", parse_dates = [0, 1], date_format = \"%d.%m.%Y %H:%M\")\n\nconsumption_ms = pd.read_csv(\"01-daten/Realisierter_Stromverbrauch_202301010000_202401010000_Viertelstunde.csv\", \\\nsep = \";\", thousands = \".\", decimal = \",\", parse_dates = [0, 1], date_format = \"%d.%m.%Y %H:%M\")\n\n# Remove the string \" Originalauflösungen\" from column names\ngeneration_ms.columns = generation_ms.columns.str.replace(pat = \" Originalauflösungen\", repl = \"\")\ninstalled_capacity_ms.columns = installed_capacity_ms.columns.str.replace(pat = \" Originalauflösungen\", repl = \"\")\nconsumption_ms.columns = consumption_ms.columns.str.replace(pat = \" Originalauflösungen\", repl = \"\")\n\n# Aggregate renewable generation into a list\nrenewables_ms = ['Biomasse [MWh]', 'Wasserkraft [MWh]', 'Wind Offshore [MWh]', 'Wind Onshore [MWh]', 'Photovoltaik [MWh]', 'Sonstige Erneuerbare [MWh]']\n\npumped_storage_capacity_MWh_ms = 37.4 * 1000\n\n# Projected generation and electricity consumption for 2030 & 2035:\nprint(f\"Onshore Wind 2030:\\t{( windonshore_growth_factor_2030_ms := 115 / (installed_capacity_ms['Wind Onshore [MW]'].sum() / 1000) ):,.2f}\\n\"\n      f\"Offshore Wind 2030:\\t{( windoffshore_growth_factor_2030_ms := 30 / (installed_capacity_ms['Wind Offshore [MW]'].sum() / 1000) ):,.2f}\\n\"\n      f\"Solar 2030:\\t\\t\\t{( solar_growth_factor_2030_ms := 215 / (installed_capacity_ms['Photovoltaik [MW]'].sum() / 1000) ):,.2f}\\n\"\n      f\"Biomass 2030:\\t\\t{8.4 / (installed_capacity_ms['Biomasse [MW]'].sum() / 1000):,.2f}\")\n\nprint(f\"\\n\\nOnshore Wind 2035:\\t{( windonshore_growth_factor_2035_ms := 157 / (installed_capacity_ms['Wind Onshore [MW]'].sum() / 1000) ):,.2f}\\n\"\n      f\"Offshore Wind 2035:\\t{( windoffshore_growth_factor_2035_ms := 40 / (installed_capacity_ms['Wind Offshore [MW]'].sum() / 1000) ):,.2f}\\n\"\n      f\"Solar 2035:\\t\\t\\t{( solar_growth_factor_2035_ms := 309 / (installed_capacity_ms['Photovoltaik [MW]'].sum() / 1000) ):,.2f}\\n\"\n      f\"Biomass 2035:\\t\\t{8.4 / (installed_capacity_ms['Biomasse [MW]'].sum() / 1000):,.2f}\")\n\nload_factor_2030_MWh_ms = (658 * 1000 * 1000) / consumption_ms[\"Gesamt (Netzlast) [MWh]\"].sum()\nload_factor_2035_MWh_ms = (670.4 * 1000 * 1000) / consumption_ms[\"Gesamt (Netzlast) [MWh]\"].sum()\n\nprint(f\"\\nIncrease in electricity consumption 2030 vs 2023 factor: {load_factor_2030_MWh_ms:,.2f}\\n\"\n      f\"Increase in electricity consumption 2035 vs 2023 factor: {load_factor_2035_MWh_ms:,.2f}\")\n\n# Define residual load\nresidual_load_ms = pd.DataFrame()\nresidual_load_ms[\"Netzlast [MWh]\"] = consumption_ms[\"Gesamt (Netzlast) [MWh]\"].copy() \nresidual_load_ms[\"Erneuerbare [MWh]\"] = generation_ms[renewables_ms].sum(axis = \"columns\").copy()\nresidual_load_ms[\"Restlast [MWh]\"] = residual_load_ms[\"Netzlast [MWh]\"] - residual_load_ms[\"Erneuerbare [MWh]\"]\nresidual_load_ms = residual_load_ms[\"Restlast [MWh]\"]\n\ngeneration_2030_ms = generation_ms.copy()\ngeneration_2035_ms = generation_ms.copy()\n\ngeneration_2030_ms[\"Wind Onshore [MWh]\"] = generation_2030_ms[\"Wind Onshore [MWh]\"] * windonshore_growth_factor_2030_ms\ngeneration_2030_ms[\"Wind Offshore [MWh]\"] = generation_2030_ms[\"Wind Offshore [MWh]\"] * windoffshore_growth_factor_2030_ms\ngeneration_2030_ms[\"Photovoltaik [MWh]\"] = generation_2030_ms[\"Photovoltaik [MWh]\"] * solar_growth_factor_2030_ms\n# Biomass does not need to change (factor ~1)\ngeneration_2035_ms[\"Wind Onshore [MWh]\"] = generation_2035_ms[\"Wind Onshore [MWh]\"] * windonshore_growth_factor_2035_ms\ngeneration_2035_ms[\"Wind Offshore [MWh]\"] = generation_2035_ms[\"Wind Offshore [MWh]\"] * windoffshore_growth_factor_2035_ms\ngeneration_2035_ms[\"Photovoltaik [MWh]\"] = generation_2035_ms[\"Photovoltaik [MWh]\"] * solar_growth_factor_2035_ms\n\nconsumption_2030_ms = consumption_ms.copy()\nconsumption_2030_ms[\"Gesamt (Netzlast) [MWh]\"] = consumption_2030_ms[\"Gesamt (Netzlast) [MWh]\"] * load_factor_2030_MWh_ms\nconsumption_2035_ms = consumption_ms.copy()\nconsumption_2035_ms[\"Gesamt (Netzlast) [MWh]\"] = consumption_2035_ms[\"Gesamt (Netzlast) [MWh]\"] * load_factor_2035_MWh_ms\n\nresidual_load_2030_ms = pd.DataFrame()\nresidual_load_2030_ms[\"Netzlast [MWh]\"] = consumption_2030_ms[\"Gesamt (Netzlast) [MWh]\"].copy() \nresidual_load_2030_ms[\"Erneuerbare [MWh]\"] = generation_2030_ms[renewables_ms].sum(axis = \"columns\").copy()\nresidual_load_2030_ms[\"Restlast [MWh]\"] = residual_load_2030_ms[\"Netzlast [MWh]\"] - residual_load_2030_ms[\"Erneuerbare [MWh]\"]\nresidual_load_2030_ms = residual_load_2030_ms[\"Restlast [MWh]\"]\n\nresidual_load_2035_ms = pd.DataFrame()\nresidual_load_2035_ms[\"Netzlast [MWh]\"] = consumption_2035_ms[\"Gesamt (Netzlast) [MWh]\"].copy() \nresidual_load_2035_ms[\"Erneuerbare [MWh]\"] = generation_2035_ms[renewables_ms].sum(axis = \"columns\").copy()\nresidual_load_2035_ms[\"Restlast [MWh]\"] = residual_load_2035_ms[\"Netzlast [MWh]\"] - residual_load_2035_ms[\"Erneuerbare [MWh]\"]\nresidual_load_2035_ms = residual_load_2035_ms[\"Restlast [MWh]\"]\n\nprint(\"\\n2030\\n======================\\n\")\nstorage_2030_ms = calculate_storage_capacity(residual_load_2030_ms, charge_efficiency = 0.9, discharge_efficiency = 0.88, output = False)\nprint(f\"Required storage capacity in 2030: {storage_2030_ms:,.1f} MWh\")\n\nrenewable_share_2030_ms = calculate_renewable_share(residual_load_2030_ms, grid_load = consumption_2030_ms['Gesamt (Netzlast) [MWh]'],\n                                     charge_efficiency = 0.9, discharge_efficiency = 0.88, new_storage_capacitys = [0.5, 0.1, 0.01], output = True)\n\nprint(\"\\n2035\\n======================\\n\")\nstorage_2035_ms = calculate_storage_capacity(residual_load_2035_ms, charge_efficiency = 0.9, discharge_efficiency = 0.88, output = False)\nprint(f\"Required storage capacity in 2035: {storage_2035_ms:,.1f} MWh\")\n\nrenewable_share_2035_ms = calculate_renewable_share(residual_load_2035_ms, grid_load = consumption_2035_ms['Gesamt (Netzlast) [MWh]'],\n                                     charge_efficiency = 0.9, discharge_efficiency = 0.88, new_storage_capacitys = [0.5, 0.1, 0.01], output = True)\n\nOnshore Wind 2030:  2.00\nOffshore Wind 2030: 3.69\nSolar 2030:         3.41\nBiomass 2030:       0.99\n\n\nOnshore Wind 2035:  2.73\nOffshore Wind 2035: 4.92\nSolar 2035:         4.90\nBiomass 2035:       0.99\n\nIncrease in electricity consumption 2030 vs 2023 factor: 1.44\nIncrease in electricity consumption 2035 vs 2023 factor: 1.46\n\n2030\n======================\n\nRequired storage capacity in 2030: 6,170,038.0 MWh\nTotal grid load: 658,000,000.00\nSum of positive residual load: 175,897,072.30   Sum of negative residual load: -85,250,478.82\nBase storage size: 6,170,038.04 Renewable share without storage: 0.73\n\n   relative_storage_capacity  Renewable share Year1  Renewable share Year2\n0                       1.00                   0.83                   0.84\n1                       0.50                   0.83                   0.83\n2                       0.10                   0.81                   0.81\n3                       0.01                   0.75                   0.75\n\n2035\n======================\n\nRequired storage capacity in 2035: 23,829,823.9 MWh\nTotal grid load: 670,400,000.00\nSum of positive residual load: 125,949,558.61   Sum of negative residual load: -221,510,407.41\nBase storage size: 23,829,823.85    Renewable share without storage: 0.81\n\n   relative_storage_capacity  Renewable share Year1  Renewable share Year2\n0                       1.00                   0.98                   1.00\n1                       0.50                   0.97                   0.97\n2                       0.10                   0.94                   0.94\n3                       0.01                   0.87                   0.87\n\n\nSample solution by Marc Sönnecken. For compatibility with this script, the file paths and object names have been adjusted. The definitions of the functions used have been omitted (identical to those shown in the script). The code has been extended so that the output includes some additional blank lines and markers for the year 2030 and the year 2035.\n\n\n\n\nmy_storage_capacitys = [0.9, 0.8, 0.7, 0.6, 0.5, 0.4, 0.3, 0.2, 0.1, 0.08, 0.06, 0.04, 0.02, 0.01]\nmy_charge_efficiency = 0.9\nmy_discharge_efficiency = 0.88\n\n# Generate 2030 dataset\n## windonshore_growth_factor_2030\n## windoffshore_growth_factor_2030\n## solar_growth_factor_2030\n\ngeneration_2030 = generation.copy()\ngeneration_2030['Wind Onshore [MWh]'] *= windonshore_growth_factor_2030\ngeneration_2030['Wind Offshore [MWh]'] *= windoffshore_growth_factor_2030\ngeneration_2030['Photovoltaik [MWh]'] *= solar_growth_factor_2030\n\nrenewables_2030 = pd.Series()\nrenewables = ['Biomasse [MWh]', 'Wasserkraft [MWh]', 'Wind Offshore [MWh]', 'Wind Onshore [MWh]', 'Photovoltaik [MWh]',\n'Sonstige Erneuerbare [MWh]']\nrenewables_2030 = generation_2030[renewables].sum(axis=\"columns\").copy()\n\ngrid_load_2023 = pd.Series()\ngrid_load_2023 = consumption[\"Gesamt (Netzlast) [MWh]\"].copy()\ngrid_load_2030 = grid_load_2023 * load_factor_2030_MWh\n\nresidual_load_2030 = pd.Series()\nresidual_load_2030 = grid_load_2030 - renewables_2030\n\n# Output\nstorage_2030 = calculate_storage_capacity(residual_load_2030, charge_efficiency=my_charge_efficiency, discharge_efficiency=my_discharge_efficiency, output=False)\nprint(f\"Maximum required storage capacity 2030: {storage_2030:,.1f} MWh\\nThis corresponds to {storage_2030 / pumped_storage_capacity_MWh:,.1f} pumped storage equivalents.\")\nprint(\"\\n\")\n\ncalculate_curtailment_effect(residual_load_2030, charge_efficiency=my_charge_efficiency, discharge_efficiency=my_discharge_efficiency, new_storage_capacitys=my_storage_capacitys, output=True)\nprint(\"\\n\")\n\ncalculate_renewable_share(residual_load_2030, grid_load=grid_load_2030, charge_efficiency=my_charge_efficiency, discharge_efficiency=my_discharge_efficiency, new_storage_capacitys=my_storage_capacitys, output=True)\n\nMaximum required storage capacity 2030: 6,170,038.0 MWh\nThis corresponds to 165.0 pumped storage equivalents.\n\n\n    Storage size  Storage Year1  Cycles Year1  Storage Year2  Cycles Year2\n0       6.17e+06       7.67e+07         11.99       7.67e+07         12.44\n1       5.55e+06       7.67e+07         13.32       7.61e+07         13.71\n2       4.94e+06       7.61e+07         14.92       7.55e+07         15.29\n3       4.32e+06       7.55e+07         16.98       7.49e+07         17.34\n4       3.70e+06       7.49e+07         19.73       7.43e+07         20.06\n5       3.09e+06       7.43e+07         23.58       7.36e+07         23.87\n6       2.47e+06       7.35e+07         29.29       7.29e+07         29.53\n7       1.85e+06       7.17e+07         38.23       7.12e+07         38.45\n8       1.23e+06       6.79e+07         54.56       6.76e+07         54.76\n9       6.17e+05       5.90e+07         95.05       5.86e+07         94.96\n10      4.94e+05       5.59e+07        112.65       5.55e+07        112.41\n11      3.70e+05       5.13e+07        137.99       5.09e+07        137.51\n12      2.47e+05       4.28e+07        172.79       4.25e+07        172.29\n13      1.23e+05       2.66e+07        215.36       2.65e+07        214.86\n14      6.17e+04       1.51e+07        243.93       1.50e+07        243.43\n\n\n    Relative storage size  Curtailed storage Year1  Curtailed storage Year2\n0                    0.90                 1.49e-08                 6.17e+05\n1                    0.80                 5.95e+05                 1.23e+06\n2                    0.70                 1.21e+06                 1.85e+06\n3                    0.60                 1.83e+06                 2.47e+06\n4                    0.50                 2.45e+06                 3.09e+06\n5                    0.40                 3.21e+06                 3.85e+06\n6                    0.30                 5.04e+06                 5.55e+06\n7                    0.20                 8.78e+06                 9.15e+06\n8                    0.10                 1.78e+07                 1.81e+07\n9                    0.08                 2.09e+07                 2.12e+07\n10                   0.06                 2.55e+07                 2.58e+07\n11                   0.04                 3.40e+07                 3.42e+07\n12                   0.02                 5.01e+07                 5.02e+07\n13                   0.01                 6.16e+07                 6.17e+07\n\n\nTotal grid load: 658,000,000.00\nSum of positive residual load: 175,897,072.30   Sum of negative residual load: -85,250,478.82\nBase storage size: 6,170,038.04 Renewable share without storage: 0.73\n\n    relative_storage_capacity  Renewable share Year1  Renewable share Year2\n0                        1.00                   0.83                   0.84\n1                        0.90                   0.83                   0.83\n2                        0.80                   0.83                   0.83\n3                        0.70                   0.83                   0.83\n4                        0.60                   0.83                   0.83\n5                        0.50                   0.83                   0.83\n6                        0.40                   0.83                   0.83\n7                        0.30                   0.83                   0.83\n8                        0.20                   0.82                   0.82\n9                        0.10                   0.81                   0.81\n10                       0.08                   0.81                   0.81\n11                       0.06                   0.80                   0.80\n12                       0.04                   0.79                   0.79\n13                       0.02                   0.77                   0.77\n14                       0.01                   0.75                   0.75\n\n\n\n\n\n# Generate 2035 dataset\n# ## windonshore_growth_factor_2035\n# ## windoffshore_growth_factor_2035\n# ## solar_growth_factor_2035\n\ngeneration_2035 = generation.copy()\ngeneration_2035['Wind Onshore [MWh]'] *= windonshore_growth_factor_2035\ngeneration_2035['Wind Offshore [MWh]'] *= windoffshore_growth_factor_2035\ngeneration_2035['Photovoltaik [MWh]'] *= solar_growth_factor_2035\n\nrenewables_2035 = pd.Series()\nrenewables = ['Biomasse [MWh]', 'Wasserkraft [MWh]', 'Wind Offshore [MWh]', 'Wind Onshore [MWh]', 'Photovoltaik [MWh]',\n'Sonstige Erneuerbare [MWh]']\nrenewables_2035 = generation_2035[renewables].sum(axis=\"columns\").copy()\n\ngrid_load_2023 = pd.Series()\ngrid_load_2023 = consumption[\"Gesamt (Netzlast) [MWh]\"].copy()\ngrid_load_2035 = grid_load_2023 * load_factor_2035_MWh\n\nresidual_load_2035 = pd.Series()\nresidual_load_2035 = grid_load_2035 - renewables_2035\n\n# Output\nstorage_2035 = calculate_storage_capacity(residual_load_2035, charge_efficiency=my_charge_efficiency, discharge_efficiency=my_discharge_efficiency, output=False)\nprint(f\"Maximum required storage capacity 2035: {storage_2035:,.1f} MWh\\nThis corresponds to {storage_2035 / pumped_storage_capacity_MWh:,.1f} pumped storage equivalents.\")\nprint(\"\\n\")\n\ncalculate_curtailment_effect(residual_load_2035, charge_efficiency=my_charge_efficiency, discharge_efficiency=my_discharge_efficiency, new_storage_capacitys=my_storage_capacitys, output=True)\nprint(\"\\n\")\n\ncalculate_renewable_share(residual_load_2035, grid_load=grid_load_2035, charge_efficiency=my_charge_efficiency, discharge_efficiency=my_discharge_efficiency, new_storage_capacitys=my_storage_capacitys, output=True)\n\nMaximum required storage capacity 2035: 23,829,823.9 MWh\nThis corresponds to 637.2 pumped storage equivalents.\n\n\n    Storage size  Storage Year1  Cycles Year1  Storage Year2  Cycles Year2\n0       2.38e+07       1.49e+08          5.84       1.43e+08          6.01\n1       2.14e+07       1.47e+08          6.44       1.41e+08          6.56\n2       1.91e+07       1.44e+08          7.17       1.38e+08          7.24\n3       1.67e+07       1.42e+08          8.05       1.33e+08          7.99\n4       1.43e+07       1.39e+08          9.19       1.29e+08          8.99\n5       1.19e+07       1.34e+08         10.73       1.24e+08         10.39\n6       9.53e+06       1.29e+08         12.99       1.19e+08         12.49\n7       7.15e+06       1.21e+08         16.49       1.14e+08         15.99\n8       4.77e+06       1.13e+08         23.15       1.08e+08         22.65\n9       2.38e+06       1.01e+08         41.76       9.83e+07         41.26\n10      1.91e+06       9.72e+07         50.47       9.53e+07         49.97\n11      1.43e+06       9.18e+07         63.73       9.04e+07         63.23\n12      9.53e+05       8.23e+07         85.86       8.14e+07         85.36\n13      4.77e+05       6.58e+07        137.54       6.53e+07        137.04\n14      2.38e+05       4.29e+07        179.40       4.26e+07        178.90\n\n\n    Relative storage size  Curtailed storage Year1  Curtailed storage Year2\n0                    0.90                 2.38e+06                 2.38e+06\n1                    0.80                 4.77e+06                 5.01e+06\n2                    0.70                 7.15e+06                 9.77e+06\n3                    0.60                 1.07e+07                 1.45e+07\n4                    0.50                 1.55e+07                 1.93e+07\n5                    0.40                 2.07e+07                 2.41e+07\n6                    0.30                 2.78e+07                 2.88e+07\n7                    0.20                 3.65e+07                 3.52e+07\n8                    0.10                 4.86e+07                 4.48e+07\n9                    0.08                 5.21e+07                 4.79e+07\n10                   0.06                 5.74e+07                 5.27e+07\n11                   0.04                 6.69e+07                 6.18e+07\n12                   0.02                 8.35e+07                 7.78e+07\n13                   0.01                 1.06e+08                 1.00e+08\n\n\nTotal grid load: 670,400,000.00\nSum of positive residual load: 125,949,558.61   Sum of negative residual load: -221,510,407.41\nBase storage size: 23,829,823.85    Renewable share without storage: 0.81\n\n    relative_storage_capacity  Renewable share Year1  Renewable share Year2\n0                        1.00                   0.98                   1.00\n1                        0.90                   0.98                   1.00\n2                        0.80                   0.98                   0.99\n3                        0.70                   0.98                   0.99\n4                        0.60                   0.98                   0.98\n5                        0.50                   0.97                   0.97\n6                        0.40                   0.97                   0.97\n7                        0.30                   0.96                   0.96\n8                        0.20                   0.95                   0.95\n9                        0.10                   0.94                   0.94\n10                       0.08                   0.94                   0.94\n11                       0.06                   0.93                   0.93\n12                       0.04                   0.92                   0.92\n13                       0.02                   0.90                   0.90\n14                       0.01                   0.87                   0.87\n\n\n\n\n\n\n\n\n\nGraphical Representation of Selected Storage Configurations\nA graphical representation of the annual storage profile can be generated for different configurations relative to the maximum required storage capacity (C\\(_{max}\\)) using the function calculate_annual_storage(output = False). First, a residual load curve for the years 2030 and 2035 is calculated from the projected grid load and the planned renewable expansion.\n\n# Calculate residual load 2030\n## windonshore_growth_factor_2030\n## windoffshore_growth_factor_2030\n## solar_growth_factor_2030\n\ngeneration_2030 = generation.copy()\ngeneration_2030['Wind Onshore [MWh]'] *= windonshore_growth_factor_2030\ngeneration_2030['Wind Offshore [MWh]'] *= windoffshore_growth_factor_2030\ngeneration_2030['Photovoltaik [MWh]'] *= solar_growth_factor_2030\n\nrenewables_2030 = pd.Series()\nrenewables = ['Biomasse [MWh]', 'Wasserkraft [MWh]', 'Wind Offshore [MWh]', 'Wind Onshore [MWh]', 'Photovoltaik [MWh]', 'Sonstige Erneuerbare [MWh]']\nrenewables_2030 = generation_2030[renewables].sum(axis=\"columns\").copy()\n\ngrid_load_2023 = pd.Series()\ngrid_load_2023 = consumption[\"Gesamt (Netzlast) [MWh]\"].copy()\ngrid_load_2030 = grid_load_2023 * load_factor_2030_MWh\n\nresidual_load_2030 = pd.Series()\nresidual_load_2030 = grid_load_2030 - renewables_2030\n\n# Calculate residual load 2035\n## windonshore_growth_factor_2035\n## windoffshore_growth_factor_2035\n## solar_growth_factor_2035\n\ngeneration_2035 = generation.copy()\ngeneration_2035['Wind Onshore [MWh]'] *= windonshore_growth_factor_2035\ngeneration_2035['Wind Offshore [MWh]'] *= windoffshore_growth_factor_2035\ngeneration_2035['Photovoltaik [MWh]'] *= solar_growth_factor_2035\n\nrenewables_2035 = pd.Series()\nrenewables = ['Biomasse [MWh]', 'Wasserkraft [MWh]', 'Wind Offshore [MWh]', 'Wind Onshore [MWh]', 'Photovoltaik [MWh]', 'Sonstige Erneuerbare [MWh]']\nrenewables_2035 = generation_2035[renewables].sum(axis=\"columns\").copy()\n\ngrid_load_2023 = pd.Series()\ngrid_load_2023 = consumption[\"Gesamt (Netzlast) [MWh]\"].copy()\ngrid_load_2035 = grid_load_2023 * load_factor_2035_MWh\n\nresidual_load_2035 = pd.Series()\nresidual_load_2035 = grid_load_2035 - renewables_2035\n\n \nBased on the calculated residual load curves, 80%, 20%, and 4% configurations of the maximum required storage capacity are calculated and visualized.\n\n80% 203080% 203520% 203020% 20354% 20304% 2035Code Example\n\n\n\n\n\n\n\n\n\n\n\nNumber of cycles year 1: 14.92\nNumber of cycles year 2: 15.29\nTotal grid load: 658,000,000.00\nSum of positive residual load: 175,897,072.30   Sum of negative residual load: -85,250,478.82\nBase storage size: 6,170,038.04 Renewable share without storage: 0.73\n\n   relative_storage_capacity  Renewable share Year1  Renewable share Year2\n0                        1.0                   0.83                   0.84\n1                        0.8                   0.83                   0.83\n\nThe storage size is 4,936,030.4 MWh\nThis corresponds to 132.0 pumped storage equivalents.\n\n\n\n\n\n\n\n\n\n\n\n\n\nNumber of cycles year 1: 7.17\nNumber of cycles year 2: 7.24\nTotal grid load: 670,400,000.00\nSum of positive residual load: 125,949,558.61   Sum of negative residual load: -221,510,407.41\nBase storage size: 23,829,823.85    Renewable share without storage: 0.81\n\n   relative_storage_capacity  Renewable share Year1  Renewable share Year2\n0                        1.0                   0.98                   1.00\n1                        0.8                   0.98                   0.99\n\nThe storage size is 19,063,859.1 MWh\nThis corresponds to 509.7 pumped storage equivalents.\n\n\n\n\n\n\n\n\n\n\n\n\n\nNumber of cycles year 1: 54.56\nNumber of cycles year 2: 54.76\nTotal grid load: 658,000,000.00\nSum of positive residual load: 175,897,072.30   Sum of negative residual load: -85,250,478.82\nBase storage size: 6,170,038.04 Renewable share without storage: 0.73\n\n   relative_storage_capacity  Renewable share Year1  Renewable share Year2\n0                        1.0                   0.83                   0.84\n1                        0.2                   0.82                   0.82\n\nThe storage size is 1,234,007.6 MWh\nThis corresponds to 33.0 pumped storage equivalents.\n\n\n\n\n\n\n\n\n\n\n\n\n\nNumber of cycles year 1: 23.15\nNumber of cycles year 2: 22.65\nTotal grid load: 670,400,000.00\nSum of positive residual load: 125,949,558.61   Sum of negative residual load: -221,510,407.41\nBase storage size: 23,829,823.85    Renewable share without storage: 0.81\n\n   relative_storage_capacity  Renewable share Year1  Renewable share Year2\n0                        1.0                   0.98                   1.00\n1                        0.2                   0.95                   0.95\n\nThe storage size is 4,765,964.8 MWh\nThis corresponds to 127.4 pumped storage equivalents.\n\n\n\n\n\n\n\n\n\n\n\n\n\nNumber of cycles year 1: 172.79\nNumber of cycles year 2: 172.29\nTotal grid load: 658,000,000.00\nSum of positive residual load: 175,897,072.30   Sum of negative residual load: -85,250,478.82\nBase storage size: 6,170,038.04 Renewable share without storage: 0.73\n\n   relative_storage_capacity  Renewable share Year1  Renewable share Year2\n0                       1.00                   0.83                   0.84\n1                       0.04                   0.79                   0.79\n\nThe storage size is 246,801.5 MWh\nThis corresponds to 6.6 pumped storage equivalents.\n\n\n\n\n\n\n\n\n\n\n\n\n\nNumber of cycles year 1: 85.86\nNumber of cycles year 2: 85.36\nTotal grid load: 670,400,000.00\nSum of positive residual load: 125,949,558.61   Sum of negative residual load: -221,510,407.41\nBase storage size: 23,829,823.85    Renewable share without storage: 0.81\n\n   relative_storage_capacity  Renewable share Year1  Renewable share Year2\n0                       1.00                   0.98                   1.00\n1                       0.04                   0.92                   0.92\n\nThe storage size is 953,193.0 MWh\nThis corresponds to 25.5 pumped storage equivalents.\n\n\n\n\n\n# Generate data\n## Determine storage size and calculate 80 percent\nstorage_capacity_2030_80 = calculate_storage_capacity(residual_load_2030, charge_efficiency=0.9, discharge_efficiency=0.88, output=False) * 0.8\n\n## Determine annual storage profile\nstorage_2030_80_eff_90_88 = calculate_annual_storage(residual_load_2030, storage_capacity=storage_capacity_2030_80, charge_efficiency=0.9, discharge_efficiency=0.88, output=False)\n\nannual_storage_year1 = storage_2030_80_eff_90_88[1]\nannual_storage_year2 = storage_2030_80_eff_90_88[2]\n\n# Generate x-ticks\nmonths_index = generation[~generation[\"Datum von\"].dt.month.duplicated()].index\nmonth_names = generation[\"Datum von\"].iloc[months_index].dt.strftime(\"%B\") \n\n# Create plot with three subplots\nfig, (ax1, ax2, ax3) = plt.subplots(3, 1, figsize=(7.5, 6), height_ratios=[2, 1, 1], sharex=True, layout='tight')\nplt.suptitle('Residual Load 2030 and Annual Profile of a Storage with\\n C$_{max}$ = 0.8, η$_{charge}$ = 0.9 and η$_{discharge}$ = 0.88')\nplt.xticks(months_index, month_names, rotation=45)\nplt.minorticks_off()\nplt.setp([ax1, ax2, ax3], xlim=(residual_load.index.min() - len(residual_load.index)/100, residual_load.index.max() * 1.01))\nplt.setp([ax2, ax3], ylim=(0, max(max(annual_storage_year1), max(annual_storage_year2)) * 1.2))\n\n## Plot residual load\nax1.plot(residual_load_2030, label=\"Residual Load\")\nax1.grid()\nax1.set_ylabel('MWh')\nax1.legend()\n\n## Plot annual_storage_year1\nax2.plot(annual_storage_year1, color='black', linestyle='-', label='Storage Year 1')\nax2.grid()\nax2.set_ylabel('MWh')\nax2.legend()\n\n## Plot annual_storage_year2\nax3.plot(annual_storage_year2, color='black', linestyle='-', label='Storage Year 2')\nax3.tick_params(axis='x', rotation=45)\nax3.set_ylabel('MWh')\nax3.grid()\nax3.legend()\n\nplt.show()\n\n# Calculate number of cycles; passing tuple of efficiencies not needed\ncalculate_cycles(storage_2030_80_eff_90_88, output=True)\n\n# Calculate renewable share\ncalculate_renewable_share(residual_load_2030, grid_load=grid_load_2030, charge_efficiency=0.9, discharge_efficiency=0.88, new_storage_capacitys=[0.8], output=True)\n\n# Print storage size\nprint(f\"\\nThe storage size is {storage_2030_80_eff_90_88[0]:,.1f} MWh\\n\"\n      f\"This corresponds to {storage_2030_80_eff_90_88[0] / pumped_storage_capacity_MWh:,.1f} pumped storage equivalents.\")\n\n\n\n\nWith an 80-percent sizing of the storage, the system appears oversized. In 2030, the storage can hardly utilize its full capacity over the course of the year. The storage rarely reaches state-of-charge levels around 50 percent. Only during the turn of the year is the maximum capacity used. In contrast, in 2035 the storage is mostly fully charged, and only minimal charging and discharging occurs. In particular, in 2035 the storage undergoes only a few full cycles.\nThe storage capacity required in 2030 of 4,936 GWh corresponds to 132 times the existing pumped-storage plants or 99 annual productions of the Tesla Gigafactory Berlin-Brandenburg in its first expansion stage with 50 GWh/year (Wikipedia). The storage capacity required in 2035 of 19,064 GWh corresponds to 510 times the existing pumped-storage plants or 381 annual productions of the Tesla Gigafactory Berlin-Brandenburg.\nNote: The reference to the Tesla Gigafactory Berlin-Brandenburg is only for context. The Grünheide factory currently does not produce battery cells. Plans for additional battery factories in Germany have recently been canceled.\nWith a 20-percent sizing, more full cycles and more extensive partial cycles are achieved. Nevertheless, in 2035 consistently high state-of-charge levels are observed from April to the end of August. In 2030, 1,234 GWh of storage capacity would be needed, and in 2035, 4,766 GWh. This corresponds to 33 and 127 times the existing pumped-storage capacity or 25 and 95 annual productions of the Tesla Gigafactory Berlin-Brandenburg in the first expansion stage.\nThe 4-percent sizing shows a constant up-and-down pattern. At this scale, operating a storage economically could be feasible. This would require 247 GWh in 2030 and 953 GWh in 2035. 247 GWh corresponds to 6.6 times the existing pumped-storage capacity or 5 annual productions of the Tesla Gigafactory Berlin-Brandenburg in the first expansion stage. 953 GWh corresponds to 25.5 pumped-storage equivalents and 19 annual productions of the Tesla Gigafactory Berlin-Brandenburg.\nIn all scenarios, it is notable that the number of cycles in year 1 and year 2 is almost identical. The difference of half a cycle arises because the storage starts the first year empty. Depending on the scenario, the storage is then first fully charged over the course of the year (80% sizing), within a few weeks (20% sizing), or almost immediately (4% sizing).\nIt is evident that the 80-20 rule (Pareto principle) applies to storage sizing: 20 percent of the effort achieves 80 percent of the result. If in 2035 the share of renewable energy without storage is 81 percent, then 19 percent must be covered by storage (or otherwise). To achieve 100 percent demand coverage from electricity storage, 23.8 TWh of storage capacity would be required. A storage 20 percent of this size achieves a total renewable share of 95 percent. A storage 20 percent of that size achieves a total share of 92 percent.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Energy Data Analysis</span>"
    ]
  },
  {
    "objectID": "skript/energiedatenanalyse.html#bonus-estimating-the-required-peak-power-of-backup-power-plants",
    "href": "skript/energiedatenanalyse.html#bonus-estimating-the-required-peak-power-of-backup-power-plants",
    "title": "1  Energy Data Analysis",
    "section": "7.6 Bonus: Estimating the Required Peak Power of Backup Power Plants",
    "text": "7.6 Bonus: Estimating the Required Peak Power of Backup Power Plants\nFrom the calculation of different storage sizes, it became clear that even relatively small storage systems can lead to a high share of renewable energy in the electricity mix. Nevertheless, smaller storage capacities mean that at certain times, the grid load must be met by backup load-following power plants. In this section, the required generation capacity of these backup plants is estimated. The maximum positive residual load after discharging is multiplied by four, since the dataset is based on 15-minute intervals.\n\npeak_power_2030 = calculate_renewable_share(residual_load_2030, grid_load = grid_load_2030, charge_efficiency = 0.9, discharge_efficiency = 0.88, new_storage_capacitys = [0.2, 0.04], output = False)\npeak_power_2035 = calculate_renewable_share(residual_load_2035, grid_load = grid_load_2035, charge_efficiency = 0.9, discharge_efficiency = 0.88, new_storage_capacitys = [0.2, 0.04], output = False)\n\n## Examine data structure\n## Column 0 contains storage size = 1, the following columns contain the new storage sizes. Row 0 contains the residual load curve for year 1, row 1 for year 2\n# print(peak_power_2030.shape)\n# print(peak_power_2030.head())\n\n# Row 1 contains the annual profile in year 2\n# Column 0 contains the baseline scenario with storage size = 1\nprint(f\"\\nPeak power 2030 for Cmax = 0.20: {max(peak_power_2030.iloc[1, 1]) * 4 / 1000:.2f} GW\\n\"\n      f\"Peak power 2030 for Cmax = 0.04: {max(peak_power_2030.iloc[1, 2]) * 4 / 1000:.2f} GW\\n\"\n      f\"Peak power 2035 for Cmax = 0.20: {max(peak_power_2035.iloc[1, 1]) * 4 / 1000:.2f} GW\\n\"\n      f\"Peak power 2035 for Cmax = 0.04: {max(peak_power_2035.iloc[1 , 2]) * 4 / 1000:.2f} GW\")\n\n\nPeak power 2030 for Cmax = 0.20: 87.64 GW\nPeak power 2030 for Cmax = 0.04: 87.64 GW\nPeak power 2035 for Cmax = 0.20: 87.53 GW\nPeak power 2035 for Cmax = 0.04: 87.53 GW",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Energy Data Analysis</span>"
    ]
  },
  {
    "objectID": "skript/energiedatenanalyse.html#skills-quiz",
    "href": "skript/energiedatenanalyse.html#skills-quiz",
    "title": "1  Energy Data Analysis",
    "section": "9.1 Skills Quiz",
    "text": "9.1 Skills Quiz\n\n\nWhat is the full command to convert the following string into a datetime object using the Python module Pandas?\n\n\ndate_str = '2008-Oct-29'\ndate_pd = pd.to_datetime(date_str, format = \" ... \")\n\n \n\nWhich method can be used to concatenate the data series a, b, and c?\n\npandas.concat(a, b, c)\npandas.append(a, b, c)\npandas.concatenate[a, b, c]\npandas.concat([a, b, c])\n\n\n \n\nWhat is the purpose of descriptive data analysis?\n\nIdentify errors in the dataset\nLoad required modules\nPrepare for exploratory and inferential data analysis\nGain an overview of the dataset\n\n\n \n\nWhich statements are true?\n\nExploratory data analysis is an iterative process to explore a dataset and generate new questions based on the insights gained.\nThe methods of exploratory data analysis are strictly predefined.\nExploratory data analysis is purely numeric.\nExploratory data analysis prepares for inferential data analysis.\n\n\n \n\nThe sizing of an electricity storage system depends on:\n\nThe cyclic nature of charging\nThe ratio of storable excess generation to the load to be served by the storage\nThe capping of generation peaks\nThe efficiency of the storage system\n\n\n\n\n\n\n\n\nTipp 9.1: Solutions\n\n\n\n\n\nSolution 1: date_pd = pd.to_datetime(date_str, format = “%Y-%b-%d”)\nSolution 2: pandas.concat([a, b, c])\nSolution 3: a, c, d\nSolution 4: a, d\nSolution 5: a, b, c, d",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Energy Data Analysis</span>"
    ]
  },
  {
    "objectID": "skript/energiedatenanalyse.html#exercises",
    "href": "skript/energiedatenanalyse.html#exercises",
    "title": "1  Energy Data Analysis",
    "section": "9.2 Exercises",
    "text": "9.2 Exercises\nWithin the framework of inferential data analysis, it was found that by capping generation peaks in a power system dominated by renewable surplus production, the required electricity storage can be dimensioned orders of magnitude smaller. However, a few percent of the annual electricity demand would remain that cannot be covered by ongoing renewable generation or storage. One option would be to operate biomass power plants in load-following mode.\nCalculate the required storage size (charging efficiency = 0.9, discharging efficiency = 0.88) if the share of renewable energy in 2035 is to be 100 percent and biomass power plants are operated in load-following mode. Assume that biomass plants store gas production during periods when the electricity demand is fully met by other renewable sources and generate electricity when there is positive residual load. The production profile of biogas plants corresponds to the generation curve of 2023.\n\nHow large would the gas storage need to be (in MWh of electrical energy)?\nWhat is the maximum required electricity generation capacity of the biomass plants, both absolute and relative to the installed 2023 capacity?\nHow large does the required electricity storage need to be if biomass power plants are operated in load-following mode?\n\n\n\n\n\nFraunhofer Institut für Solare Energiesysteme ISE. o. J. „Öffentliche Nettostromerzeugung in Deutschland“. Zugegriffen 3. Juni 2024. https://energy-charts.info/charts/energy/chart.htm?l=de&c=DE&chartColumnSorting=default&year=-1&interval=year&legendItems=lz1zb&source=public.\n\n\nHeimerl, Stephan, und Beate Kohler. 2017. „Aktueller Stand der Pumpspeicherkraftwerke in Deutschland“. WasserWirtschaft. 2017. https://www.fwt.fichtner.de/userfiles/fileadmin-fwt/Publikationen/WaWi_2017_10_Heimerl_Kohler_PSKW.pdf.\n\n\nWickham, Hadley, Mine Çetinkaya-Rundel, und Garrett Grolemund. 2023. „R for data science: Import, tidy, transform, visualize, and model data“. Beijing; Boston; Farnham; Sebastopol; Tokyo: O’Reilly. 2023. https://r4ds.hadley.nz/.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Energy Data Analysis</span>"
    ]
  }
]