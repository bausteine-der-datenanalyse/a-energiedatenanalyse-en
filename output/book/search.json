[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Anwendungsbaustein Energiedatenanalyse",
    "section": "",
    "text": "Preamble\n\n\n\n\n\n\n\n\n\n\nBausteine Computergestützter Datenanalyse von Lukas Arnold, Simone Arnold, Florian Bagemihl, Matthias Baitsch, Marc Fehr, Franca Hollmann, Maik Poetzsch und Sebastian Seipel. Anwendungsbaustein Energiedatenanalyse von Maik Poetzsch ist lizensiert unter CC BY 4.0. Das Werk ist abrufbar auf GitHub. Ausgenommen von der Lizenz sind alle Logos und anders gekennzeichneten Inhalte. 2025\n\n\n\nZitiervorschlag\nArnold, Lukas, Simone Arnold, Florian Bagemihl, Matthias Baitsch, Marc Fehr, Franca Hollmann, Maik Poetzsch, und Sebastian Seipel. 2025. „Bausteine Computergestützter Datenanalyse. Anwendungsbaustein Energiedatenanalyse“. https://github.com/bausteine-der-datenanalyse/a-energiedatenanalyse.\nBibTeX-Vorlage\n@misc{BCD-a-ernergiedatenanalyse-2025,\n title={Bausteine Computergestützter Datenanalyse. Anwendungsbaustein Energiedatenanalyse},\n author={Arnold, Lukas and Arnold, Simone and Bagemihl, Florian and Baitsch, Matthias and Fehr, Marc and Hollmann, Franca and Poetzsch, Maik and Seipel, Sebastian},\n year={2025},\n url={https://github.com/bausteine-der-datenanalyse/a-energiedatenanalyse}} \n\n\n\nVoraussetzungen\nDie Bearbeitungszeit dieses Bausteins beträgt circa 10 Stunden. Für die Bearbeitung dieses Bausteins werden folgende Bausteine vorausgesetzt und die genannten Bibliotheken verwendet:\n\nWerkzeugbaustein Python\n\nModul random\nModul Pandas\nModul NumPy\nModul matplotlib.pyplot\n\nMethodenbaustein Einlesen strukturierter Datensätze\n\nIm Baustein werden Strommarktdaten für das Jahr 2023 verwendet. Daten für Deutschland werden von der Bundesnetzagentur bereitgestellt und sind unter https://www.smard.de/ abrufbar. Daten für Österreich werden von der Austrian Power Grid AG bereitgestellt und sind unter https://markttransparenz.apg.at/ abrufbar.\n\n\nLernziele\nIn diesen Baustein lernen Sie Methoden und Werkzeuge für die Energiedatenanalyse kennen. Dabei bilden Prinzipien und Verfahren zur Auslegung eines Stromspeichers einen inhaltlichen Schwerpunkt.\nDie behandelten Methoden umfassen:\n\nbeschreibende Datenanlyse\nexplorative Datenanalyse\nschließende Datenanalyse\nergänzender Einsatz kennzahlenbasierter und visualisierender Methoden\n\nZu den vorgestellten Werkzeugen gehören:\n\nVisualisierung einer sortierten Jahresdauerlinie\nBerechnung der Residual- und Restlast\nGrenzstromanalyse\nGrößenbestimmung eines Stromspeichers unter Berücksichtigung des Wirkungsgrads und der Kappung von Erzeugungsspitzen, Berechnung der realisierten Zyklenzahl, Jahresgänge und des Potenzials auf dem Ausbaupfad erneuerbarer Energien\n\nSchlagworte: vergleichende Analyse von Strommarktdaten, Daten visualisieren, Speicherauslegung",
    "crumbs": [
      "Preamble"
    ]
  },
  {
    "objectID": "skript/energiedatenanalyse.html",
    "href": "skript/energiedatenanalyse.html",
    "title": "1  Energiedatenanalyse",
    "section": "",
    "text": "2 Hintergrund\nElektrischer Strom wird in Kraftwerken erzeugt und über das Stromnetz zu den Stromverbrauchern transportiert. Stromerzeugung und -verbrauch müssen dabei immer ausgeglichen sein. Der Anteil wetterabhängiger erneuerbarer Einspeisung steigt, Strom kann bislang aber nicht (kostengünstig) großtechnisch gespeichert werden. 2023 speisten die Pumpspeicherkraftwerke in Deutschland bei einer Kapazität von 37,4 GWh (Heimerl und Kohler 2017, 77) 11,1 TWh Strom ein, was 2,4 Prozent des deutschen Stromverbrauchs von 458,3 TWh entsprach (Fraunhofer Institut für Solare Energiesysteme ISE o. J.). Die Kraftwerkseinsatzplanung und Speicherauslegung auf Basis von Erzeugungs- und Verbrauchsdaten ist deshalb ein relevantes Anwendungsfeld für die Datenanalyse.\nDie Bundesnetzagentur veröffentlicht auf https://www.smard.de/ unter anderem Daten zu Stromerzeugung, -verbrauch und Großhandelspreisen. (Hinweis: Kraftwerksdaten liegen für Erzeugungseinheiten mit einer installierten Erzeugungsleistung von mindestens 100 MW vor.)",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Energiedatenanalyse</span>"
    ]
  },
  {
    "objectID": "skript/energiedatenanalyse.html#visualisieren",
    "href": "skript/energiedatenanalyse.html#visualisieren",
    "title": "1  Energiedatenanalyse",
    "section": "5.1 Visualisieren",
    "text": "5.1 Visualisieren\nDie Auswertung der beschreibenden Statistik für 12 verschiedene Erzeugungsformen erfordert jedoch Konzentration. Komplexe Informationen sollten deshalb grafisch aufbereitet werden.\nEinen schnellen Überblick beispielsweise über die Verteilung der Gesamterzeugungsleistung nach Erzeugungsart verschafft ein Kreis- bzw. Ringdiagramm. Allerdings hat dieser Diagrammtyp den Nachteil, dass dieser mit steigender Anzahl von Merkmalsausprägungen (bzw. hier darzustellenden Merkmalen) schnell unübersichtlich wird und Winkel kaum exakt abgelesen werden können.\nIm folgenden, mit der Methode pd.DataFrame.plot.pie() erstellten Ringdiagramm wurde deshalb zum einen die automatische Annotation der Anteilswerte mit dem entsprechenden Formatierungsstring autopct='%1.1f%%' aktiviert. Zum anderen wurde die Reihenfolge der Spalten im DataFrame getauscht, da sich die Prozentangaben und Beschriftungen kleiner Kreissegmente andernfalls überlappen. Außerdem wurde für die Beschriftung der Segmente die Zeichkette ” [MWh]” aus den Spaltennamen gekürzt. Dies verbessert zwar die Lesbarkeit des Diagramms. Das ist aber nicht der Grund, weshalb die Zeichenkette entfernt wurde.\nWas denken Sie, was der Grund dafür ist?\n\n\n\n\n\n\nTipp 5.1: Lösung Kreisdiagramm\n\n\n\n\n\nDas Kreis- bzw. Ringdiagramm stellt Anteilswerte dar und ist deshalb einheitenlos.\n\n\n\nDie Details der Ploterstellung können Sie dem zweiten Reiter entnehmen.\n\nPlotten mit PandasCode für Pandas\n\n\n\n\n\n\n\nAnteil an der Stromerzeugung\n\n\n\n\n\n\n\n# plot the pie first try - Sonstige Erneuerbare [MWh] overlaps with Kernenergie [MWh] and Pumpspeicher [MWh]\n# erzeugung.sum(numeric_only = True).plot.pie(colormap = \"Blues\", startangle = 90, rotatelabels = True, explode = explosion)\n\n# rearrange columns, remove \" [MWh]\"\nplotting_data = erzeugung.copy()\ncolumn_to_move = plotting_data.pop(\"Kernenergie [MWh]\")\nplotting_data.insert(4, \"Kernenergie [MWh]\", column_to_move)\n\ncolumn_to_move = plotting_data.pop(\"Pumpspeicher [MWh]\")\nplotting_data.insert(10, \"Pumpspeicher [MWh]\", column_to_move)\n\nplotting_data.columns = plotting_data.columns.str.replace(pat = \" [MWh]\", repl = \"\")\n\n# plot the pie\nax = plotting_data.sum(numeric_only = True).plot.pie(colormap = \"Blues\", startangle = 90, rotatelabels = False, autopct='%1.1f%%', pctdistance = 0.6, textprops = dict(size = 7, color = 'black'), wedgeprops = {\"linewidth\": 0.5, \"edgecolor\": \"white\"})\n\n# make a donut\ncircle = plt.Circle((0, 0), radius = 0.7, color = \"white\")\nax.add_patch(circle)\n\nplt.show()\n\n\n\n\n\nDaten aggregieren\nAufgrund der zahlreichen Merkmale erschließt sich aus der deskriptiven und visuellen Beschreibung der Erzeugungsleistung nicht unbedingt ein prägnanter Befund. Eine Möglichkeit, um Daten besser zu verstehen, besteht darin, ähnliche Merkmale zusammenzufassen. Im Folgenden werden erneuerbare und konventionelle (mit fossilen Brennstoffen betriebene) Erzeugungsarten für die Darstellung der Anteilswerte in einem Ringdiagramm zusammengefasst. Beide Gruppen werden zusätzlich in einem Balkendiagramm dargestellt. Für die Darstellung wird das Modul matplotlib.pyplot verwendet. Die Details der Ploterstellung können Sie dem zweiten Reiter entnehmen.\n\nPlotten mit matplotlibCode für matplotlib\n\n\n\n\n\n\n\nAbsolute Stromerzeugung und relative Anteile nach Erzeugungstyp\n\n\n\n\n\n\n\n# Erneuerbare und Konventionelle bestimmen, jeweils summieren\n\n## Erneuerbare\nplotting_data = erzeugung.copy()\nplotting_data.drop(columns = ['Datum von', 'Datum bis', 'Biomasse [MWh]', 'Wasserkraft [MWh]', 'Wind Offshore [MWh]',\n'Wind Onshore [MWh]', 'Photovoltaik [MWh]',\n'Sonstige Erneuerbare [MWh]'], inplace = True) # Datumsspalten entfernen, inplace = False liefert eine Kopie und tut deshalb ohne Objektzuweisung 'nichts'\nerneuerbare = ['Biomasse [MWh]', 'Wasserkraft [MWh]', 'Wind Offshore [MWh]', 'Wind Onshore [MWh]', 'Photovoltaik [MWh]',\n'Sonstige Erneuerbare [MWh]']\nplotting_data[\"Erneuerbare\"] = erzeugung[erneuerbare].sum(axis = 'columns')\n\n## Konventionelle\nplotting_data.drop(columns = ['Braunkohle [MWh]',  'Steinkohle [MWh]', 'Erdgas [MWh]', 'Sonstige Konventionelle [MWh]'], inplace = True)\nkonventionelle = ['Braunkohle [MWh]',  'Steinkohle [MWh]', 'Erdgas [MWh]', 'Sonstige Konventionelle [MWh]']\nplotting_data[\"Konventionelle\"] = erzeugung[konventionelle].sum(axis = 'columns')\n\n# rearrange columns, remove \" [MWh]\"\nplotting_data = plotting_data[['Erneuerbare', 'Pumpspeicher [MWh]', 'Konventionelle', 'Kernenergie [MWh]']]\nplotting_data.columns = plotting_data.columns.str.replace(pat = \" [MWh]\", repl = \"\")\n\n# zur Kontrolle - axis = columns addiert die Spalten zeilenweise\n## print(erneuerbare)\n## print(erzeugung[erneuerbare].sum(axis = 'columns'))\n## print(plotting_data.columns)\n## print(plotting_data[0:3])\n\n# Grafik mit drei subplots erzeugen\nplt.figure(figsize = (7.5, 7.5))\n\nnrows = 4\nncols = 2\nfont_size = 8\n\n# value for shared x-axis on barplots\nx_lim = erzeugung.sum(numeric_only = True).max() * 1.1\n\n# array of colors\nmy_colors = plt.get_cmap('Blues')(np.linspace(0.2, 1, len(plotting_data.sum())))\n\n# plot the pie, use 4 out of 8 panels = middle 2 rows\nax = plt.subplot(nrows, ncols, (3, 6))\nplt.pie(x = plotting_data.sum(), colors = my_colors, startangle = 350, labels = list(plotting_data.columns), autopct='%1.1f%%', pctdistance = 0.5, textprops = dict(size = font_size + 1), wedgeprops = {\"linewidth\": 0.5, \"edgecolor\": \"white\"})\n\n# make a donut\ncircle = plt.Circle((0, 0), radius = 0.65, color = \"white\")\nax.add_patch(circle)\n\n# top row unstacked barplot \nplt.subplot(nrows, ncols, (1, 2))\nerzeugung[erneuerbare].sum().sort_values(ascending = False).plot.barh(fontsize = font_size, xlim = (0, x_lim), color = my_colors[0], edgecolor = 'darkgrey')\nplt.title(\"Erneuerbare\", fontsize = font_size + 2)\n\n# bottom row unstacked barplot \nplt.subplot(nrows, ncols, (7, 8))\nerzeugung[konventionelle].sum().sort_values(ascending = False).plot.barh(fontsize = font_size, xlim = (0, x_lim), color = my_colors[2], edgecolor = 'darkgrey')\nplt.title(\"Konventionelle\", fontsize = font_size + 2)\n\nplt.tight_layout()\nplt.show()\n\n\n\n\n \nDurch die Aggregation ähnlicher Stromerzeugungsarten wurde das Ringdiagramm auf vier Erzeugungsarten reduziert. Die mit nur geringen Anteilen an der Gesamtstromerzeugung beteiligten Erzeugungsarten Pumpspeicher und Kernenergie treten dadurch gegenüber der Einzeldarstellung aller Erzeugungsarten deutlich hervor. Auf dieser Grundlage kann diskutiert werden, ob die gezeigte Aggregation zweckmäßig ist. So könnte einerseits die Kernenergie den Konventionellen zugeschlagen werden, wenn für diese Gruppe nicht auf das Merkmal einer Erzeugung mit fossilen Brennstoffen, sondern auf das Prinzip thermischer Dampfexpansion abgestellt wird. Andererseits sollte die Erzeugung durch Pumpspeicher kritisch hinterfragt werden. Dieser Aspekt wird im folgenden Abschnitt diskutiert.\n\n\n\n\n\n\nHinweis 5.1: Hinweis\n\n\n\nKomplexe Grafiken, wie die hier gezeigte, sollten im Allgemeinen sparsam eingesetzt werden, da sie schwer zu erfassen und zu interpretieren sind. Die Zweck der Grafik und die wesentlichen Schlussfolgerungen sollten deshalb im Text erläutert werden.\nTipp: Stellen Sie sich vor, Sie würden die Grafik spontan einem:einer Freund:in zeigen, die Ihre Arbeit nicht gelesen hat. Wie würden Sie Ihrer:Ihrem Freund:in die Grafik erklären? Schreiben Sie es in Ihrer Arbeit auf.\n\n\n\n\nErzeugung, Speicherung, Einspeisung\nPumpspeicherkraftwerke sind Energiespeicher, die keine Primärenergie erzeugen, sondern den von anderen Erzeugern produzierten Strom speichern und bei Bedarf wieder ins Netz einspeisen. Welche Erzeuger Strom zum Befüllen der Pumpspeicher lieferten, wird in Kapitel 6 untersucht. Die realisierte Netzeinspeisung von Pumpspeicherkraftwerken entspricht der um die Verluste beim Ein- und Ausspeichern (sowie ggf. Speicherverluste wie Verdunstung, Versickerung) verminderten Energieerzeugung anderer Stromerzeuger. Der Wirkungsgrad der Pumpspeicherkraftwerke kann mit den vorliegenden Daten für das Jahr 2023 berechnet werden.\nWie hoch war der Wirkungsgrad der Pumpspeicherkraftwerke 2023?\n\n\n\n\n\n\nTipp 5.2: Lösung Wirkungsgrad Pumpspeicher\n\n\n\n\n\n\nprint(f\"Summe Erzeugung Pumpspeicher: {erzeugung[\"Pumpspeicher [MWh]\"].sum():,.2f}\\n\"\n      f\"Summe Verbrauch Pumpspeicher: {verbrauch[\"Pumpspeicher [MWh]\"].sum():,.2f}\\n\"\n      f\"{41 * \"=\"}\\n\"\n      f\"Wirkungsgrad in Prozent: \\t\\t\\t{( erzeugung[\"Pumpspeicher [MWh]\"].sum() / verbrauch[\"Pumpspeicher [MWh]\"].sum() ) * 100:,.2f}\")\n\nSumme Erzeugung Pumpspeicher: 11,149,398.50\nSumme Verbrauch Pumpspeicher: 14,095,632.75\n=========================================\nWirkungsgrad in Prozent:            79.10\n\n\n\n\n\nDie tatsächlich realisierte Stromerzeugung ist deshalb die von der Bundesnetzagentur veröffentlichte kumulierte Stromerzeugung der Pumpspeicherkraftwerke zuzüglich der Speicherverluste. Die Bundesnetzagentur führt diesen Wert im Datensatz Stromverbrauch. Im folgenden Programmcode wird der “Walross”-Operator := benutzt, der Objektzuweisungen innerhalb von Anweisungen (hier die Anweisung print()) erlaubt. Dadurch Code knapper gefasst werden (die Lesbarkeit nimmt aber ab). Mit dem Walross-Operator durchgeführte Zuweisungen müssen in runde Klammern eingefasst werden:\n\nprint(f\"Speicherverluste:\\t\\t\\t{ (speicherverluste := ( verbrauch[\"Pumpspeicher [MWh]\"].sum() - erzeugung[\"Pumpspeicher [MWh]\"].sum() ) / (1000 * 1000) ):&gt;6.2f} TWh\\n\"\n      f\"kumulierte Stromerzeugung:\\t{ ( kumulierte_erzeugung := erzeugung.sum(numeric_only = True).sum() // (1000 * 1000) ):,.2f} TWh\\n\"\n      f\"Summe:\\t\\t\\t\\t\\t\\t{speicherverluste + kumulierte_erzeugung:,.2f} TWh\\n\\n\")\n\nSpeicherverluste:             2.95 TWh\nkumulierte Stromerzeugung:  448.00 TWh\nSumme:                      450.95 TWh\n\n\n\n\nDie Differenz zwischen tatsächlich realisierter und von der Bundesnetzagentur veröffentlichter Stromerzeugung beträgt knapp 3 TWh, also weniger als 1 Prozent der Gesamtstromerzeugung. In anderen Ländern ist die korrekte Zuordnung der Daten auch betragsmäßig relevant. In Österreich spielen Pumpspeicherkraftwerke eine bedeutende Rolle im Strommix.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Energiedatenanalyse</span>"
    ]
  },
  {
    "objectID": "skript/energiedatenanalyse.html#sec-aufgabe-beschreibende-Datenanalyse",
    "href": "skript/energiedatenanalyse.html#sec-aufgabe-beschreibende-Datenanalyse",
    "title": "1  Energiedatenanalyse",
    "section": "5.2 Aufgabe beschreibende Datenanalyse",
    "text": "5.2 Aufgabe beschreibende Datenanalyse\n\n\n\n\n \n\n\nBlick vom Schlegeisspeicher von Höhenweg aus. von Klaus Kettner steht unter der Lizenz CC BY-SA 3.0 und ist abrufbar auf Wikimedia. Das Bild wurde zugeschnitten und im Format PNG gespeichert. 2012.\n\n \nWie die Bundesnetzagentur veröffentlicht auch die Austrian Power Grid AG (APG) Strommarktdaten unter https://markttransparenz.apg.at/. Unter dem Link können Erzeugungsdaten für das Jahr 2023 heruntergeladen werden.\nDiesem Skript ist folgende Datei angefügt.\n\n\n\n\n\n\n\n\nDaten\nDateiname\n\n\n\n\nRealisierte Stromerzeugung 2023\nAGPT_2022-12-31T23_00_00Z_2023-12-31T23_00_00Z_15M_de_2024-06-10T09_32_38Z.csv\n\n\n\n\n \nLesen Sie die österreichischen Erzeugungsdaten ein und visualisieren Sie die Anteile der Erzeugungstypen. Was fällt Ihnen im Datensatz auf?\n\n\n\n\n\n\nHinweis 5.2: Markttranzparenzdaten Österreich herunterladen\n\n\n\n\n\nNach der Auswahl des Zeitraums auf Exportieren klicken, dann erscheint die Schaltfläche Download.\n\n\n\n \n\n\n\n\n\n \n\n\nDas Datumsformat der Dateien ist abhängig von der auf der Internetseite eingestellten Sprache (Deutsch/English).\n\n\n\n \n\n\n\n\n\n\nTipp 5.3: Tipp Erzeugungsdaten und Musterlösung\n\n\n\n\n\nDer österreichische Datensatz unterscheidet sich zum einen dadurch, dass die Leistung statt der erzeugten Energie angegeben wird. (Das ist für die Visualisierung der Erzeugungsanteile unerheblich.) Der Datensatz unterscheidet sich aber noch in einer anderen Hinsicht.\nTipp: Wenn Ihnen in der Ausgabe der Methode .describe() nicht alle Spalten angezeigt werden, versuchen Sie, den DataFrame in zwei oder mehr Teilen auszugeben. Beispielsweise:\n\nprint(df.iloc[ :, 0:5].describe(include = np.number))\nprint(df.iloc[ :, 5:10].describe(include = np.number))\nprint(df.iloc[ :, 10:15].describe(include = np.number))\n\n\n\n\n\n\n\nMusterlösung Strommarktdaten Österreich\n\n\n\n\n\n\n\nimport pandas as pd\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# Deklarieren der Anzahl der Nachkommastellen\npd.set_option(\"display.precision\", 2)\n\n# Datensatz wird eingelesen und in der Variable erzeugung0 gespeichert\n\n# !\n# Für die eigene Anwendung muss der Dateipfad an den korrekten Speicherort der runtergeladenen .csv Datei angepasst werden. \n# !\n\nerzeugung0_austria_ms = pd.read_csv(\"01-daten/AGPT_2022-12-31T23_00_00Z_2023-12-31T23_00_00Z_15M_de_2024-06-10T09_32_38Z.csv\", \n                                     sep = \";\", thousands = \".\", decimal = \",\", parse_dates = [0, 1], date_format = \"%d.%m.%Y\")\n\nprint(erzeugung0_austria_ms.head(10))\n\nprint(f\"Der DataFrame erzeugung_austria_ms hat {erzeugung0_austria_ms.shape[0]} Zeilen und {erzeugung0_austria_ms.shape[1]} Spalten.\")\n\n# Eckdaten des Datensatzes werden kurz \"zusammengefasst\"\nprint(erzeugung0_austria_ms.describe(include = [np.number]))\n# Da der Datensatz relativ viele Spalten besitzt, können möglicherweise (je nach Bildschirmauflösung) nicht alle Spalten im Terminal angezeigt werden\n# und die mittleren werden daher mit \"...\" abgekürzt.\n# In dem Fall müssen die Spalten passend unterteilt werden, sodass man sich mit der Methode .describe() auch wirklich alle Spalten anschauen und beschreiben lassen kann:\nprint(erzeugung0_austria_ms.iloc[:, 0:5].describe(include=[np.number]))\nprint(erzeugung0_austria_ms.iloc[:, 5:10].describe(include=[np.number]))\nprint(erzeugung0_austria_ms.iloc[:, 10:15].describe(include=[np.number]))\n\n# Kopie des Datensatzes wird angelegt\nerzeugung_austria_ms_c = erzeugung0_austria_ms\n\n# Spalten mit den Uhrzeitdaten werden gelöscht\nerzeugung_austria_ms_c = erzeugung_austria_ms_c.drop(columns=[\"Zeit von [CET/CEST]\",\"Zeit bis [CET/CEST]\"])\nprint(erzeugung_austria_ms_c.head(5))\n# Die Zeichenkette \"[MW]\" wird aus den Spalten entfernt\nerzeugung_austria_ms_c.columns = erzeugung_austria_ms_c.columns.str.replace(pat=\" [MW]\", repl=\"\")\nprint(erzeugung_austria_ms_c.head(5))\n\n# mögliche Plausibilisierung: die .csv Datei in Excel ansehen. Es sollte auffallen, dass sich in der Spalte der Pumpspeicher sowohl\n# Positiv- als auch Negativwerte befinden. Sieht man auch, wenn man genau auf die beschriebenen Werte der .describe() Methode achtet\n# Nun wird geprüft, ob sich negative Werte in den Erzeugungsleistungen befinden:\ncheck_minus_werte = (erzeugung_austria_ms_c &lt; 0).any().any()\nif check_minus_werte == True:\n    print(\"FEHLER: Es befinden sich negative Werte unter den Erzeugungswerten.\")\n\n# negative Werte in der Spalte \"Pumpspeicher\" werden auf 0 gesetzt\nerzeugung_austria_ms_c[\"Pumpspeicher\"] = erzeugung_austria_ms_c[\"Pumpspeicher\"].clip(lower=0)\n\n# Spalten mit Summe 0 entfernen\n# Ansatz: Jede Spalte wird darauf geprüft, ob die Summe ihrer Werte Null ist. Falls ja, wird diese Spalte mit der .drop Methode aus dem neuen Dataframe gelöscht\n# dadurch verschwinden 3 Spalten mit der Summe Null. Geothermie wird immer noch als 0,0 % angezeigt, da der Wert sehr klein ist (nicht erkennbar bei einer Nachkommastelle)\nspalten_weg = []\nfor i in erzeugung_austria_ms_c.columns:\n    if erzeugung_austria_ms_c[i].sum() == 0:\n        spalten_weg.append(i)\nerzeugung_austria_ms_c = erzeugung_austria_ms_c.drop(columns=spalten_weg)\nprint(erzeugung_austria_ms_c.head(10))\n\n# um die Lesbarkeit der sehr kleinen Teilstücke des Kreisdiagramms zu verbessern, werden die Segmente anders angeordnet.\n# Dafür wird die Reihenfolgeder Spalten im Dataframe umsortiert, sodass das größte Segment auf das kleinste Segment der Liste folgt, und so weiter\nsortierte_spalten = erzeugung_austria_ms_c.sum().sort_values().index\n\nneue_reihenfolge = []\nfor i in range(len(sortierte_spalten) // 2):\n    neue_reihenfolge.append(sortierte_spalten[i])\n    neue_reihenfolge.append(sortierte_spalten[-(i+1)])\n\n# falls eine ungerade Anzahl an Spalten existiert:\nif len(sortierte_spalten) % 2 != 0:\n    neue_reihenfolge.append(sortierte_spalten[len(sortierte_spalten) // 2])\n\nerzeugung_austria_ms_c = erzeugung_austria_ms_c[neue_reihenfolge]\n\nplt.figure(figsize = (7, 7))\nnew_plot = erzeugung_austria_ms_c.sum(numeric_only=True).plot.pie(colormap = \"Blues\", startangle=90, rotatelabels=False, wedgeprops = {\"linewidth\":1, \"edgecolor\":\"white\"}, autopct='%1.1f%%', pctdistance=0.6, textprops=dict(size=7))\n\n# make a donut\ncircle = plt.Circle((0, 0), radius = 0.7, color = \"white\")\nnew_plot.add_patch(circle)\n\nplt.show()\n\n   Zeit von [CET/CEST]  Zeit bis [CET/CEST]  Wind [MW]  Solar [MW]  \\\n0  01.01.2023 00:00:00  01.01.2023 00:15:00     1000.0         0.0   \n1  01.01.2023 00:15:00  01.01.2023 00:30:00      964.0         0.0   \n2  01.01.2023 00:30:00  01.01.2023 00:45:00      956.0         0.0   \n3  01.01.2023 00:45:00  01.01.2023 01:00:00      992.0         0.0   \n4  01.01.2023 01:00:00  01.01.2023 01:15:00      880.0         0.0   \n5  01.01.2023 01:15:00  01.01.2023 01:30:00      888.0         0.0   \n6  01.01.2023 01:30:00  01.01.2023 01:45:00      948.0         0.0   \n7  01.01.2023 01:45:00  01.01.2023 02:00:00      968.0         0.0   \n8  01.01.2023 02:00:00  01.01.2023 02:15:00      956.0         0.0   \n9  01.01.2023 02:15:00  01.01.2023 02:30:00      952.0         0.0   \n\n   Biomasse [MW]  Gas [MW]  Kohle [MW]  Öl [MW]  Geothermie [MW]  \\\n0          240.0      27.6         0.0      0.0             0.07   \n1          240.0      27.6         0.0      0.0             0.07   \n2          240.0      28.0         0.0      0.0             0.07   \n3          240.0      27.6         0.0      0.0             0.07   \n4          240.0      27.6         0.0      0.0             0.07   \n5          240.0      28.4         0.0      0.0             0.07   \n6          240.0      28.8         0.0      0.0             0.07   \n7          240.0      28.0         0.0      0.0             0.07   \n8          240.0      28.8         0.0      0.0             0.07   \n9          240.0      28.4         0.0      0.0             0.07   \n\n   Pumpspeicher [MW]  Lauf- und Schwellwasser [MW]  Speicher [MW]  \\\n0            -1404.8                        2291.6           70.4   \n1            -1532.8                        2283.2           66.8   \n2            -1544.4                        2240.0          100.4   \n3            -1579.6                        2199.6           77.6   \n4            -1590.8                        2234.8           63.2   \n5            -1602.8                        2229.2           73.6   \n6            -1572.0                        2211.2           69.2   \n7            -1579.2                        2194.8           70.8   \n8            -1649.6                        2202.8           75.2   \n9            -1702.0                        2172.4           65.6   \n\n   Sonstige Erneuerbare [MW]  Müll [MW]  Andere [MW]  \n0                        0.0      100.0         22.0  \n1                        0.0      100.0         22.0  \n2                        0.0      100.0         22.0  \n3                        0.0      100.0         22.0  \n4                        0.0      100.0         22.0  \n5                        0.0      100.0         22.0  \n6                        0.0      100.0         22.0  \n7                        0.0      100.0         22.0  \n8                        0.0      100.0         22.0  \n9                        0.0      100.0         22.0  \nDer DataFrame erzeugung_austria_ms hat 35040 Zeilen und 15 Spalten.\n       Wind [MW]  Solar [MW]  Biomasse [MW]  Gas [MW]  Kohle [MW]  Öl [MW]  \\\ncount   35040.00    35040.00       35040.00  35040.00     35040.0  35040.0   \nmean      942.84      268.01         159.94    736.68         0.0      0.0   \nstd       884.56      421.28          64.30    799.65         0.0      0.0   \nmin         4.00        0.00          52.00      0.00         0.0      0.0   \n25%       204.00        0.00         100.00      0.40         0.0      0.0   \n50%       644.00       20.00         156.00    472.00         0.0      0.0   \n75%      1484.00      392.00         216.00   1273.60         0.0      0.0   \nmax      3400.00     2028.00         312.00   3599.60         0.0      0.0   \n\n       Geothermie [MW]  Pumpspeicher [MW]  Lauf- und Schwellwasser [MW]  \\\ncount         3.50e+04           35040.00                      35040.00   \nmean          7.20e-02             283.53                       3477.12   \nstd           1.39e-17            1101.68                       1032.45   \nmin           7.20e-02           -2082.80                       1375.60   \n25%           7.20e-02            -451.20                       2591.60   \n50%           7.20e-02             181.60                       3516.00   \n75%           7.20e-02            1010.40                       4131.20   \nmax           7.20e-02            3160.80                       6290.40   \n\n       Speicher [MW]  Sonstige Erneuerbare [MW]  Müll [MW]  Andere [MW]  \ncount       35040.00                    35040.0    35040.0      35040.0  \nmean          488.40                        0.0      100.0         22.0  \nstd           301.89                        0.0        0.0          0.0  \nmin            16.00                        0.0      100.0         22.0  \n25%           248.00                        0.0      100.0         22.0  \n50%           424.40                        0.0      100.0         22.0  \n75%           686.00                        0.0      100.0         22.0  \nmax          1434.40                        0.0      100.0         22.0  \n       Wind [MW]  Solar [MW]  Biomasse [MW]\ncount   35040.00    35040.00       35040.00\nmean      942.84      268.01         159.94\nstd       884.56      421.28          64.30\nmin         4.00        0.00          52.00\n25%       204.00        0.00         100.00\n50%       644.00       20.00         156.00\n75%      1484.00      392.00         216.00\nmax      3400.00     2028.00         312.00\n       Gas [MW]  Kohle [MW]  Öl [MW]  Geothermie [MW]  Pumpspeicher [MW]\ncount  35040.00     35040.0  35040.0         3.50e+04           35040.00\nmean     736.68         0.0      0.0         7.20e-02             283.53\nstd      799.65         0.0      0.0         1.39e-17            1101.68\nmin        0.00         0.0      0.0         7.20e-02           -2082.80\n25%        0.40         0.0      0.0         7.20e-02            -451.20\n50%      472.00         0.0      0.0         7.20e-02             181.60\n75%     1273.60         0.0      0.0         7.20e-02            1010.40\nmax     3599.60         0.0      0.0         7.20e-02            3160.80\n       Lauf- und Schwellwasser [MW]  Speicher [MW]  Sonstige Erneuerbare [MW]  \\\ncount                      35040.00       35040.00                    35040.0   \nmean                        3477.12         488.40                        0.0   \nstd                         1032.45         301.89                        0.0   \nmin                         1375.60          16.00                        0.0   \n25%                         2591.60         248.00                        0.0   \n50%                         3516.00         424.40                        0.0   \n75%                         4131.20         686.00                        0.0   \nmax                         6290.40        1434.40                        0.0   \n\n       Müll [MW]  Andere [MW]  \ncount    35040.0      35040.0  \nmean       100.0         22.0  \nstd          0.0          0.0  \nmin        100.0         22.0  \n25%        100.0         22.0  \n50%        100.0         22.0  \n75%        100.0         22.0  \nmax        100.0         22.0  \n   Wind [MW]  Solar [MW]  Biomasse [MW]  Gas [MW]  Kohle [MW]  Öl [MW]  \\\n0     1000.0         0.0          240.0      27.6         0.0      0.0   \n1      964.0         0.0          240.0      27.6         0.0      0.0   \n2      956.0         0.0          240.0      28.0         0.0      0.0   \n3      992.0         0.0          240.0      27.6         0.0      0.0   \n4      880.0         0.0          240.0      27.6         0.0      0.0   \n\n   Geothermie [MW]  Pumpspeicher [MW]  Lauf- und Schwellwasser [MW]  \\\n0             0.07            -1404.8                        2291.6   \n1             0.07            -1532.8                        2283.2   \n2             0.07            -1544.4                        2240.0   \n3             0.07            -1579.6                        2199.6   \n4             0.07            -1590.8                        2234.8   \n\n   Speicher [MW]  Sonstige Erneuerbare [MW]  Müll [MW]  Andere [MW]  \n0           70.4                        0.0      100.0         22.0  \n1           66.8                        0.0      100.0         22.0  \n2          100.4                        0.0      100.0         22.0  \n3           77.6                        0.0      100.0         22.0  \n4           63.2                        0.0      100.0         22.0  \n     Wind  Solar  Biomasse   Gas  Kohle   Öl  Geothermie  Pumpspeicher  \\\n0  1000.0    0.0     240.0  27.6    0.0  0.0        0.07       -1404.8   \n1   964.0    0.0     240.0  27.6    0.0  0.0        0.07       -1532.8   \n2   956.0    0.0     240.0  28.0    0.0  0.0        0.07       -1544.4   \n3   992.0    0.0     240.0  27.6    0.0  0.0        0.07       -1579.6   \n4   880.0    0.0     240.0  27.6    0.0  0.0        0.07       -1590.8   \n\n   Lauf- und Schwellwasser  Speicher  Sonstige Erneuerbare   Müll  Andere  \n0                   2291.6      70.4                   0.0  100.0    22.0  \n1                   2283.2      66.8                   0.0  100.0    22.0  \n2                   2240.0     100.4                   0.0  100.0    22.0  \n3                   2199.6      77.6                   0.0  100.0    22.0  \n4                   2234.8      63.2                   0.0  100.0    22.0  \nFEHLER: Es befinden sich negative Werte unter den Erzeugungswerten.\n     Wind  Solar  Biomasse   Gas  Geothermie  Pumpspeicher  \\\n0  1000.0    0.0     240.0  27.6        0.07           0.0   \n1   964.0    0.0     240.0  27.6        0.07           0.0   \n2   956.0    0.0     240.0  28.0        0.07           0.0   \n3   992.0    0.0     240.0  27.6        0.07           0.0   \n4   880.0    0.0     240.0  27.6        0.07           0.0   \n5   888.0    0.0     240.0  28.4        0.07           0.0   \n6   948.0    0.0     240.0  28.8        0.07           0.0   \n7   968.0    0.0     240.0  28.0        0.07           0.0   \n8   956.0    0.0     240.0  28.8        0.07           0.0   \n9   952.0    0.0     240.0  28.4        0.07           0.0   \n\n   Lauf- und Schwellwasser  Speicher   Müll  Andere  \n0                   2291.6      70.4  100.0    22.0  \n1                   2283.2      66.8  100.0    22.0  \n2                   2240.0     100.4  100.0    22.0  \n3                   2199.6      77.6  100.0    22.0  \n4                   2234.8      63.2  100.0    22.0  \n5                   2229.2      73.6  100.0    22.0  \n6                   2211.2      69.2  100.0    22.0  \n7                   2194.8      70.8  100.0    22.0  \n8                   2202.8      75.2  100.0    22.0  \n9                   2172.4      65.6  100.0    22.0  \n\n\n\n\n\nAnteil an der Stromerzeugung in Österreich\n\n\n\n\nMusterlösung von Marc Sönnecken. Für die Kompatibilität mit diesem Skript wurden der Dateipfad und die Objektbezeichnungen angepasst. Für die Barrierefreiheit wurden die Grafikgröße geändert, die Farbpalette geändert, ein weißer Innenkreis ergänzt und die Position der Prozentwerte angepasst.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Energiedatenanalyse</span>"
    ]
  },
  {
    "objectID": "skript/energiedatenanalyse.html#hintergrund-grenzstromanalyse",
    "href": "skript/energiedatenanalyse.html#hintergrund-grenzstromanalyse",
    "title": "1  Energiedatenanalyse",
    "section": "6.1 Hintergrund: Grenzstromanalyse",
    "text": "6.1 Hintergrund: Grenzstromanalyse\nIm vorliegenden Fall wird die explorative Auseinandersetzung mit dem Datensatz von der Frage strukturiert, welche Erzeuger Strom lieferten, um zusätzlich zur Netzlast die Pumpspeicher zu befüllen. Es soll also bestimmt werden, welche Stromerzeuger an den Zeitpunkten, an denen die Pumpspeicher befüllt wurden, in der Lage waren, zusätzliche Leistung bereitzustellen. Dieser zusätzliche Strom kann kurz als Grenzstrom bezeichnet werden.\n\n\n\n\n\n\nDefinition 6.1: Grenzstrom\n\n\n\nGrenzbetrachtungen untersuchen die Bedingungen, die bei der Produktion oder dem Verbrauch einer zusätzlichen Einheit herrschen. Eine Grenzbetrachtung unterscheidet sich dadurch von einer Durchschnittsbetrachtung, die den Effekt einer Mengenänderung auf alle Einheiten untersucht. Der Grenzstrom bezeichnet eine zusätzliche Einheit Strom.\nBeispielsweise bestehe die momentane Stromerzeugung in Höhe von 100 Einheiten aus 60 Einheiten Solarstrom und, weil die solare Produktion nicht ausreicht, zusätzlich aus 40 Einheiten Kohlestrom. In diesem Fall enthält jede Einheit Strom durchschnittlich 0,4 Anteile Kohlestrom. Werden nun weitere 20 Einheiten Strom nachgefragt, so müssen diese durch eine zusätzliche Kohleverstromung bedient werden. In der Durchschnittsbetrachtung beträgt der Strommix nun aus 60 Einheiten Solarstrom und 40 + 20 = 60 Einheiten Kohlestrom. Dadurch verändert sich der durchschnittliche Anteil der Kohle an der Stromproduktion von 0,4 auf 0,5.\nIn der Grenzbetrachtung beträgt der Kohleanteil des zusätzlich verbrauchten Stroms 20 von 20 Einheiten, also 1.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Energiedatenanalyse</span>"
    ]
  },
  {
    "objectID": "skript/energiedatenanalyse.html#hintergrund-einspeisevorrang-erneuerbarer-energien",
    "href": "skript/energiedatenanalyse.html#hintergrund-einspeisevorrang-erneuerbarer-energien",
    "title": "1  Energiedatenanalyse",
    "section": "6.2 Hintergrund: Einspeisevorrang erneuerbarer Energien",
    "text": "6.2 Hintergrund: Einspeisevorrang erneuerbarer Energien\nIn Deutschland gilt seit dem Jahr 2000 das Erneuerbare-Energien-Gesetz, das ursprünglich als Gesetz für den Vorrang Erneuerbarer Energien eingeführt wurde Dokumentations- und Informationssystem für Parlamentsmaterialien. Dieses regelte in § 3 den Einspeisevorrang erneuerbarer Energien:\n\n\n\n\n\n\n \n\n\nAbnahme- und Vergütungspflicht\n(1) Netzbetreiber sind verpflichtet, Anlagen zur Erzeugung von Strom nach § 2 an ihr Netz anzuschließen, den gesamten angebotenen Strom aus diesen Anlagen vorrangig abzunehmen und den eingespeisten Strom nach §§ 4 bis 8 zu vergüten.\n\n\n \n\n\n\n\n \nGesetz für den Vorrang Erneuerbarer Energien (Erneuerbare-Energien-Gesetz – EEG) sowie zur Änderung des Energiewirtschaftsgesetzes und des Mineralölsteuergesetzes. Bundesgesetzblatt Jahrgang 2000 Teil I Nr. 13, ausgegeben zu Bonn am 31. März 2000. Bundesanzeiger\n\n\n\n \nAls erneuerbare Energien klassifizierte Erzeuger speisen vorrangig in das Netz ein. Dies sind nach der aktuellen Fassung des Gesetztes:\n\n\nWasserkraft einschließlich der Wellen-, Gezeiten-, Salzgradienten- und Strömungsenergie,\nWindenergie,\nsolare Strahlungsenergie,\nGeothermie,\nEnergie aus Biomasse einschließlich Biogas, Biomethan, Deponiegas und Klärgas sowie aus dem biologisch abbaubaren Anteil von Abfällen aus Haushalten und Industrie\n\nGesetz für den Ausbau erneuerbarer Energien (Erneuerbare-Energien-Gesetz - EEG 2023). § 3 Begriffsbestimmungen. https://www.gesetze-im-internet.de/eeg_2014/__3.html\n\n \nDie nicht erneuerbaren Erzeuger arbeiten im Lastfolgebetrieb zur Deckung der Restlast, das heißt der Netzlast abzüglich der erneuerbaren Erzeugungsleistung. Dies bedeutet, dass zwei Szenarien zu unterscheiden sind:\n\nÜberschuss an erneuerbaren Energien: Der Stromverbrauch wird vollständig durch die Erzeugung erneuerbarer Energien gedeckt und es besteht ein Erzeugungsüberschuss (bzw. Erzeuger wurden abgeregelt), aus dem zusätzlicher Stromverbrauch bedient werden kann.\nStrommix aus erneuerbarer Einspeisung und Lastfolgebetrieb nicht erneuerbarer Erzeuger: Erneuerbare Energien speisen mit voller Leistung ein, die Restlast und zusätzlicher Stromverbrauch wird von nicht erneuerbaren Erzeugern gedeckt.\n\nWelches Szenario im Stromnetz zu einem bestimmten Zeitpunkt besteht, lässt sich also an der Restlast ablesen.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Energiedatenanalyse</span>"
    ]
  },
  {
    "objectID": "skript/energiedatenanalyse.html#residual--und-restlast-bestimmen",
    "href": "skript/energiedatenanalyse.html#residual--und-restlast-bestimmen",
    "title": "1  Energiedatenanalyse",
    "section": "6.3 Residual- und Restlast bestimmen",
    "text": "6.3 Residual- und Restlast bestimmen\nDie Bundesnetzagentur veröffentlicht im Datensatz zum realisierten Stromverbrauch Netzlast, Residuallast und den Stromverbrauch durch Pumpspeicherkraftwerke.\n\nprint(verbrauch.sum(numeric_only = True))\n\nGesamt (Netzlast) [MWh]    4.58e+08\nResiduallast [MWh]         2.60e+08\nPumpspeicher [MWh]         1.41e+07\ndtype: float64\n\n\n\n\n\n\n\n\nDefinition 6.2: Residuallast\n\n\n\n“Die Residuallast […] entspricht dem gesamten Realisierten Stromverbrauch, abzüglich der Einspeisung von Photovoltaik-, Wind Onshore- und Wind Offshore-Anlagen.” SMARD.de Benutzerhandbuch (S. 53)\n\n\n \nDie nicht durch erneuerbare Energien bediente Restlast ist die Differenz aus Stromverbrauch und der Erzeugung durch erneuerbare Energien. Die Restlast ist folglich kleiner als die von der Bundesnetzagentur veröffentlichte Residuallast. Residual- und Restlast können aus der Differenz von Netzlast und der entsprechenden erneuerbaren Stromerzeugung berechnet werden.\n\nerneuerbare = ['Biomasse [MWh]', 'Wasserkraft [MWh]', 'Wind Offshore [MWh]', 'Wind Onshore [MWh]', 'Photovoltaik [MWh]', 'Sonstige Erneuerbare [MWh]']\nPV_WindOnshore_WindOffshore = ['Wind Offshore [MWh]', 'Wind Onshore [MWh]', 'Photovoltaik [MWh]'] \n\nplotting_data = pd.DataFrame()\nplotting_data[\"Netzlast [MWh]\"] = verbrauch[\"Gesamt (Netzlast) [MWh]\"].copy() \nplotting_data[\"volatile EE [MWh]\"] = erzeugung[PV_WindOnshore_WindOffshore].sum(axis = \"columns\").copy()\nplotting_data[\"Erneuerbare [MWh]\"] = erzeugung[erneuerbare].sum(axis = \"columns\").copy()\n\nplotting_data[\"Residuallast BNetzA [MWh]\"] = verbrauch[\"Residuallast [MWh]\"].copy()\nplotting_data[\"Residuallast [MWh]\"] = plotting_data[\"Netzlast [MWh]\"] - plotting_data[\"volatile EE [MWh]\"]\nplotting_data[\"Restlast [MWh]\"] = plotting_data[\"Netzlast [MWh]\"] - plotting_data[\"Erneuerbare [MWh]\"]\n\nplotting_data.head()\n\n\n\n\n\n\n\n\nNetzlast [MWh]\nvolatile EE [MWh]\nErneuerbare [MWh]\nResiduallast BNetzA [MWh]\nResiduallast [MWh]\nRestlast [MWh]\n\n\n\n\n0\n9720.75\n7830.50\n9277.00\n1890.25\n1890.25\n443.75\n\n\n1\n9641.25\n7902.00\n9343.00\n1739.25\n1739.25\n298.25\n\n\n2\n9609.50\n8119.50\n9559.50\n1490.00\n1490.00\n50.00\n\n\n3\n9565.00\n7919.00\n9362.25\n1646.00\n1646.00\n202.75\n\n\n4\n9473.50\n8107.75\n9540.50\n1365.75\n1365.75\n-67.00\n\n\n\n\n\n\n\n \nDie von der Bundesnetzagentur veröffentlichte Residuallast Residuallast BNetzA [MWh] entspricht nach der Betrachtung der ersten Zeilen der selbst berechneten Residuallast Residuallast [MWh]. Ob dies für die gesamte Zeitreihe gilt, kann leicht mit der Methode pd.Series.equals() überprüft werden, die einen boolschen Wahrheitswert, d. h. True oder False, zurückgibt.\n\nplotting_data['Residuallast BNetzA [MWh]'].equals(plotting_data['Residuallast [MWh]'])\n\nTrue\n\n\nSomit kann die redundante Spalte entfernt werden.\n\nplotting_data.drop(['Residuallast BNetzA [MWh]'], axis = 'columns', inplace = True)",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Energiedatenanalyse</span>"
    ]
  },
  {
    "objectID": "skript/energiedatenanalyse.html#jahresgang-grafisch-darstellen",
    "href": "skript/energiedatenanalyse.html#jahresgang-grafisch-darstellen",
    "title": "1  Energiedatenanalyse",
    "section": "6.4 Jahresgang grafisch darstellen",
    "text": "6.4 Jahresgang grafisch darstellen\nDie Netzlast, die Erzeugung durch erneuerbare Energien sowie die Residual- und Restlast sollen im Jahresgang dargestellt werden. Zur besseren Darstellung wird nur jeder 100. Wert eingezeichnet.\n\nNetzlast im JahresgangCode für den Plot\n\n\n\n\n\n\n\nNetzlast im Jahresgang\n\n\n\n\n\n\n\n# Position und Inhalt der x-Achsenbeschriftung finden\nmonate = erzeugung[\"Datum von\"].dt.month.unique().tolist() # gibt die Zahlen 1-12 aus\n\n## mit Pandas\nmonate_index = erzeugung[~erzeugung[\"Datum von\"].dt.month.duplicated()].index\nmonatsnamen = erzeugung[\"Datum von\"].iloc[monate_index].dt.strftime(\"%B\") \n\n## alternativ mit einer Listenoperation\n# monate_index = []\n# monatsnamen = []\n\n# for i in monate:\n#   monate_index.append(erzeugung.index[erzeugung[\"Datum von\"].dt.month == i].min())\n#   monatsnamen.append(erzeugung[\"Datum von\"].iloc[monate_index[i - 1]].strftime(\"%B\"))\n\n\n# plotten jedes 100. Werts\nplotting_data[::100].plot(figsize = (9, 8), subplots = True, sharey = True, xlim = (plotting_data.index.min() - (len(plotting_data.index) / 100), plotting_data.index.max() * 1.01), rot = 45, grid = True)\nplt.ylim(top = 20000)\nplt.minorticks_off()\nplt.xticks(monate_index, monatsnamen);\n\nplt.show()\n\n\n\n\nEs ist zu erkennen, dass die Netzlast dauerhaft oberhalb von 9.000 MWh liegt. Darüber hinausgehend schwankt die Netzlast im Monatsgang stark und erreicht Werte von bis zu 19.000 MWh. In jedem Monat werden Leistungen nahe des absoluten Minimums und Maximums erreicht. Im Sommer ist die Netzlast im Allgemeinen etwas niedriger als im Winter.\nDie Stromerzeugung durch erneuerbare Energien, die im zweiten subplot (volatile EE [MWh]) dargestellt ist, ist stark volatil. Phasen hoher Produktion wechseln sich mit Phasen geringer Produktion ab und dauern jeweils nur einige Tage und höchstens für zwei Wochen an. Dies geht maßgeblich auf die Stromerzeugung durch Photovoltaik und Off- und Onshore Wind zurück, deren deutschlandweit kombinierte Erzeugungsleistung häufig nahe Null liegt, um anschließend ein (lokales) Produktionsmaximum zu erreichen. Im dritten subplot (Erneuerbare [MWh]) ist zu erkennen, dass die zusätzliche Einspeisung weniger volatiler erneuerbarer Energien wie Biomasse und Wasserkraft vergleichsweise gering ist. Dadurch ist die über alle erneuerbaren Erzeugungsformen summierte Stromerzeugung zwar nie Null, erreicht aber häufig eine geringe Gesamtleistung. Gleichwohl gibt es auch kurze Phasen erneuerbarer Vollversorgung bzw. Überschussproduktion, wie am Jahresgang der nicht erneuerbaren Restlast abzulesen ist.\nFür die Frage nach der Herkunft des in den Pumpspeicherkraftwerken gespeicherten Stroms kann bereits durch die graphische Darstellung gefolgert werden, dass dieser überwiegend durch nicht erneuerbare Stromerzeuger erzeugt wurde, da die Restlast nur selten Null oder negativ ist.\nDer Jahresgang der Restlast gleicht dem Erzeugungsverlauf der volatilen erneuerbaren Energien. Dies stellt für die konventionellen Kraftwerke eine Herausforderung dar. Dieser Aspekt wird im nächsten Abschnitt vertieft.\nZunächst aber eine kleine Aufgabe:\nWie würde sich eine Verdopplung der erneuerbaren Erzeugung auf die Restlast auswirken? Stellen Sie den Effekt auf vergleichbare Weise grafisch dar (z. B. durch eine zusätzliche Spalte ‘Netzlast - 2x EE’).\n\n\n\n\n\n\nTipp 6.1: Musterlösung Verdopplung EE\n\n\n\n\n\n\nPlotCodeMögliche Interpretation\n\n\n\n\n\n\n\nMusterlösung Verdopplung EE\n\n\n\n\n\n\n\nplotting_data_2EE = plotting_data.copy()\nplotting_data_2EE[\"2x EE\"] = plotting_data_2EE[\"Erneuerbare [MWh]\"] * 2\nplotting_data_2EE[\"Netzlast - 2x EE\"] = plotting_data_2EE[\"Netzlast [MWh]\"] - plotting_data_2EE[\"2x EE\"]\nplotting_data_2EE = plotting_data_2EE[[\"Netzlast [MWh]\", \"Netzlast - 2x EE\"]]\n\n# plotten jedes 100. Werts\nplotting_data_2EE[::100].plot(figsize = (9, 6), subplots = True, sharey = True, xlim = (plotting_data_2EE.index.min() - (len(plotting_data_2EE.index)) / 100, plotting_data_2EE.index.max() * 1.01), rot = 45, grid = True)\nplt.minorticks_off()\nplt.xticks(monate_index, monatsnamen);\n\nplt.show()\n\n\n\nDie Netzlast abzüglich der verdoppelten erneuerbaren Stromerzeugung nähert sich einer symmetrischen Verteilung um die Nullinie an. Das heißt, Phasen erneuerbarer Über- und Unterproduktion halten sich ungefähr die Waage.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Energiedatenanalyse</span>"
    ]
  },
  {
    "objectID": "skript/energiedatenanalyse.html#hintergrund-grund--mittel-und-spitzenlast",
    "href": "skript/energiedatenanalyse.html#hintergrund-grund--mittel-und-spitzenlast",
    "title": "1  Energiedatenanalyse",
    "section": "6.5 Hintergrund: Grund-, Mittel und Spitzenlast",
    "text": "6.5 Hintergrund: Grund-, Mittel und Spitzenlast\nNicht alle Erzeuer sind aus technischen oder aus wirtschaftlichen Gründen gleichermaßen für den Lastfolgebetrieb geeignet. Beispielsweise sind Kohlekraftwerke weniger flexibel regelbar als Gaskraftwerke. Kernkraftwerke werden aufgrund ihrer hohen Fix- und geringen variablen Kosten bevorzugt im Grundlastbetrieb betrieben. Im Stromnetz werden drei Einsatzprofile für Kraftwerke unterschieden: Grundlast, Mittellast und Spitzenlast.\n\n\n\n\n\n\nDefinition 6.3: Grund-, Mittel- und Spitzenlast\n\n\n\n\n\nGrundlast: Die im Jahresgang dauerhaft nachgefragte Leistung.\nKraftwerkstypen: Braunkohle, Kernkraft, Laufwasser\nMittellast: Über die Grundlast hinausgehende, im Tages- und Jahresgang planbar nachgefragte Leistung.\nKraftwerkstypen: Gas-und-Dampfturbinen-Kraftwerk, Steinkohle\nSpitzenlast: Über die Mittellast hinausgehende, im Tages- und Jahresgang nur kurzzeitig oder ungeplant nachgefragte Leistung.\nKraftwerkstypen: Gaskraftwerke, Pumpspeicherkraftwerke\n\nISPEX AG: Grundlast, Mittellast, Spitzenlast\nGrünwald, Reinhard / Caviezel, Claudio 2017: Lastfolgefähigkeit deutscher Kernkraftwerke. Monitoring. Büro für Technikfolgen-Abschätzung beim Deutschen Bundestag (TAB). doi: 10.5445/IR/1000102277. Seite 16.\n\n\n\nFür die Frage, welche Kraftwerke den Grenzstrom zur Befüllung der Pumpspeicherkraftwerke liefern, ist insbesondere die Unterscheidung von im Grundlastbetrieb operierenden Kraftwerken einerseits sowie von im Mittellast- und Spitzenlastbetrieb arbeitenden Kraftwerken andererseits relevant. In Grundlast operierende Kraftwerke fahren 24 Stunden am Tag in Volllast. Beispielsweise erreichte Kernenergie im Jahr 2021 mit 8.070 Jahresvolllaststunden beinahe einen durchgehenden Volllastbetrieb statista. In Volllast betriebene Kraftwerke können nicht mehr auf zusätzliche Stromnachfrage reagieren. Dies bleibt im Mittel- und Spitzenlastbetrieb arbeitenden Kraftwerken überlassen.\nSomit können durch die Unterscheidung von in Grundlast und von in Mittel- bzw. Spitzenlast betriebenen Kraftwerkstypen die Kraftwerkstypen, die den zur Befüllung der Pumpspeicherkraftwerken erforderlichen Strom lieferten, eingegrenzt werden.\nDie Auslastung eines Kraftwerks (bzw. einer Gruppe von Kraftwerken) kann mittels seiner Jahresvolllaststunden quantifiziert werden.\n\n\n\n\n\n\nDefinition 6.4: Jahresvolllaststunden\n\n\n\nDie Jahresvolllaststunden geben an, wie viel der 8.760 Stunden eines Jahres ein Kraftwerk bei maximaler Leistung laufen müsste, um seine Jahresproduktion zu erzeugen. statista\n\\[\nJahresvolllaststunden ~ in ~ h = \\frac{Summe ~ erzeugten ~ Stroms ~ in ~ MWh}{installierte ~ Leistung ~ in ~ MW}\n\\]\n\n\nDie Jahresvolllaststunden können wie folgt berechnet werden. Die Anwendung der Methode .sum auf den Datensatz installierte_leistung ist nicht erforderlich, da dieser nur eine Zeile hat. Die Methode .sum erlaubt es aber, über den Parameter numeric_only = True die Datumsspalten auszuschließen.\n\n# print(f\"{erzeugung.sum(numeric_only = True)}\\n\")\n# print(installierte_leistung.sum(numeric_only = True), \"\\n\")\n\n# Für die Division müssen die Indizes zurücksetzt werden\njahresvolllaststunden = erzeugung.sum(numeric_only = True).reset_index(drop = True).divide(installierte_leistung.sum(numeric_only = True).reset_index(drop = True))\n\n# Index neu setzen\njahresvolllaststunden.index = erzeugung.sum(numeric_only = True).index.str.replace(pat = \" [MWh]\", repl = \" [h]\")\n\nprint(f\"\\n\\nJahresvolllaststunden\\n\\n{jahresvolllaststunden.sort_values(ascending = False)}\")\n\n\n\nJahresvolllaststunden\n\nBiomasse [h]                   4467.41\nBraunkohle [h]                 4399.96\nWind Offshore [h]              2893.34\nWasserkraft [h]                2855.83\nSonstige Erneuerbare [h]       2653.47\nSteinkohle [h]                 2192.86\nWind Onshore [h]               2062.55\nKernenergie [h]                1661.92\nErdgas [h]                     1576.42\nSonstige Konventionelle [h]    1293.98\nPumpspeicher [h]               1188.76\nPhotovoltaik [h]                883.48\ndtype: float64\n\n\nDie Berechnung der Jahresstunden zeigt, dass kein Kraftwerkstyp auch nur annähernd in Volllast lief. Die höchste Auslastung weisen Biomasse und Braunkohle auf. Biomasse ist umgerechnet in 51 Prozent der 8760 Jahresstunden in Volllast gelaufen, Braunkohle in 50 Prozent. Demgegenüber erreichte der klassische Grundlasterzeuger Kernenergie nur 25 Prozent. Die in Deutschland hauptsächlich für den Mittellastbetrieb eingesetzte Steinkohle erreichte 19 Prozent. Das Jahr 2023 war insbesondere für die Kernenergie ein ungewöhnliches Jahr.\nDeshalb wird der Jahresgang ausgewählter konventioneller Erzeuger dargestellt. Um eine hohe Auflösung zu erreichen, wird eine Darstellung auf Monatsbasis gewählt.\n\nBeispiel-Code KernenergieKernenergieBraunkohleSteinkohleErdgas\n\n\n\nplotting_data = erzeugung.copy()\n\nerzeuger = \"Kernenergie\"\n\nfig = plt.figure(figsize = (8, 12))\nfig.suptitle(erzeuger, fontsize = 12)\nfor i in range(1, 13):\n  plotting_data_monthly = plotting_data[plotting_data['Datum von'].dt.month == i]\n  ax = fig.add_subplot(12, 1, i)\n  ax.plot(plotting_data_monthly[erzeuger + \" [MWh]\"])\n  plt.margins(x = 0.01)\n  ax.set_ylabel(ylabel = \"MWh\")\n \n  # Titel erzeugen\n  plt.title(label = plotting_data_monthly['Datum von'].head(1).dt.strftime('%B').item(), fontsize = 10)\n  \n  # xticks erzeugen\n  tage_index = plotting_data_monthly[~plotting_data_monthly[\"Datum von\"].dt.day.duplicated()].index\n  tagesnamen = plotting_data_monthly[\"Datum von\"].dt.day.unique() \n  plt.xticks(tage_index, tagesnamen, fontsize = 8)\n\nplt.tight_layout()\nplt.show()\n\n\n\n\n\n\n\n\nJahresgang Kernenergie\n\n\n\n\n\n\n\n\n\n\n\nJahresgang Braunkohle\n\n\n\n\n\n\n\n\n\n\n\nJahresgang Steinkohle\n\n\n\n\n\n\n\n\n\n\n\nJahresgang Erdgas\n\n\n\n\n\n\n\nIm Reiter Kernenergie ist zu erkennen, dass 2023 die letzten deutschen Atomkraftwerke Emsland, Isar 2 und Neckarwestheim 2 vom Netz genommen wurden. Für diese wurde im Herbst 2022 aufgrund der Energiekrise ein über den ursprünglichen Abschalttermin zum 31. Dezember 2022 hinausgehender Streckbetrieb beschlossen. BMWK\nBis zu welchem Tag wurde der Streckbetrieb genehmigt? Bestimmen Sie den Zeitpunkt der Abschaltung anhand des Datensatzes erzeugung. Geben Sie den Zeitpunkt über die Spalte ‘Datum bis’ in deutscher Datumsformtierung `TT. Monat YYYY um HH:MM Uhr’ aus.\n\n\n\n\n\n\nTipp 6.3: Lösungshinweis und Musterlösung\n\n\n\n\n\nMit der Abschaltung erreichte die Stromproduktion durch Kernenergie den Wert 0. Die Abschaltung wurde in der Periode vollendet, die der ersten Periode mit der Stromproduktion durch Kernenergie mit dem Wert 0 vorausging.\nDie Ausgabe einer als datetime formatierten Spalten können Sie mit der Methode pandas.Series.dt.strftime formatieren.\n\n\n\n\n\n\nTipp 6.2: Musterlösung\n\n\n\n\n\nIn der graphischen Darstellung des Jahresgangs wurde nur jeder 100. Wert geplottet, sodass es möglich ist, dass die Stromerzeugung bereits vor der endgültigen Abschaltung den Wert Null erreichte. Es ist deshalb zuverlässiger, den Datensatz rückwärts zu durchsuchen.\nIn der Vorwärtssuche wird mit der Methode .eq()die Position des ersten Auftretens des Werts 0 bestimmt und 1 subtrahiert. In der Rückwärtssuche wird mit der Methode .gt() die Position des ersten Werts bestimmt, der größer als 0 ist.\n\nprint(f\"Vorwärtssuche: erzeugung['Kernenergie [MWh]'].eq(0).idxmax() - 1\\n{erzeugung['Kernenergie [MWh]'].eq(0).idxmax() - 1}\\n\")\n\n# rückwärts\nprint(f\"Rückwärtssuche: position := erzeugung['Kernenergie [MWh]'].iloc[::-1].gt(0).idxmax()\\n{ ( position := erzeugung['Kernenergie [MWh]'].iloc[::-1].gt(0).idxmax() ) }\\n\")\n\nprint(f\"erzeugung['Datum bis'].iloc[position].strftime('%d. %B %Y um %H:%M Uhr')\\n{erzeugung['Datum bis'].iloc[position].strftime('%d. %B %Y um %H:%M Uhr')}\")\n\nVorwärtssuche: erzeugung['Kernenergie [MWh]'].eq(0).idxmax() - 1\n10075\n\nRückwärtssuche: position := erzeugung['Kernenergie [MWh]'].iloc[::-1].gt(0).idxmax()\n10075\n\nerzeugung['Datum bis'].iloc[position].strftime('%d. %B %Y um %H:%M Uhr')\n16. April 2023 um 00:00 Uhr\n\n\n\n\n\n\n\n\nDie Berechnung der Jahresvolllaststunden und die Visualisierung der Jahresgänge zeigen, dass es durch den hohen Anteil volatiler erneuerbarer Stromerzeugung im deutschen Stromsystem keine Grundlast mehr gibt, die von konventionellen Erzeugern bedient werden kann. Dies bedeutet, dass alle nicht erneuerbaren Erzeuger im Lastfolgebetrieb arbeiten. Dies kann am Beispiel der Steinkohle verdeutlicht werden, deren erzielte Jahresvolllaststunden näher an der klassischen Spitzenlasterzeugung aus Erdgas als an der Mittellasterzeugung durch Braunkohle liegt. Die Auslastung eines Stromerzeugers kann mit einer sortierten Jahresdauerlinie dargestellt werden.\n\n\n\n\n\n\nDefinition 6.5: sortierte Jahresdauerlinie\n\n\n\nDie sortierte Jahresdauerlinie ist ein Diagramm der absteigend sortierten Daten.\n\n\nEnergietechnik. 2 Einführung. 2.13 Sortierte Jahresdauerlinie von Henrik te Heesen ist lizensiert unter CC BY-SA 3.0 und abrufbar auf YouTube.\n\n\n\n\nPlotCode für den Plot\n\n\n\n\n\n\n\nsortierte Jahresdauerlinie ausgewählter konventioneller Erzeuger\n\n\n\n\n\n\n\n# Daten nach Tag gruppieren und durch Mittelwertbildung auf Tagesbasis aggregieren.\nbraunkohle_daily = erzeugung['Braunkohle [MWh]'].groupby(erzeugung[\"Datum von\"].dt.dayofyear).mean()\nsteinkohle_daily = erzeugung['Steinkohle [MWh]'].groupby(erzeugung[\"Datum von\"].dt.dayofyear).mean()\nerdgas_daily = erzeugung['Erdgas [MWh]'].groupby(erzeugung[\"Datum von\"].dt.dayofyear).mean()\n\n## Zur Kontrolle\n## print(erzeugung[\"Datum von\"].dt.dayofyear)\n## print(f\"\\n\\nbraunkohle_daily.head()\\n{braunkohle_daily.head()}\\n\\n\"\n##       f\"Zum Vergleich:\\nerzeugung['Braunkohle [MWh]'].iloc[[0, 1, 95, 96]]\\n{erzeugung['Braunkohle [MWh]'].iloc[[0, 1, 95, 96]]}\\n\\n\"\n##       f\"erzeugung['Braunkohle [MWh]'].iloc[0:96].mean()\\n{erzeugung['Braunkohle [MWh]'].iloc[0:96].mean()}\") \n\n# Liniendiagramm plotten\n# Index um 1 verschieben, weil Index mit 0 beginnt, aber die Anzahl der Tage dargestellt wird.\nlinienstärke = 5\nplt.figure(figsize = (8, 4))\n\nbraunkohle_daily = braunkohle_daily.sort_values(ascending = False, ignore_index = True)\nbraunkohle_daily.index += 1\nbraunkohle_daily.plot.line(lw = linienstärke, color = 'brown', alpha = 0.5, label = 'Braunkohle')\n\nsteinkohle_daily = steinkohle_daily.sort_values(ascending = False, ignore_index = True)\nsteinkohle_daily.index += 1\nsteinkohle_daily.plot.line(lw = linienstärke, color = 'black', alpha = 0.5, label = 'Steinkohle')\n\nerdgas_daily = erdgas_daily.sort_values(ascending = False, ignore_index = True)\nerdgas_daily.index += 1\nerdgas_daily.plot.line(lw = linienstärke, color = 'lightskyblue', alpha = 0.5, label = 'Erdgas')\n\nplt.title(label = \"sortierte Jahresdauerlinie für ausgewählte konventionelle Erzeuger\")\nplt.grid()\nplt.legend()\nplt.ylabel('durchschnittliche Stromerzeugung in MWh\\n(auf Viertelstundenbasis)')\nplt.xlabel('Anzahl Tage pro Jahr')\n\nplt.margins(x = 0.02)\nplt.show()\n\n\n\n\nBeim Vergleich der erzielten Jahresvolllaststunden konnte festgestellt werden, dass die Auslastung der Steinkohle eher der des Spitzenlasterzeugers Erdgas als des Mittellasterzeugers Braunkohle entspricht. In der grafischen Darstellung der sortierten Jahresdauerlinien wird darüber hinaus deutlich, dass das Erzeugungsprofil der Steinkohle dem der Braunkohle sogar weniger ähnelt als dem von Erdgas.\nBisher wurde ausschließlich die Erzeugung durch konventionelle Kraftwerke betrachtet. Biomasse und Braunkohle erreichen vergleichbare Jahresvolllaststunden, sodass ein Vergleich beider Erzeuger interessant sein könnte.\nStellen Sie den Jahresgang und die Jahresdauerlinien für Biomasse und Braunkohle dar.\n\n\n\n\n\n\nTipp 6.4: Musterlösung Erzeugungsprofile von Biomasse und Braunkohle\n\n\n\n\n\n\n\nCodeText-OutputJahresgang BiomasseJahresgang BraunkohleSortierte Jahresdauerlinien\n\n\n\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Deklarieren der Anzahl der Nachkommastellen\npd.set_option(\"display.precision\", 2)\n\n# Datensätze werden eingelesen\n\n# !\n# Für die eigene Anwendung muss der Dateipfad an den korrekten Speicherort der runtergeladenen .csv Datei angepasst werden. \n# !\n\nerzeugung0_ms = pd.read_csv(\"01-daten/Realisierte_Erzeugung_202301010000_202401010000_Viertelstunde.csv\", \\\nsep = \";\", thousands = \".\", decimal = \",\", parse_dates =  [0, 1], date_format = \"%d.%m.%Y %H:%M\")\n\n# Zeichenkette \" Originalauflösungen\" entfernen\nerzeugung0_ms.columns = erzeugung0_ms.columns.str.replace(pat = \" Originalauflösungen\", repl = \"\")\n\nprint(erzeugung0_ms.head(10))\n\n# Daten der zu betrachtenden Erzeugungsarten nach Tag gruppieren und durch Mittelwertbildung auf Tagesbasis aggregieren\nbraunkohle_daily_ms = erzeugung0_ms['Braunkohle [MWh]'].groupby(erzeugung0_ms[\"Datum von\"].dt.dayofyear).mean()\nbiomasse_daily_ms = erzeugung0_ms['Biomasse [MWh]'].groupby(erzeugung0_ms[\"Datum von\"].dt.dayofyear).mean()\n\n# Liniendiagramm plotten\nlinienstärke = 5\nplt.figure(figsize = (8, 4))\n\nbraunkohle_daily_ms = braunkohle_daily_ms.sort_values(ascending = False, ignore_index = True)\nbraunkohle_daily_ms.index += 1\nbraunkohle_daily_ms.plot.line(lw = linienstärke, color = 'brown', alpha = 0.5, label = 'Braunkohle')\n\nbiomasse_daily_ms = biomasse_daily_ms.sort_values(ascending = False, ignore_index = True)\nbiomasse_daily_ms.index += 1\nbiomasse_daily_ms.plot.line(lw = linienstärke, color = 'greenyellow', alpha = 0.5, label = 'Biomasse')\n\nplt.title(label = \"sortierte Jahresdauerlinie für ausgewählte Erzeuger\")\nplt.grid()\nplt.legend()\nplt.ylabel('durchschnittliche Stromerzeugung in MWh\\n(auf Viertelstundenbasis)')\nplt.xlabel('Anzahl Tage pro Jahr')\n\nplt.margins(x = 0.02)\n\n# Lastgang: Hier den Erzeugungstyp auswählen, je nachdem, welcher Lastgang geplottet werden soll. Der andere wird auskommentiert\nerzeuger = \"Biomasse\"\n#erzeuger = \"Braunkohle\"\n\nfig = plt.figure(figsize = (8, 12))\nfig.suptitle(erzeuger, fontsize = 12)\nfor i in range(1, 13):\n  plotting_data_monthly = erzeugung0_ms[erzeugung0_ms['Datum von'].dt.month == i]\n  ax = fig.add_subplot(12, 1, i)\n  ax.plot(plotting_data_monthly[erzeuger + \" [MWh]\"])\n  plt.margins(x = 0.01)\n  ax.set_ylabel(ylabel = \"MWh\")\n \n  # Titel erzeugen\n  plt.title(label = plotting_data_monthly['Datum von'].head(1).dt.strftime('%B').item(), fontsize = 10)\n  \n  # xticks erzeugen\n  tage_index = plotting_data_monthly[~plotting_data_monthly[\"Datum von\"].dt.day.duplicated()].index\n  tagesnamen = plotting_data_monthly[\"Datum von\"].dt.day.unique() \n  plt.xticks(tage_index, tagesnamen, fontsize = 8)\n\nplt.tight_layout()\nplt.show()\n\n\n\n\n\n            Datum von           Datum bis  Biomasse [MWh]  Wasserkraft [MWh]  \\\n0 2023-01-01 00:00:00 2023-01-01 00:15:00         1094.25             320.00   \n1 2023-01-01 00:15:00 2023-01-01 00:30:00         1091.25             317.50   \n2 2023-01-01 00:30:00 2023-01-01 00:45:00         1090.25             317.25   \n3 2023-01-01 00:45:00 2023-01-01 01:00:00         1089.25             321.50   \n4 2023-01-01 01:00:00 2023-01-01 01:15:00         1085.25             315.25   \n5 2023-01-01 01:15:00 2023-01-01 01:30:00         1087.75             304.75   \n6 2023-01-01 01:30:00 2023-01-01 01:45:00         1086.50             303.50   \n7 2023-01-01 01:45:00 2023-01-01 02:00:00         1085.25             304.25   \n8 2023-01-01 02:00:00 2023-01-01 02:15:00         1080.25             308.25   \n9 2023-01-01 02:15:00 2023-01-01 02:30:00         1084.25             305.50   \n\n   Wind Offshore [MWh]  Wind Onshore [MWh]  Photovoltaik [MWh]  \\\n0               684.25             7145.75                0.50   \n1               743.50             7158.25                0.25   \n2               817.00             7302.25                0.25   \n3               814.50             7104.25                0.25   \n4               785.50             7322.00                0.25   \n5               898.50             7332.75                0.25   \n6               943.75             7259.75                0.25   \n7               958.25             7390.50                0.25   \n8              1009.75             7229.00                0.50   \n9               967.00             7421.75                0.25   \n\n   Sonstige Erneuerbare [MWh]  Kernenergie [MWh]  Braunkohle [MWh]  \\\n0                       32.25             615.25            962.75   \n1                       32.25             614.75            963.25   \n2                       32.50             615.00            966.50   \n3                       32.50             614.50            966.75   \n4                       32.25             614.50            969.00   \n5                       32.25             614.75            965.75   \n6                       32.25             614.75            967.50   \n7                       32.25             614.75            964.25   \n8                       32.25             615.00            963.00   \n9                       32.25             614.75            967.00   \n\n   Steinkohle [MWh]  Erdgas [MWh]  Pumpspeicher [MWh]  \\\n0            517.00        429.75               13.50   \n1            518.00        429.50                9.75   \n2            517.00        432.00                9.75   \n3            515.50        430.50                9.75   \n4            513.25        391.25               26.50   \n5            514.00        389.50               45.00   \n6            513.75        393.75               50.50   \n7            511.00        393.50               50.50   \n8            509.75        391.50               41.25   \n9            509.00        394.50               40.75   \n\n   Sonstige Konventionelle [MWh]  \n0                         307.25  \n1                         307.25  \n2                         308.25  \n3                         306.00  \n4                         306.75  \n5                         305.00  \n6                         302.00  \n7                         304.50  \n8                         303.00  \n9                         303.75  \n\n\n\n\n\n\n\n\n\nJahresgang Biomasse\n\n\n\n\n\n\n\n\n\n\n\nJahresgang Biomasse\n\n\n\n\n\n\n\n\n\n\n\nSortierte Jahresdauerlinien für ausgewählte Erzeuger\n\n\n\n\n\n\n\nMusterlösung von Marc Sönnecken. Der Code und die durch Abschnitte des Codes erzeugten Outputs wurden in Reiter aufgeteilt. Für die Kompatibilität mit diesem Skript wurden der Dateipfad und die Objektbezeichnungen angepasst. Für die Barrierefreiheit wurden die verwendeten Farben angepasst.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Energiedatenanalyse</span>"
    ]
  },
  {
    "objectID": "skript/energiedatenanalyse.html#sec-Pumpspeicherinhalt",
    "href": "skript/energiedatenanalyse.html#sec-Pumpspeicherinhalt",
    "title": "1  Energiedatenanalyse",
    "section": "6.6 Bestimmung des in den Pumpspeichern gespeicherten Stroms",
    "text": "6.6 Bestimmung des in den Pumpspeichern gespeicherten Stroms\nIn den bisherigen Betrachtungen wurde gezeigt, dass zwei grundsätzliche Szenarien im Stromnetz zu unterscheiden sind:\n\nRestlast Null oder negativ: Grenzstrom wird von erneuerbaren Energien produziert.\nRestlast positiv: Grenzstrom wird von konventionellen Energien im Lastfolgebetrieb produziert.\n\nDen Jahresgang des Stromverbrauchs durch Pumpspeicher und das jeweils bestehende Szenario zeigt folgender Graph, der jeden 100. Wert der Datenreihe verbrauch['Pumpspeicher [MWh]'] darstellt.\n\nPlotCode für den Plot\n\n\n\n\n\n\n\nEinspeicherung in Pumpspeicherkraftwerke 2023\n\n\n\n\n\n\n\n# Restlast berechnen\nerneuerbare = ['Biomasse [MWh]', 'Wasserkraft [MWh]', 'Wind Offshore [MWh]', 'Wind Onshore [MWh]', 'Photovoltaik [MWh]', 'Sonstige Erneuerbare [MWh]']\n\nrestlast = pd.DataFrame()\nrestlast[\"Netzlast [MWh]\"] = verbrauch[\"Gesamt (Netzlast) [MWh]\"].copy() \nrestlast[\"Erneuerbare [MWh]\"] = erzeugung[erneuerbare].sum(axis = \"columns\").copy()\nrestlast[\"Restlast [MWh]\"] = restlast[\"Netzlast [MWh]\"] - restlast[\"Erneuerbare [MWh]\"]\nrestlast = restlast[\"Restlast [MWh]\"]\n\n# xticks berechnen\nmonate_index = erzeugung[~erzeugung[\"Datum von\"].dt.month.duplicated()].index\nmonatsnamen = erzeugung[\"Datum von\"].iloc[monate_index].dt.strftime(\"%B\") \n\n# plotten jedes n. Werts\nschritt = 100\nverbrauch['Pumpspeicher [MWh]'][::schritt].plot(figsize = (9, 6), xlim = (verbrauch.index.min() - (len(verbrauch.index) / 100), verbrauch.index.max() * 1.01), rot = 45, grid = True, label = \"\")\nplt.ylabel('Einspeicherung [MWh]', fontsize = 12)\nplt.suptitle('Einspeicherung in Pumpspeicherkraftwerke 2023')\n\n# xticks eintragen\nplt.minorticks_off()\nplt.xticks(monate_index, monatsnamen);\n\n# Kurve unterlegen: plt.fill_between bietet einen praktischen Parameter where\nplt.fill_between(x = verbrauch['Pumpspeicher [MWh]'].index[::schritt], y1 = verbrauch['Pumpspeicher [MWh]'][::schritt], label = 'konventionelle Einspeicherung') # , where = restlast[::schritt] &gt; 0 führt zu weißen Stellen\nplt.fill_between(x = verbrauch['Pumpspeicher [MWh]'].index[::schritt], y1 = verbrauch['Pumpspeicher [MWh]'][::schritt], where = restlast[::schritt] &lt;= 0, color = 'greenyellow', label = 'erneuerbare Einspeicherung')\n\nplt.legend()\nplt.show()\n\n\n\n\nDie Grafik spiegelt die bei der Bestimmung der Residual- und Restlast gewonnene Erkenntnis wider, dass mit dem im Jahr 2023 realisierten Strommix zusätzliche Stromnachfrage vorwiegend konventionell bedient wird.\nWie sähe die Grafik aus, wenn die Einspeisung aus erneuerbaren Energien doppelt so hoch ausgefallen wäre?\n\n\n\n\n\n\nTipp 6.5: Musterlösung Einspeicherung bei doppelter erneuerbarer Erzeugung\n\n\n\n\n\nFür die Berechnung genügt es, die summierte Stromerzeugung aus erneuerbaren Energien mit 2 zu multiplizieren.\nrestlast = pd.DataFrame()\nrestlast[\"Netzlast [MWh]\"] = verbrauch[\"Gesamt (Netzlast) [MWh]\"].copy() \nrestlast[\"Erneuerbare [MWh]\"] = erzeugung[erneuerbare].sum(axis = \"columns\").copy()\nrestlast[\"Restlast [MWh]\"] = restlast[\"Netzlast [MWh]\"] - 2 * restlast[\"Erneuerbare [MWh]\"]\nrestlast = restlast[\"Restlast [MWh]\"]\n\n\n\n\n\nEinspeicherung in Pumpspeicherkraftwerke 2023",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Energiedatenanalyse</span>"
    ]
  },
  {
    "objectID": "skript/energiedatenanalyse.html#aufgabe-explorative-datenanalyse",
    "href": "skript/energiedatenanalyse.html#aufgabe-explorative-datenanalyse",
    "title": "1  Energiedatenanalyse",
    "section": "6.7 Aufgabe explorative Datenanalyse",
    "text": "6.7 Aufgabe explorative Datenanalyse\n\n\n\n\n \n\n\nOber- und Hauptstufe der Kraftwerksgruppe: Mooser- und Wasserfallboden mit Karlingerkees links oben, im Hintergrund rechts der Großvenediger von Tigerente ist lizensiert unter CC BY-SA 3.0 und abrufbar auf wikimedia.org. 2008\n\n \nStellen Sie den Jahresgang der Pumpspeicher in Österreich 2023 dar. Hinweise zum Herunterladen der Daten finden Sie in Abschnitt Kapitel 5.2.\n\n\n\n\n\n\nHinweis 6.1: Zeitumstellung im österreichischen Datensatz\n\n\n\n\n\nIm österreichischen Datensatz wird durch die Umstellung von Sommer- auf Winterzeit am letzten Sonntag im Oktober die Stunde 2 Uhr morgens doppelt eingetragen (dafür fehlt eine Stunde bei der Umstellung von Winter- auf Sommerzeit am letzten Sonntag im März). Die doppelte Stunde wird im Datensatz mit 2A bzw. 2B gekennzeichnet. (Mitteilung Austrian Power Grid AG vom 13.08.2024)\n\n\n\nZeitumstellung im österreichischen Datensatz\n\n\nDamit die Datumsspalten korrekt eingelesen werden können, müssen die Einträge bereinigt werden. Eine Möglichkeit besteht darin, die Zeichenfolgen “2A” und “2B” mit der Methode str.replace() durch “02” zu ersetzen (wodurch eine Dublette im Datensatz erzeugt wird).\n\n\n\n\n\n\nMusterlösung korrektes Einlesen mit Hilfe von str.replace()\n\n\n\n\n\n\nerzeugung_austria = pd.read_csv(filepath_or_buffer = \"01-daten/AGPT_2022-12-31T23_00_00Z_2023-12-31T23_00_00Z_15M_de_2024-06-10T09_32_38Z.csv\",\n                            sep = \";\", decimal = \",\", thousands = \".\")\n\n# string replace & als Datum einlesen\n## Spalte Zeit von [CET/CEST]\nerzeugung_austria['Zeit von [CET/CEST]'] = erzeugung_austria['Zeit von [CET/CEST]'].str.replace(pat = '2A', repl = '02')\nerzeugung_austria['Zeit von [CET/CEST]'] = erzeugung_austria['Zeit von [CET/CEST]'].str.replace(pat = '2B', repl = '02')\n\nerzeugung_austria['Zeit von [CET/CEST]'] = pd.to_datetime(erzeugung_austria['Zeit von [CET/CEST]'], format = \"%d.%m.%Y %H:%M:%S\")\n\n## Spalte Zeit bis [CET/CEST]\nerzeugung_austria['Zeit bis [CET/CEST]'] = erzeugung_austria['Zeit bis [CET/CEST]'].str.replace(pat = '2A', repl = '02')\nerzeugung_austria['Zeit bis [CET/CEST]'] = erzeugung_austria['Zeit bis [CET/CEST]'].str.replace(pat = '2B', repl = '02')\n\nerzeugung_austria['Zeit bis [CET/CEST]'] = pd.to_datetime(erzeugung_austria['Zeit bis [CET/CEST]'], format = \"%d.%m.%Y %H:%M:%S\")\n\nprint(erzeugung_austria.dtypes)\n\nZeit von [CET/CEST]             datetime64[ns]\nZeit bis [CET/CEST]             datetime64[ns]\nWind [MW]                              float64\nSolar [MW]                             float64\nBiomasse [MW]                          float64\nGas [MW]                               float64\nKohle [MW]                             float64\nÖl [MW]                                float64\nGeothermie [MW]                        float64\nPumpspeicher [MW]                      float64\nLauf- und Schwellwasser [MW]           float64\nSpeicher [MW]                          float64\nSonstige Erneuerbare [MW]              float64\nMüll [MW]                              float64\nAndere [MW]                            float64\ndtype: object\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nMusterlösung Aufgabe explorative Datenanalyse\n\n\n\n\n\n\n\nCodePlot\n\n\n\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Deklarieren der Anzahl der Nachkommastellen\npd.set_option(\"display.precision\", 2)\n\n# Datensatz wird eingelesen und in der Variable erzeugung0_austria_ms gespeichert\n\n# !\n# Für die eigene Anwendung muss der Dateipfad an den korrekten Speicherort der runtergeladenen .csv Datei angepasst werden. \n# !\nerzeugung0_austria_ms = pd.read_csv(\"01-daten/AGPT_2022-12-31T23_00_00Z_2023-12-31T23_00_00Z_15M_de_2024-06-10T09_32_38Z.csv\", \n                                     sep = \";\", thousands = \".\", decimal = \",\", parse_dates = [0, 1], date_format = \"%d.%m.%Y %H:%M\")\n                                     \n# string replace & als Datum einlesen\n## Spalte Zeit von [CET/CEST]\nerzeugung0_austria_ms['Zeit von [CET/CEST]'] = erzeugung0_austria_ms['Zeit von [CET/CEST]'].str.replace(pat = '2A', repl = '02')\nerzeugung0_austria_ms['Zeit von [CET/CEST]'] = erzeugung0_austria_ms['Zeit von [CET/CEST]'].str.replace(pat = '2B', repl = '02')\n\nerzeugung0_austria_ms['Zeit von [CET/CEST]'] = pd.to_datetime(erzeugung0_austria_ms['Zeit von [CET/CEST]'], format = \"%d.%m.%Y %H:%M:%S\")\n\n## Spalte Zeit bis [CET/CEST]\nerzeugung0_austria_ms['Zeit bis [CET/CEST]'] = erzeugung0_austria_ms['Zeit bis [CET/CEST]'].str.replace(pat = '2A', repl = '02')\nerzeugung0_austria_ms['Zeit bis [CET/CEST]'] = erzeugung0_austria_ms['Zeit bis [CET/CEST]'].str.replace(pat = '2B', repl = '02')\n\nerzeugung0_austria_ms['Zeit bis [CET/CEST]'] = pd.to_datetime(erzeugung0_austria_ms['Zeit bis [CET/CEST]'], format = \"%d.%m.%Y %H:%M:%S\")\n\nprint(erzeugung0_austria_ms.dtypes)\nprint(erzeugung0_austria_ms.head(10))\n\n# Kopie des Datensatzes wird angelegt\nerzeugung_c_austria_ms = erzeugung0_austria_ms.copy()\n\nplotting_data_ms = erzeugung_c_austria_ms.copy()\n\nerzeuger = \"Pumpspeicher\"\n\nfig = plt.figure(figsize = (7.5, 12))\nfig.suptitle(erzeuger, fontsize = 12)\n\nfor i in range(1, 13):\n  plotting_data_monthly_ms = plotting_data_ms[plotting_data_ms[\"Zeit von [CET/CEST]\"].dt.month == i]\n  ax = fig.add_subplot(12, 1, i)\n  ax.plot(plotting_data_monthly_ms[erzeuger + \" [MW]\"])\n  plt.margins(x = 0.01)\n  ax.set_ylabel(ylabel = \"MW\")\n \n  # Titel erzeugen\n  plt.title(label = plotting_data_monthly_ms[\"Zeit von [CET/CEST]\"].head(1).dt.strftime('%B').item(), fontsize = 10)\n  \n  # xticks erzeugen\n  tage_index = plotting_data_monthly_ms[~plotting_data_monthly_ms[\"Zeit von [CET/CEST]\"].dt.day.duplicated()].index\n  tagesnamen = plotting_data_monthly_ms[\"Zeit von [CET/CEST]\"].dt.day.unique() \n  plt.xticks(tage_index, tagesnamen, fontsize = 8)\n\nplt.tight_layout()\nplt.show()\n\n\n\n\n\nZeit von [CET/CEST]             datetime64[ns]\nZeit bis [CET/CEST]             datetime64[ns]\nWind [MW]                              float64\nSolar [MW]                             float64\nBiomasse [MW]                          float64\nGas [MW]                               float64\nKohle [MW]                             float64\nÖl [MW]                                float64\nGeothermie [MW]                        float64\nPumpspeicher [MW]                      float64\nLauf- und Schwellwasser [MW]           float64\nSpeicher [MW]                          float64\nSonstige Erneuerbare [MW]              float64\nMüll [MW]                              float64\nAndere [MW]                            float64\ndtype: object\n  Zeit von [CET/CEST] Zeit bis [CET/CEST]  Wind [MW]  Solar [MW]  \\\n0 2023-01-01 00:00:00 2023-01-01 00:15:00     1000.0         0.0   \n1 2023-01-01 00:15:00 2023-01-01 00:30:00      964.0         0.0   \n2 2023-01-01 00:30:00 2023-01-01 00:45:00      956.0         0.0   \n3 2023-01-01 00:45:00 2023-01-01 01:00:00      992.0         0.0   \n4 2023-01-01 01:00:00 2023-01-01 01:15:00      880.0         0.0   \n5 2023-01-01 01:15:00 2023-01-01 01:30:00      888.0         0.0   \n6 2023-01-01 01:30:00 2023-01-01 01:45:00      948.0         0.0   \n7 2023-01-01 01:45:00 2023-01-01 02:00:00      968.0         0.0   \n8 2023-01-01 02:00:00 2023-01-01 02:15:00      956.0         0.0   \n9 2023-01-01 02:15:00 2023-01-01 02:30:00      952.0         0.0   \n\n   Biomasse [MW]  Gas [MW]  Kohle [MW]  Öl [MW]  Geothermie [MW]  \\\n0          240.0      27.6         0.0      0.0             0.07   \n1          240.0      27.6         0.0      0.0             0.07   \n2          240.0      28.0         0.0      0.0             0.07   \n3          240.0      27.6         0.0      0.0             0.07   \n4          240.0      27.6         0.0      0.0             0.07   \n5          240.0      28.4         0.0      0.0             0.07   \n6          240.0      28.8         0.0      0.0             0.07   \n7          240.0      28.0         0.0      0.0             0.07   \n8          240.0      28.8         0.0      0.0             0.07   \n9          240.0      28.4         0.0      0.0             0.07   \n\n   Pumpspeicher [MW]  Lauf- und Schwellwasser [MW]  Speicher [MW]  \\\n0            -1404.8                        2291.6           70.4   \n1            -1532.8                        2283.2           66.8   \n2            -1544.4                        2240.0          100.4   \n3            -1579.6                        2199.6           77.6   \n4            -1590.8                        2234.8           63.2   \n5            -1602.8                        2229.2           73.6   \n6            -1572.0                        2211.2           69.2   \n7            -1579.2                        2194.8           70.8   \n8            -1649.6                        2202.8           75.2   \n9            -1702.0                        2172.4           65.6   \n\n   Sonstige Erneuerbare [MW]  Müll [MW]  Andere [MW]  \n0                        0.0      100.0         22.0  \n1                        0.0      100.0         22.0  \n2                        0.0      100.0         22.0  \n3                        0.0      100.0         22.0  \n4                        0.0      100.0         22.0  \n5                        0.0      100.0         22.0  \n6                        0.0      100.0         22.0  \n7                        0.0      100.0         22.0  \n8                        0.0      100.0         22.0  \n9                        0.0      100.0         22.0  \n\n\n\n\n\nJahresgang der Pumpspeicher in Österreich 2023\n\n\n\n\n\n\n\nMusterlösung von Marc Sönnecken. Für die Kompatibilität mit diesem Skript wurden der Dateipfad und die Objektbezeichnungen angepasst sowie die Grafikbreite reduziert.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Energiedatenanalyse</span>"
    ]
  },
  {
    "objectID": "skript/energiedatenanalyse.html#hintergrund-ausbaupfad-erneuerbarer-energien",
    "href": "skript/energiedatenanalyse.html#hintergrund-ausbaupfad-erneuerbarer-energien",
    "title": "1  Energiedatenanalyse",
    "section": "7.1 Hintergrund: Ausbaupfad erneuerbarer Energien",
    "text": "7.1 Hintergrund: Ausbaupfad erneuerbarer Energien\nIn Deutschland begann der Ausbau erneuerbarer Energien in den 1990er Jahren. Seit dem Beginn der 2000er Jahre stieg die erneuerbare Stromerzeugung weitgehend kontinuierlich an.\n\n\n\n\nRegenerative Strom­erzeugung in Deutschland seit 1990\n\n\nRegenerative Strom­erzeugung in Deutschland seit 1990 von Volker Quaschning nach Daten der AG Energiebilanzen (Stromerzeugung nach Energieträgern (Strommix) von 1990 bis 2022 (in TWh) Deutschland insgesamt (XLSX)) ist lizensiert unter CC BY-SA 4.0 und abrufbar unter https://www.volker-quaschning.de/datserv/ren-Strom-D/index.php. 2023\n\n \nDas Erneuerbare-Energien Gesetz legt in Paragraph 4 Ausbaupfade für die installierte Leistung von Solarenergie, Windenergie an Land sowie für Biomasse fest. Der Ausbaupfad für Windenergie auf See ist in Paragraph 1 des Windenergie-auf-See-Gesetzes geregelt.\n\n\n\n\n\n\nGesetzliche Grundlagen des erneuerbaren Ausbaupfads\n\n\n\n\n\n\n\n\n\n\n\n \n\n\n§ 4 Ausbaupfad\n[…]\n1. eine Steigerung der installierten Leistung von Windenergieanlagen an Land auf\na) 69 Gigawatt im Jahr 2024,\nb) 84 Gigawatt im Jahr 2026,\nc) 99 Gigawatt im Jahr 2028,\nd) 115 Gigawatt im Jahr 2030,\ne) 157 Gigawatt im Jahr 2035 und\nf) 160 Gigawatt im Jahr 2040\n[…]\n2. eine Steigerung der installierten Leistung von Windenergieanlagen auf See nach Maßgabe des Windenergie-auf-See-Gesetzes,\n3. eine Steigerung der installierten Leistung von Solaranlagen auf\na) 88 Gigawatt im Jahr 2024,\nb) 128 Gigawatt im Jahr 2026,\nc) 172 Gigawatt im Jahr 2028,\nd) 215 Gigawatt im Jahr 2030,\ne) 309 Gigawatt im Jahr 2035 und\nf) 400 Gigawatt im Jahr 2040\n[…]\n4. eine installierte Leistung von Biomasseanlagen von 8 400 Megawatt im Jahr 2030.\n\n\n \n\n\n\n\nGesetz für den Ausbau erneuerbarer Energien (Erneuerbare-Energien-Gesetz - EEG 2023) Bundesministerium der Justiz\n\n\n\n\n \n\n\n\n\n \n\n\n§ 1 Zweck und Ziel des Gesetzes\n[…]\n(2) Ziel dieses Gesetzes ist es, die installierte Leistung von Windenergieanlagen auf See, die an das Netz angeschlossen werden, auf insgesamt mindestens 30 Gigawatt bis zum Jahr 2030, auf insgesamt mindestens 40 Gigawatt bis zum Jahr 2035 und auf insgesamt mindestens 70 Gigawatt bis zum Jahr 2045 zu steigern.\n\n\n \n\n\n\n\nGesetz zur Entwicklung und Förderung der Windenergie auf See (Windenergie-auf-See-Gesetz - WindSeeG) Bundesministerium der Justiz\n\n\n\n\n\n\nDie Ausbauziele der Bundesregierung legen für das Jahr 2030 bzw. 2035 eine installierte Leistung fest in Höhe von:\n\n115 GW Wind an Land bis 2030, 157 GW bis 2035,\n30 GW Wind auf See bis 2030, 40 GW bis 2035,\n215 GW Solar bis 2030, 309 GW bis 2035 sowie\n8,4 GW Biomasse.\n\nDies bedeutet einen geplanten Zubau der installierten Leistung gemessen an der installierten Leistung im Jahr 2023 von:\n\n\n\nCode-Block 7.1\n\n\n\nprint(f\"Wind an Land 2030:\\t{( zubaufaktor_windonshore_2030 := 115 / (installierte_leistung['Wind Onshore [MW]'].sum() / 1000) ):,.2f}\\n\"\n      f\"Wind auf See 2030:\\t{( zubaufaktor_windoffshore_2030 := 30 / (installierte_leistung['Wind Offshore [MW]'].sum() / 1000) ):,.2f}\\n\"\n      f\"Solar 2030:\\t\\t\\t{( zubaufaktor_solar_2030 := 215 / (installierte_leistung['Photovoltaik [MW]'].sum() / 1000) ):,.2f}\\n\"\n      f\"Biomasse 2030:\\t\\t{8.4 / (installierte_leistung['Biomasse [MW]'].sum() / 1000):,.2f}\")\n\nprint(f\"\\n\\nWind an Land 2035:\\t{( zubaufaktor_windonshore_2035 := 157 / (installierte_leistung['Wind Onshore [MW]'].sum() / 1000) ):,.2f}\\n\"\n      f\"Wind auf See 2035:\\t{( zubaufaktor_windoffshore_2035 := 40 / (installierte_leistung['Wind Offshore [MW]'].sum() / 1000) ):,.2f}\\n\"\n      f\"Solar 2035:\\t\\t\\t{( zubaufaktor_solar_2035 := 309 / (installierte_leistung['Photovoltaik [MW]'].sum() / 1000) ):,.2f}\\n\"\n      f\"Biomasse 2035:\\t\\t{8.4 / (installierte_leistung['Biomasse [MW]'].sum() / 1000):,.2f}\")\n\nWind an Land 2030:  2.00\nWind auf See 2030:  3.69\nSolar 2030:         3.41\nBiomasse 2030:      0.99\n\n\nWind an Land 2035:  2.73\nWind auf See 2035:  4.92\nSolar 2035:         4.90\nBiomasse 2035:      0.99\n\n\n\n\n\nBis 2030 soll die Produktion durch Windkraftanlagen an Land verdoppelt sowie durch Windkraftanlagen auf See und durch Photovoltaik verdreieinhalbfacht werden. Bis 2035 soll Windkraft an Land fast verdreifacht, Wind auf See und Photovoltaik verfünffacht werden. Biomasse soll nicht weiter ausgebaut werden. Die Zubaufaktoren werden jeweils in einem Objekt gespeichert.\n\n\n\n\n\n\nNetzentwicklungsplan Strom\n\n\n\nNeben der Erzeugungsleistung soll auch das Stromübertragungsnetz ausgebaut werden. Die Planungen werden im Netzentwicklungsplan Strom festgehalten, der alle zwei Jahre von den vier Übertragungsnetzbetreibern in Abstimmung mit der Bundesnetzagentur aktualisiert wird.\nDer aktuelle und die bisherigen Netzentwicklungspläne können unter https://www.netzentwicklungsplan.de/ abgerufen werden.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Energiedatenanalyse</span>"
    ]
  },
  {
    "objectID": "skript/energiedatenanalyse.html#hintergrund-stromspeicher",
    "href": "skript/energiedatenanalyse.html#hintergrund-stromspeicher",
    "title": "1  Energiedatenanalyse",
    "section": "7.2 Hintergrund: Stromspeicher",
    "text": "7.2 Hintergrund: Stromspeicher\nStromspeicher speichern die Stromerzeugung in Überschussphasen, um die Energie in Phasen der Unterdeckung wieder abzugeben. Verschiedene Arten von Stromspeichern und ihre Einsatzgebiete werden im folgenden Video vorgestellt. Die Speichertypen unterscheiden sich grundlegend hinsichtlich ihrer Kapazität sowie der Lade- bzw. Entladeleistung.\n\n\nEnergietechnik. 14 Energiespeicherung. 14.02 Kennzahlen von Henrik te Heesen ist lizensiert unter CC BY-SA 3.0 und abrufbar auf YouTube. 2020\n\n\n\n\n\n\n\nDefinition 7.1: Ausgewählte Kenngrößen von Stromspeichern\n\n\n\n\n\nNominale Speicherkapazität: Energiemenge, die dem Stromspeicher entnommen werden kann.\nNutzbare Speicherkapazität: Beschädigungsfrei nutzbarer Anteil der nominalen Speicherkapazität.\nEntladetiefe (Depth of Discharge, DoD): Differenz zwischen maximal und minimal erlaubten Ladezustand.\nLadezustand (State of Charge, SoC): Verhältnis der aktuell gespeicherten Energie zur nominalen Kapazität, i. d. R. in Prozent angegeben.\nEffizienz: Wirkungsgrad bei der Speicherung (Be- und Entladen und Speicherverluste wie Selbstentladung)\n\nWeitere Kenngrößen werden im folgenden Video vorgestellt:\n\nEnergietechnik. 14 Energiespeicherung. 14.03 Kenngrößen und Begriffsdefinitionen von Henrik te Heesen ist lizensiert unter CC BY-SA 3.0 und abrufbar auf YouTube. 2020",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Energiedatenanalyse</span>"
    ]
  },
  {
    "objectID": "skript/energiedatenanalyse.html#speichergröße-berechnen",
    "href": "skript/energiedatenanalyse.html#speichergröße-berechnen",
    "title": "1  Energiedatenanalyse",
    "section": "7.3 Speichergröße berechnen",
    "text": "7.3 Speichergröße berechnen\nIm Folgenden werden Grundprinzipien der Speicherauslegung und die entsprechenden Verfahren zu ihrer Berechnung entwickelt. Grundlage aller Überlegungen ist die Restlastkurve. Werte kleiner als Null entsprechen einer erneuerbaren Überschussproduktion, Werte größer als Null einer durch Lastfolgekraftwerke oder Speicher zu bedienenden Netzlast. Die Restlast wird wie folgt bestimmt:\n\nerneuerbare = ['Biomasse [MWh]', 'Wasserkraft [MWh]', 'Wind Offshore [MWh]', 'Wind Onshore [MWh]', 'Photovoltaik [MWh]', 'Sonstige Erneuerbare [MWh]']\n\nrestlast = pd.DataFrame()\nrestlast[\"Netzlast [MWh]\"] = verbrauch[\"Gesamt (Netzlast) [MWh]\"].copy() \nrestlast[\"Erneuerbare [MWh]\"] = erzeugung[erneuerbare].sum(axis = \"columns\").copy()\nrestlast[\"Restlast [MWh]\"] = restlast[\"Netzlast [MWh]\"] - restlast[\"Erneuerbare [MWh]\"]\nrestlast = restlast[\"Restlast [MWh]\"]\n\nUm die Größenordnung der Berechnungen besser einordnen zu können, wird die Speichergröße zur bestehenden Pumpspeicherkapazität von 37,4 GWh ins Verhältnis gesetzt.\n\npumpspeicherkapazität_MWh = 37.4 * 1000\n\n \n\n\n\n\n\n\nTipp 7.1: Funktionsentwicklung mit Testdaten\n\n\n\n\n\nDie im Folgenden entwickelten Funktionen bieten in der Regel eine Option zur Ausgabe der Rechenergebnisse, die aber aufgrund der Länge der vorliegenden Datenreihe zur Restlast nicht sinnvoll darstellbar sind. Dadurch sind die Datenreihe selbst wie auch die Zwischen- und Endergebnisse durchgeführter Berechnungen sowie vorhandene Fehler nicht zu überblicken. Für die Funktionsentwicklung empfiehlt es sich daher, mit Testdaten zu arbeiten. Auf diese Weise werden Berechnungen schneller durchgeführt und Zwischenergebnisse und Ergebnisse können bei Bedarf zur Überprüfung ausgegeben werden. Die nachfolgenden Funktionen wurden mit zufällig generierten Testdaten entwickelt.\nIm folgenden Code-Block wird eine Restlastkurve aus zehn zufälligen Werten erzeugt. Durch Anpassen der Werte für a und b kann das Ergebnis gesteuert werden. In der Ausgabe ist die Summe der Datenreihe festgehalten. Ein negativer Wert bedeutet, dass über die simulierte Restlastkurve eine Überschussproduktion erneuerbarer Energien herrscht. Ein positiver Wert bedeutet, dass über die simulierte Restlastkurve die positive Restlast größer als die erneuerbare Überschussproduktion ist.\nIm Code-Block wird außerdem eine statische Datenreihe angelegt. Diese dient dazu, Testdaten festzuhalten, die zu Fehlern geführt haben. Dazu wird die Datenreihe random_data in Listenform ausgegeben, sodass diese durch Kopieren und Einfügen in die statische Datenreihe eingesetzt werden kann.\n\nimport random as rd\n\nrandom_data = []\nfor i in range(10):\n  random_data.append(rd.randint(a = -20, b = 20))\n\nrandom_data = pd.Series(random_data, dtype = 'float')\nprint(f\"random_data: {list(random_data)}\\nSumme random_data: {random_data.sum()}\\n\")\n\nstatic_data = pd.Series([8, -14, -7, 1, 3, -6, 5, -20, -2, 12], dtype = 'float')\n\nrandom_data: [18.0, -2.0, 11.0, 5.0, 3.0, -12.0, 3.0, 12.0, -7.0, -13.0]\nSumme random_data: 18.0\n\n\n\n\n\n\n\nÜberschuss oder Defizit erneuerbarer Energien\nDie erforderliche Größe des Stromspeichers ist einerseits abhängig von dem Verhältnis aus der Menge der erneuerbaren Überschussproduktion und der aus dem Speicher zu bedienenden Restlast. Andererseits spielt der Wirkungsgrad η (griechischer Buchstabe Eta) des Speichers beim Ein- und Ausspeichern von Strom eine Rolle.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nErneuerbare Stromproduktion: Überschuss oder Defizit?\n\nIst die Summe der erneuerbaren Überschussproduktion kleiner als die aus dem Speicher zu bedienende Restlast, entspricht die erforderliche Speichergröße der Summe der erneuerbaren Überschussproduktion.\n\n\nIst die Summe der erneuerbaren Überschussproduktion größer als die aus dem Speicher zu bedienende Restlast, entspricht die erforderliche Speichergröße der Summe der zu bedienenden Restlast.\n\n\nOb ein Überschuss oder ein Defizit erneuerbarer Stromproduktion vorliegt, kann am Vorzeichen der summierten Restlast abgelesen werden. Ein negatives Vorzeichen entspricht einem erneuerbaren Stromüberschuss, ein positives Vorzeichen einem erneuerbaren Stromdefizit.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nWirkungsgrad\n\nDer Einspeicherwirkungsgrad vermindert den verfügbaren Überschussstrom. Ist die Summe der erneuerbaren Überschussproduktion kleiner als die aus dem Speicher zu bedienende Restlast, kann der Speicher um den Einspeicherwirkungsgrad kleiner dimensioniert werden.\n\n\nDer Ausspeicherwirkungsgrad (inklusive Speicherverluste) erhöht die durch den Speicher zu bedienende Last. Ist die Summe der erneuerbaren Überschussproduktion größer als die aus dem Speicher zu bedienende Restlast, muss der Speicher um den Ausspeicherwirkungsgrad größer dimensioniert werden.\n\n\n\n\n\n\nBerechnung\nOb im Jahresgang Phasen erneuerbarer Überproduktion oder Phasen positiver Restlast vorherrschen, kann mit den folgenden Funktionen bestimmt werden.\n\nohne Wirkungsgradmit Wirkungsgrad\n\n\n\n# EE-Überschuss feststellen\n## Eingabe: data = pd.Series(data, dtype = 'float')\n## Verarbeitung: über die pd.Series wird die Summe gebildet\n## Ausgabe: zurückgegeben wird der Wahrheitswert von data.sum() &lt; 0\n\ndef prüfe_EE_Überschuss(data):\n  \n  return data.sum() &lt; 0\n\nprüfe_EE_Überschuss(restlast)\n\nnp.False_\n\n\n\n\n\n# EE-Überschuss feststellen, gegeben einen Ein- und Ausspeicherungswirkungsgrad\n## Eingabe: data = pd.Series(data, dtype = 'float'), einspeicherwirkungsgrad = 1, ausspeicherwirkungsgrad = 1\n## Verarbeitung: Werte kleiner 0 werden mit dem Einspeicherwirkungsgrad multipliziert\n## Verarbeitung: Werte größer 0 werden durch den Ausspeicherwirkungsgrad geteilt\n## Verarbeitung: über die pd.Series wird die Summe gebildet\n## Ausgabe: zurückgegeben wird der Wahrheitswert von data_wirkungsgrad_bereinigt.sum() &lt; 0\n\ndef prüfe_EE_Überschuss(data, einspeicherwirkungsgrad = 1, ausspeicherwirkungsgrad = 1):\n  data_wirkungsgrad_bereinigt = data.copy()\n\n  data_wirkungsgrad_bereinigt[data_wirkungsgrad_bereinigt &lt; 0] = data_wirkungsgrad_bereinigt[data_wirkungsgrad_bereinigt &lt; 0] * einspeicherwirkungsgrad\n  data_wirkungsgrad_bereinigt[data_wirkungsgrad_bereinigt &gt; 0] = data_wirkungsgrad_bereinigt[data_wirkungsgrad_bereinigt &gt; 0] / ausspeicherwirkungsgrad\n  \n  return data_wirkungsgrad_bereinigt.sum() &lt; 0\n\nprüfe_EE_Überschuss(restlast, einspeicherwirkungsgrad = 0.9, ausspeicherwirkungsgrad = 0.9)\n\nnp.False_\n\n\n\n\n\nWie aus der Grenzstromanalyse im Abschnitt Kapitel 6.6 bekannt, herrschte im Jahr 2023 kein Überschuss an erneuerbarer Stromproduktion.\n\n\n\nZyklik\nIm Zeitraum eines Jahres beeinflusst die Reihenfolge von Phasen mit erneuerbaren Überschüssen und mit positiver Restlast, wie groß ein Speicher ausgelegt werden muss.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nReihenfolgeabhängigkeit\n\nWird nur ein einziges Jahr betrachtet, entscheidet die Reihenfolge von erneuerbarer Über- und Unterproduktion, wie viel Strom eingespeichert werden kann. Im ungünstigsten Fall liegt im ersten Halbjahr eine positive Restlast vor (der Speicher ist aber noch leer) und im zweiten Halbjahr herrscht erneuerbare Überproduktion (die im zweiten Halbjahr nicht mehr abgenommen werden würde).\n\n\nDie Reihenfolgeabhängigkeit kann aufgelöst werden, indem zwei aufeinanderfolgende Jahresgänge betrachtet werden. Im ersten Jahr wird der Speicher leer ans Netz angeschlossen. Das zweite Jahr beginnt der Speicher gefüllt durch die Überschussproduktion aus dem Vorjahr.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nAnzahl Vollzyklen\n\nDie erforderliche Größe des Stromspeichers ist abhängig von der Verteilung der Restlast und der realisierten Anzahl Vollzyklen. Ein Vollzyklus bedeutet, dass ein Speicher vollständig geladen und wieder entladen wird.\n\n\nIm ungünstigsten Fall wird nur ein einziger Lade- / Entladezyklus gefahren. In diesem Fall entspricht die erforderliche Speichergröße der Summe der erneuerbaren Überschussproduktion.\n\n\nJe häufiger sich Lade- und Entladezyklen abwechseln, desto geringer ist die erforderliche Speichergröße. Diese entspricht der Summe der erneuerbaren Überschussproduktion geteilt durch die Anzahl der Vollzyklen.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nTeilzyklen\n\nAuch die Verteilung auftretender Teilzyklen reduziert die erforderliche Speichergröße.\n\n\nIst die Summe der erneuerbaren Überschussproduktion kleiner als die durch den Speicher zu bedienende Restlast, entspricht die erforderliche Speichergröße dem Minimum der kummulierten Summe der Restlast, wenn diese niemals größer 0 gesetzt wird (das Überschreiten wäre der Moment, in dem der Speicher leer ist).\n\n\nIst die Summe der erneuerbaren Überschussproduktion größer als die durch den Speicher zu bedienende Restlast, entspricht die erforderliche Speichergröße dem Maximum der kummulierten Summe der Restlast, wenn diese niemals kleiner 0 gesetzt wird (das Unterschreiten wäre der Moment, in dem der Speicher überdimensioniert ist).\n\n\n\n\n\n\nBerechnung\nDie Speichergröße wird aus dem Jahresgang der Restlast berechnet. Um nicht vom Zeitpunkt abhängig zu sein, an dem der Speicher an das Netz angeschlossen wird, wird der Datensatz zwei mal durchlaufen (auflösen der Reihenfolgeabhängigkeit). Die erforderliche Speichergröße wird mittels der kummulierten Summe der Restlast berechnet. Wenn die Summe der erneuerbaren Überschussproduktion kleiner als die Summe der durch den Speicher zu bedienenden Restlast ist, wird die kummulierte Summe niemals größer 0 gesetzt. Denn das Überschreiten dieser oberen Grenze wäre der Moment, in dem der Speicher leer ist und positive Restlast nicht mehr bedient werden kann. Ist dagegen die Summe der erneuerbaren Überschussproduktion größer als die Summe der durch den Speicher zu bedienenden Restlast, wird die kummulierte Summe niemals kleiner 0 gesetzt. Denn das Unterschreiten dieser Grenze wäre der Moment, in dem der Speicher überdimensioniert ist und Energie vorgehalten wird, die im Jahresgang niemals durch eine positive Restlast verbraucht wird.\n\nohne Wirkungsgradmit Wirkungsgrad\n\n\n\n# Speichergröße berechnen\n## Eingabe: data = pd.Series(data, dtype = 'float'), output = False\n## Verarbeitung: aufrufen der Funktion prüfe_EE_Überschuss, um zwischen oberer Grenze = 0 (Speicher ist leer) und unterer Grenze = 0 (Speicher ist überdimensioniert) zu unterscheiden\n## Verarbeitung: data wird zwei mal zu data_x2 verkettet. Für data_x2 wird die bei 0 gekappte kumulierte Summe berechnet und die Speichergröße berechnet.\n## Ausgabe: wenn output = False wird die Speichergröße (float) zurückgegeben, wenn output = True werden die Summe von data und die Speichergröße mit print() ausgegeben\n\ndef berechne_speichergröße(data, output = False):\n\n  data_x2 = pd.concat([data, data])\n\n  überschuss = prüfe_EE_Überschuss(data)\n  \n  if überschuss:\n    \n    # gekappte kumulierte Summe berechnen\n    capped_cumsum = []\n    summe = 0\n\n    for i in data_x2:\n      summe += i \n\n      # Untergrenze prüfen\n      if summe &lt; 0:\n        summe = 0\n      \n      capped_cumsum.append(summe)\n\n    speichergröße = max(capped_cumsum)\n  \n  else:\n\n    # gekappte kumulierte Summe berechnen\n    capped_cumsum = []\n    summe = 0\n\n    for i in data_x2:\n      summe += i\n\n      # Obergrenze prüfen\n      if summe &gt; 0:\n        summe = 0\n      \n      capped_cumsum.append(summe)\n\n    speichergröße = abs(min(capped_cumsum))\n\n  if output: # output = True\n\n    print(f\"\\nSumme data: {data.sum()}\\nSpeichergröße: {speichergröße}\")\n    \n  else: # output = False\n    return speichergröße\n  \nspeicher_2023 = berechne_speichergröße(restlast, output = False)\n\nprint(f\"erforderliche Speichergröße 2023: {speicher_2023:,.1f} MWh\\nDies entspricht {speicher_2023 / pumpspeicherkapazität_MWh:,.1f} Pumpspeicheräquivalenten.\")\n\nerforderliche Speichergröße 2023: 119,667.0 MWh\nDies entspricht 3.2 Pumpspeicheräquivalenten.\n\n\n\n\n\n# Speichergröße berechnen\n## Eingabe: data = pd.Series(data, dtype = 'float'), einspeicherwirkungsgrad = 1, ausspeicherwirkungsgrad = 1, output = False\n## Verarbeitung: aufrufen der Funktion prüfe_EE_Überschuss, um zwischen oberer Grenze = 0 (Speicher ist leer) und unterer Grenze = 0 (Speicher ist überdimensioniert) zu unterscheiden\n## Verarbeitung: data wird zwei mal zu data_x2 verkettet. Für data_x2 wird die bei 0 gekappte kumulierte Summe berechnet und die Speichergröße berechnet.\n## Ausgabe: wenn output = False wird die Speichergröße (float) zurückgegeben, wenn output = True werden die Summe von data und die Speichergröße mit print() ausgegeben\n\ndef berechne_speichergröße(data, einspeicherwirkungsgrad = 1, ausspeicherwirkungsgrad = 1, output = False):\n\n  data_x2 = pd.concat([data, data])\n\n  überschuss = prüfe_EE_Überschuss(data, einspeicherwirkungsgrad, ausspeicherwirkungsgrad)\n  \n  if überschuss:\n    \n    # gekappte kumulierte Summe berechnen\n    capped_cumsum = []\n    summe = 0\n\n    for i in data_x2:\n      if i &lt; 0:\n        summe += i * einspeicherwirkungsgrad\n      else:\n        summe += i / ausspeicherwirkungsgrad\n\n      # Untergrenze prüfen\n      if summe &lt; 0:\n        summe = 0\n      \n      capped_cumsum.append(summe)\n\n    speichergröße = max(capped_cumsum)\n  \n  else: # Unterproduktion\n\n    # gekappte kumulierte Summe berechnen\n    capped_cumsum = []\n    summe = 0\n\n    for i in data_x2:\n      if i &lt; 0:\n        summe += i * einspeicherwirkungsgrad\n      else:\n        summe += i / ausspeicherwirkungsgrad\n\n      # Obergrenze prüfen\n      if summe &gt; 0:\n        summe = 0\n      \n      capped_cumsum.append(summe)\n\n    speichergröße = abs(min(capped_cumsum))\n\n  if output: # output = True\n\n    print(f\"\\nSumme data: {data.sum()}\\nSpeichergröße: {speichergröße}\")\n\n  else: # output = False\n    return speichergröße\n\nspeicher_2023 = berechne_speichergröße(restlast, einspeicherwirkungsgrad = 0.9, ausspeicherwirkungsgrad = 0.9, output = False)\n\nprint(f\"erforderliche Speichergröße 2023: {speicher_2023:,.1f} MWh\\nDies entspricht {speicher_2023 / pumpspeicherkapazität_MWh:,.1f} Pumpspeicheräquivalenten.\")   \n\nerforderliche Speichergröße 2023: 102,674.5 MWh\nDies entspricht 2.7 Pumpspeicheräquivalenten.\n\n\n\n\n\n\n\nJahresgang des Speichers\nNachdem die Speichergröße bestimmt wurde, kann der Jahresgang des Speichers für das erste und das zweite Jahr berechnet sowie grafisch dargestellt werden. Der Jahresgang des Speichers für das zweite Jahr ist das stabile Gleichgewicht, mit dem eine gegebene Restlastkurve beliebig oft durchlaufen werden kann.\n\nEingabe: Der Funktion wird eine Restlastkurve übergeben. Außerdem kann eine Speichergröße übergeben werden, andernfalls wird diese durch Aufruf der Funktion berechne_speichergröße() ermittelt.\nVerarbeitung: Beginnend mit einem leeren Speicher wird die Restlastdatenreihe zwei mal elementweise durchlaufen. Negative Werte werden in den Speicher übertragen, bis die Speicherkapazität erreicht wurde. Positive Werte werden dem Speicher entnommen, bis der Ladestand des Speichers Null beträgt. In der um Ein- und Ausspeicherwirkungsgrade erweiterten Funktion werden eingespeicherte Werte mit dem Einspeicherwirkungsgrad (0.9) multipliziert und ausgespeicherte Werte durch den Ausspeicherwirkungsgrad (0.9) geteilt.\nAusgabe: Die Funktion gibt, wenn output = False ist, ein Tupel zurück. An Position 0 ist die Speichergröße gespeichert, an Position 1 der Jahresgang in Jahr 1 als pd.Series, an Position 2 der Jahresgang in Jahr 2 als pd.Series. Die Jahresgänge werden im Folgenden Panel grafisch dargestellt. Wenn ‘output = True’, werden die kumulierte Summe der Restlast und die Speichergröße sowie die übergebene Restlastkurve, die Ladestände und freie Kapazität des Speichers im Jahresgang für Jahr 1 und Jahr 2 mit print() ausgegeben - dies ist in der Regel nur für Testdaten sinnvoll.\n\n\nohne WirkungsgradPlot ohne WirkungsgradCode für den Plot ohne Wirkungsgradmit WirkungsgradPlot mit WirkungsgradCode für den Plot mit Wirkungsgrad\n\n\n\n# Jahresgang des Speichers berechnen\n## Eingabe: data = pd.Series(data, dtype = 'float'), speichergröße = -1, output = False\n## Verarbeitung: Wenn speichergröße = -1 wird die Speichergröße mit der Funktion berechne_speichergröße(data) ermittelt\n## Verarbeitung: data wird zwei mal zu data_x2 verkettet.\n## Verarbeitung: Anhand der Speichergröße werden der Ladestand und die freie Kapazität des Speichers für alle Werte von data für Jahr1 und alle Folgejahre berechnet.\n## Ausgabe: Wenn output False ist, wird ein Tupel aus speichergröße (float), Ladestand Jahr1 (pd.Series), Ladestand Jahr2 (pd.Series) zurückgegeben.\n## Ausgabe: Wenn output True, werden die kumulierte Summe der Restlast, die Speichergröße, die Restlastkurve, die Ladestände und freie Kapazität des Speichers im Jahresgang für Jahr 1 und Jahr 2 mit ausgegeben\n\ndef jahresgang_speicher_berechnen(data, speichergröße = -1, output = False):\n\n  data_x2 = pd.concat([data, data])\n\n  if speichergröße == -1:\n    speichergröße = berechne_speichergröße(data) \n\n# Jahresgang des Speichers berechnen\n  jahresgang_speicher = []\n  ladestand_speicher = []\n  freie_speicherkapazität = speichergröße # der speicher ist leer\n  for i in data_x2:\n\n    if (speichergröße - freie_speicherkapazität) - i &lt; 0: # last ohne vorherige Einspeicherung kann nicht bedient werden\n      freie_speicherkapazität = speichergröße\n\n    elif freie_speicherkapazität + i &lt; 0: # wenn der Speicher voll ist, muss Überschuss verworfen werden.\n      freie_speicherkapazität = 0\n      \n    else: # Ein-/Ausspeicherung\n      freie_speicherkapazität += i\n\n    jahresgang_speicher.append(freie_speicherkapazität)\n    ladestand_speicher.append(speichergröße - freie_speicherkapazität)\n\n  if output: # output = True\n\n    dataset = pd.DataFrame({'Restlast': data, 'Ladestand Jahr1': ladestand_speicher[ : len(jahresgang_speicher) // 2 ], 'freie Kapazität Jahr1': jahresgang_speicher[ : len(jahresgang_speicher) // 2 ], 'Ladestand Folgejahre': ladestand_speicher[ len(jahresgang_speicher) // 2 : ], 'freie Kapazität Folgejahre': jahresgang_speicher[ len(jahresgang_speicher) // 2 : ]})\n\n    print(f\"\\nSumme data: {data.sum()}\\nSpeichergröße: {speichergröße}\")\n    print(dataset)\n\n  else: # output = False\n    return speichergröße, pd.Series(ladestand_speicher[ : len(jahresgang_speicher) // 2 ]), pd.Series(ladestand_speicher[ len(jahresgang_speicher) // 2 : ])\n\nspeicher_2023 = jahresgang_speicher_berechnen(restlast, output = False)\n\n\n\n\n\n\n\n\nRestlast 2023 und Jahresgang eines Speichers mit Wirkungsgrad 1\n\n\n\n\n\n\n\n# Daten einlesen\njahresgang_speicher_jahr1 = speicher_2023[1]\njahresgang_speicher_jahr2 = speicher_2023[2]\n\n# xticks erzeugen\nmonate_index = erzeugung[~erzeugung[\"Datum von\"].dt.month.duplicated()].index\nmonatsnamen = erzeugung[\"Datum von\"].iloc[monate_index].dt.strftime(\"%B\") \n\n# Grafik mit drei subplots erzeugen\nfont_size = 10\n\nfig, (ax1, ax2, ax3) = plt.subplots(3, 1, figsize = (7.5, 6), height_ratios = [2, 1, 1], sharex = True, layout = 'tight')\nplt.suptitle('Restlast 2023 und Jahresgang eines Speichers mit Wirkungsgrad 1')\nplt.xticks(monate_index, monatsnamen, rotation = 45);\nplt.minorticks_off()\nplt.setp([ax1, ax2, ax3], xlim = (restlast.index.min() - len(restlast.index) / 100, restlast.index.max() * 1.01))\nplt.setp([ax2, ax3], ylim = (0, max(max(jahresgang_speicher_jahr1), max(jahresgang_speicher_jahr2)) * 1.1))\n\n## plot restlast\nax1.plot(restlast, label = \"Restlast\")\nax1.grid()\nax1.set_ylabel('MWh')\nax1.legend()\n\n## plot jahresgang_speicher_jahr1\nax2.plot(jahresgang_speicher_jahr1, color = 'black', linestyle = '-', label = 'Stromspeicher Jahr 1')\nax2.grid()\nax2.set_ylabel('MWh')\nax2.legend()\n\n## plot jahresgang_speicher_jahr2\nax3.plot(jahresgang_speicher_jahr2, color = 'black', linestyle = '-', label = 'Stromspeicher Jahr 2')\nax3.tick_params(axis = 'x', rotation = 45)\nax3.set_ylabel('MWh')\nax3.grid()\nax3.legend()\n\nplt.show()\n\n\n\n\n# Jahresgang des Speichers berechnen\n## Eingabe: data = pd.Series(data, dtype = 'float'), speichergröße = -1, einspeicherwirkungsgrad = 1, ausspeicherwirkungsgrad = 1, output = False\n## Verarbeitung: Wenn speichergröße = -1 wird die Speichergröße mit der Funktion berechne_speichergröße(data) ermittelt\n## Verarbeitung: data wird zwei mal zu data_x2 verkettet.\n## Verarbeitung: Anhand der Speichergröße werden der Ladestand und die freie Kapazität des Speichers für alle Werte von data für Jahr1 und alle Folgejahre berechnet.\n## Ausgabe: Wenn output False ist, wird ein Tupel aus speichergröße (float), Ladestand Jahr1 (pd.Series), Ladestand Jahr2 (pd.Series) zurückgegeben.\n## Ausgabe: Wenn output True, werden die kumulierte Summe der Restlast, die Speichergröße, die Restlastkurve, die Ladestände und freie Kapazität des Speichers im Jahresgang für Jahr 1 und Jahr 2 mit ausgegeben\n\ndef jahresgang_speicher_berechnen(data, speichergröße = -1, einspeicherwirkungsgrad = 1, ausspeicherwirkungsgrad = 1, output = False):\n\n  data_x2 = pd.concat([data, data])\n\n  if speichergröße == -1:\n    speichergröße = berechne_speichergröße(data, einspeicherwirkungsgrad, ausspeicherwirkungsgrad) \n\n  jahresgang_speicher = []\n  ladestand_speicher = []\n  freie_speicherkapazität = speichergröße # der speicher ist leer \n  for i in data_x2:\n\n    if i &gt; 0: # Restlast\n\n      # last ohne entsprechende vorherige Einspeicherung kann nicht vollständig bedient werden, der Speicher ist dann leer\n      if (speichergröße - freie_speicherkapazität) - i / ausspeicherwirkungsgrad &lt; 0:\n        freie_speicherkapazität = speichergröße\n\n      else: # Ausspeicherung\n        freie_speicherkapazität += i / ausspeicherwirkungsgrad # hier kann zu viel ausgespeichert werden\n        if freie_speicherkapazität &gt; speichergröße:\n          freie_speicherkapazität = speichergröße\n    \n    else: # i &lt;= 0 EE-Überschuss\n      \n      # wenn der Speicher voll ist, muss Überschuss verworfen werden.\n      if freie_speicherkapazität + i * einspeicherwirkungsgrad &lt; 0: \n        freie_speicherkapazität = 0\n      \n      else: # Einspeicherung\n        freie_speicherkapazität += i * einspeicherwirkungsgrad\n\n    jahresgang_speicher.append(freie_speicherkapazität)\n    ladestand_speicher.append(speichergröße - freie_speicherkapazität)\n\n  if output: # output = True\n\n    dataset = pd.DataFrame({'Restlast': data, 'Ladestand Jahr1': ladestand_speicher[ : len(jahresgang_speicher) // 2 ], 'freie Kapazität Jahr1': jahresgang_speicher[ : len(jahresgang_speicher) // 2 ], 'Ladestand Folgejahre': ladestand_speicher[ len(jahresgang_speicher) // 2 : ], 'freie Kapazität Folgejahre': jahresgang_speicher[ len(jahresgang_speicher) // 2 : ]})\n\n    print(f\"\\nSumme data: {data.sum()}\\nSpeichergröße: {speichergröße}\")\n    print(dataset)\n\n  else: # output = False\n    return speichergröße, pd.Series(ladestand_speicher[ : len(jahresgang_speicher) // 2 ]), pd.Series(ladestand_speicher[ len(jahresgang_speicher) // 2 : ])\n\nspeicher_2023_wirkungsgrad_90_90 = jahresgang_speicher_berechnen(restlast, einspeicherwirkungsgrad = 0.9, ausspeicherwirkungsgrad = 0.9, output = False)\n\n\n\n\n\n\n\n\nRestlast 2023 und Jahresgang eines Speichers mit Ein- und Ausspeicherwirkungsgrad 0.9\n\n\n\n\n\n\n\n# Daten einlesen\njahresgang_speicher_jahr1 = speicher_2023_wirkungsgrad_90_90[1]\njahresgang_speicher_jahr2 = speicher_2023_wirkungsgrad_90_90[2]\n\n# xticks erzeugen\nmonate_index = erzeugung[~erzeugung[\"Datum von\"].dt.month.duplicated()].index\nmonatsnamen = erzeugung[\"Datum von\"].iloc[monate_index].dt.strftime(\"%B\") \n\n# Grafik mit drei subplots erzeugen\nfont_size = 10\n\nfig, (ax1, ax2, ax3) = plt.subplots(3, 1, figsize = (7.5, 6), height_ratios = [2, 1, 1], sharex = True, layout = 'tight')\nplt.suptitle('Restlast 2023 und Jahresgang eines Speichers mit Ein- und Ausspeicherwirkungsgrad 0.9')\nplt.xticks(monate_index, monatsnamen, rotation = 45);\nplt.minorticks_off()\nplt.setp([ax1, ax2, ax3], xlim = (restlast.index.min() - len(restlast.index) / 100, restlast.index.max() * 1.01))\nplt.setp([ax2, ax3], ylim = (0, max(max(jahresgang_speicher_jahr1), max(jahresgang_speicher_jahr2)) * 1.1))\n\n## plot restlast\nax1.plot(restlast, label = \"Restlast\")\nax1.grid()\nax1.set_ylabel('MWh')\nax1.legend()\n\n## plot jahresgang_speicher_jahr1\nax2.plot(jahresgang_speicher_jahr1, color = 'black', linestyle = '-', label = 'Stromspeicher Jahr 1')\nax2.grid()\nax2.set_ylabel('MWh')\nax2.legend()\n\n## plot jahresgang_speicher_jahr2\nax3.plot(jahresgang_speicher_jahr2, color = 'black', linestyle = '-', label = 'Stromspeicher Jahr 2')\nax3.tick_params(axis = 'x', rotation = 45)\nax3.set_ylabel('MWh')\nax3.grid()\nax3.legend()\n\nplt.show()\n\n\n\n\nDie benötigte Kapazität des Speichers ergibt sich aus den ereuerbaren Erzeugungsüberschüssen während der Weihnachtsfeiertage. Diese Kapazitäten werden im übrigen Jahr kaum genutzt, der Speicher ist die meiste Zeit des Jahres leer. Der Jahresgang für das erste und das zweite Jahr ist optisch identisch. Dies kann mit pd.Series1.equals(pd.Series2) leicht überprüft werden. Werden Ein- und Ausspeicherwirkungsgrade berücksichtigt, reduzieren sich die ein- und ausgespeicherte Energie und somit die erforderliche Speichergröße.\n\n\nZyklenzahl berechnen\nAnhand der Speichergröße und des Jahresgangs des Speichers kann die Zyklenzahl im ersten und in allen Folgejahren berechnet werden. Ein Zyklus entspricht der vollständigen Ladung und Entladung des Speichers bzw. einer entsprechenden Anzahl von Teilladezyklen. Die Zyklenzahl ergibt sich somit aus der Summe der im Jahresgang des Speichers ein- bzw. ausgespeicherten Energie, die durch die Speichergröße und durch 2 geteilt wird.\n\nEingabe: Der Funktion kann ein Tupel bestehend aus einer Speichergröße an Position 0 und Speicherjahresgängen für Jahr 1 und Jahr 2 an den Positionen 1 und 2 übergeben werden. Andernfalls werden diese durch Aufruf der Funktion jahresgang_speicher_berechnen ermittelt (ohne bzw. mit Ein- und Ausspeicherwirkungsgrad).\nVerarbeitung: Um die ein- und ausgespeicherte Energie zu bestimmen, wird für die Speicherjahresgänge mit der Methode pd.Series.diff() elementweise die Differenz jedes Werts zu seinem Vorgänger gebildet (gleitende Differenz). Beispielsweise ist für die Zahlenreihe 1, 4, -6, 2 die elementweise Differenz NaN, 3, -10, 8. Da der erste Wert keinen Vorgänger hat, ist die Differenz NaN. Deshalb wird für die gleitende Differenzberechnung dem Jahresgang in Jahr 1 eine Null vorangestellt (weil der Speicher leer ans Netz geht), dem Jahresgang in Jahr 2 der letzte Wert aus Jahr 1 (weil der Speicher mit diesem Ladestand ins zweite Jahr geht). Die Zahlreihe für Jahr 2 sähe beispielsweise so aus: 2, 1, 4, -6, 2. Die elementweise Differenz wäre: NaN, -1, 3, -10, 8. Anschließend werden die Werte absolut gesetzt und summiert. Die Anweisung lautet somit: pd.Series.diff().abs().sum(). Zur Ermittlung der Zyklenzahl wird die Summe der ein- und ausgespeicherten Energie durch die Speichergröße und durch 2 geteilt.\nAusgabe: Die Funktion gibt, wenn output = False ist, ein Tupel der Zyklenzahl für Jahr 1 und Jahr 2 zurück. Ist output = True, erfolgt die Ausgabe mit print()\n\n\nohne Wirkungsgradmit Wirkungsgrad\n\n\n\n# Zyklenzahl berechnen\n## Eingabe: data = pd.Series(data, dtype = 'float'), output = False\n## Eingabe: Wenn die Eingabe ein Tupel {'Speichergröße': float, 'jahresgang_speicher_jahr1': pd.Series, 'jahresgang_speicher_jahr2': pd.Series} ist, wird die Zyklenzahl direkt berechnet.\n## Eingabe: Wenn die Eingabe data = pd.Series(data, dtype = 'float') ist, wird jahresgang_speicher_berechnen(data, speichergröße = -1, output = False) aufgerufen\n## Verarbeitung: Elementweise wird für Jahr 1 und Jahr 2 die Differenz aufeinanderfolgender Werte gebildet, absolut gesetzt und aufsummiert\n## Verarbeitung: Für die gleitende Differenzberechnung muss dem Jahresgang in Jahr 1 eine Null vorangestellt werden, dem Jahresgang in Jahr 2 der letzte Wert aus Jahr 1\n## Verarbeitung: Die Summe der Speicherladungen und -entladungen wird durch die Speichergröße und durch 2 geteilt.\n## Ausgabe: Zyklenzahl für Jahr 1 und Jahr 2 - wenn output = False als Rückgabewert (Tupel), wenn output = True mit print()\n\ndef zyklenzahl_berechnen(data, output = False):\n  \n  if type(data) is tuple: # Speichergröße und Jahresgänge wurden übergeben\n    speichergröße = data[0]\n    jahresgang_speicher_jahr1 = data[1]\n    jahresgang_speicher_jahr2 = data[2]\n  \n  else: # Restlast wurde übergeben\n    ergebnis = jahresgang_speicher_berechnen(data, speichergröße = -1, output = False)\n    speichergröße = ergebnis[0]\n    jahresgang_speicher_jahr1 = ergebnis[1]\n    jahresgang_speicher_jahr2 = ergebnis[2]\n  \n  # Jahresgang Jahr 1 eine Null voranstellen, Jahresgang Jahr 2 den letzten Wert aus Jahr 1\n  jahresgang_speicher_jahr1 = pd.concat([pd.Series(0), jahresgang_speicher_jahr1])\n  jahresgang_speicher_jahr2 = pd.concat([jahresgang_speicher_jahr1[ - 1: ], jahresgang_speicher_jahr2])\n\n  # Zyklenzahl berechnen\n  zyklenzahl_jahr1 = jahresgang_speicher_jahr1.diff().abs().sum() / (speichergröße * 2) # ein Zyklus = vollständiges Be- und Entladen --&gt; durch 2 teilen\n  zyklenzahl_jahr2 = jahresgang_speicher_jahr2.diff().abs().sum() / (speichergröße * 2) # ein Zyklus = vollständiges Be- und Entladen --&gt; durch 2 teilen\n  \n  if output:\n    print(f\"Zyklenzahl Jahr 1: {zyklenzahl_jahr1:,.2f}\\n\"\n          f\"Zyklenzahl Jahr 2: {zyklenzahl_jahr2:,.2f}\")\n  \n  else:\n    return zyklenzahl_jahr1, zyklenzahl_jahr2\n  \nzyklenzahl_berechnen(speicher_2023, output = True)\n\nZyklenzahl Jahr 1: 8.38\nZyklenzahl Jahr 2: 8.38\n\n\n\n\n\n# Zyklenzahl berechnen mit Wirkungsgrad\n## Eingabe: data = pd.Series(data, dtype = 'float'), einspeicherwirkungsgrad = 1, ausspeicherwirkungsgrad = 1, output = False\n## Eingabe: Wenn die Eingabe ein Tupel {'Speichergröße': float, 'jahresgang_speicher_jahr1': pd.Series, 'jahresgang_speicher_jahr2': pd.Series} ist, wird die Zyklenzahl direkt berechnet.\n## Eingabe: Wenn die Eingabe data = pd.Series(data, dtype = 'float') ist, wird jahresgang_speicher_berechnen(data, speichergröße = -1, einspeicherwirkungsgrad = 1, ausspeicherwirkungsgrad = 1, output = False) aufgerufen\n## Verarbeitung: Elementweise wird für Jahr 1 und Jahr 2 die Differenz aufeinanderfolgender Werte gebildet, absolut gesetzt und aufsummiert\n## Verarbeitung: Für die gleitende Differenzberechnung muss dem Jahresgang in Jahr 1 eine Null vorangestellt werden, dem Jahresgang in Jahr 2 der letzte Wert aus Jahr 1\n## Verarbeitung: Die Summe der Speicherladungen und -entladungen wird durch die Speichergröße und durch 2 geteilt.\n## Ausgabe: Zyklenzahl für Jahr 1 und Jahr 2 - wenn output = False als Rückgabewert (Tupel), wenn output = True mit print()\n\ndef zyklenzahl_berechnen(data, einspeicherwirkungsgrad = 1, ausspeicherwirkungsgrad = 1, output = False):\n  \n  if type(data) is tuple: # Speichergröße und Jahresgänge wurden übergeben\n    speichergröße = data[0]\n    jahresgang_speicher_jahr1 = data[1]\n    jahresgang_speicher_jahr2 = data[2]\n  \n  else: # Restlast wurde übergeben\n    ergebnis = jahresgang_speicher_berechnen(data, speichergröße = -1, einspeicherwirkungsgrad = einspeicherwirkungsgrad, ausspeicherwirkungsgrad = ausspeicherwirkungsgrad, output = False)\n    speichergröße = ergebnis[0]\n    jahresgang_speicher_jahr1 = ergebnis[1]\n    jahresgang_speicher_jahr2 = ergebnis[2]\n  \n  # Jahresgang Jahr 1 eine Null voranstellen, Jahresgang Jahr 2 den letzten Wert aus Jahr 1\n  jahresgang_speicher_jahr1 = pd.concat([pd.Series(0), jahresgang_speicher_jahr1])\n  jahresgang_speicher_jahr2 = pd.concat([jahresgang_speicher_jahr1[ - 1: ], jahresgang_speicher_jahr2])\n\n  # Zyklenzahl berechnen  \n  zyklenzahl_jahr1 = jahresgang_speicher_jahr1.diff().abs().sum() / (speichergröße * 2) # ein Zyklus = vollständiges Be- und Entladen --&gt; durch 2 teilen\n  zyklenzahl_jahr2 = jahresgang_speicher_jahr2.diff().abs().sum() / (speichergröße * 2) # ein Zyklus = vollständiges Be- und Entladen --&gt; durch 2 teilen\n  \n  if output:\n    print(f\"Zyklenzahl Jahr 1: {zyklenzahl_jahr1:,.2f}\\n\"\n          f\"Zyklenzahl Jahr 2: {zyklenzahl_jahr2:,.2f}\")\n  \n  else:\n    return zyklenzahl_jahr1, zyklenzahl_jahr2\n  \nzyklenzahl_berechnen(restlast, einspeicherwirkungsgrad = 0.9, ausspeicherwirkungsgrad = 0.9, output = True)\n\nZyklenzahl Jahr 1: 8.79\nZyklenzahl Jahr 2: 8.79\n\n\n\n\n\nAufgrund der geringen erneuerbaren Erzeugungsschüsse im Jahr 2023 ist die Zyklenzahl in Jahr 1 und Jahr 2 identisch. Wenn der Wirkungsgrad berücksichtigt wird, steigt die Zyklenzahl, weil der Speicher kleiner dimensioniert ist.\n\n\n\nKappung\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nKappung von Erzeugungsspitzen\n\nDie Kappung von Erzeugungsspitzen ist eine Möglichkeit, die benötigte Speichergröße zu reduzieren. Die Kappung der Einspeicherung führt zu einer besseren Auslastung der Speicherkapazität und einer höheren Zyklenzahl.\n\n\nIm oberen Beispiel wird die Speichergröße entsprechend der maximalen erneuerbaren Überschussproduktion ausgelegt. Der Speicher erreicht damit 1,5 Zyklen.\n\n\nIm unteren Beispiel wird der Speicher kleiner dimensioniert. Der Speicher erreicht 2 Zyklen.\n\n\n\n\n\n\nBerechnung\nAuf Grundlage des Jahresgangs des Speichers kann der Effekt der Kappung von Erzeugungsspitzen auf die eingespeicherte Strommenge und die erreichte Zyklenzahl des Stromspeichers berechnet werden. Dafür werden der Jahresgang des Speichers für verschiedene reduzierte Speichergrößen, die so erreichte Zyklenzahl und die Menge nicht eingespeicherten Stroms berechnet.\n\nEingabe: Der Funktion ist eine Restlastdatenreihe als pd.Series und optional eine Liste reduzierter Speichergrößen, ausgedrückt als relative Bruchteile von 1, zu übergeben. Wird keine Liste übergeben, erfolgt die Berechnung für die relativen Speichergrößen [0.9, 0.8, 0.7, 0.6, 0.5].\nVerarbeitung: Für die Restlast werden durch Aufruf der Funktion jahresgang_speicher_berechnen die ungekappte Speichergröße und Jahresgänge in Jahr 1 und in Jahr 2 berechnet. Anschließend wird durch Aufruf der Funktion zyklenzahl_berechnen die erreichte Zyklenzahl bestimmt. Anhand der Jahresgänge wird die eingespeicherte Strommenge berechnet. Dazu wird mit der Methode pd.Series.diff() elementweise die Differenz jedes Werts zu seinem Vorgänger gebildet (gleitende Differenz). Wie auch bei der Berechnung der Zyklenzahl wird dazu dem Jahresgang in Jahr 1 eine Null vorangestellt, dem Jahresgang in Jahr 2 der letzte Wert aus Jahr 1. Die eingespeicherte Strommenge ist die Summe aller positiven Werte dieser Reihe. Negative Werte bedeuten eine Reduzierung des Ladestands zwischen zwei Zeitpunkten, zeigen also Phasen der Ausspeicherung an. Deshalb werden negative Werte mit der Methode .clip Null gesetzt. Die Anweisung lautet: pd.Series.diff().clip(lower = 0).sum().\nDiese Schritte werden für alle übergebenen Elemente in der Variablen neue_speichergrößen wiederholt. Dazu wird die Speichergröße ohne Kappung mit jeweils einer der relativen Speichergrößen multipliziert und die erreichte Zyklenzahl sowie die eingespeicherte Strommenge berechnet. Aus der Differenz der eingespeicherten Strommenge für jede neue Speichergröße zum Basisjahr wird die gekappte Strommenge bestimmt.\nAusgabe: Wenn output = False, wird ein DataFrame mit drei Spalten zurückgegeben. Die Spalte mit Index 0 enthält die relative Speichergröße, Die Spalten 1 und 2 die gekappten Strommengen in Jahr 1 und Jahr 2. Wenn’ output = True’ wird dieser DataFrame mit print() ausgegeben. Zusätzlich wird ein fünfspaltiger DataFrame mit den Zwischenergebnissen (inklusive Basisjahr in Zeile 0) mit print() ausgegeben. Dieser enthält in der Spalte mit Index 0 die absolute Speichergröße sowie in den folgenden Spalten die eingespeicherte Strommenge in Jahr 1 (Spalte mit Index 1), die Zyklenzahl in Jahr 1 (Spalte mit Index 2), die eingespeicherte Strommenge in Jahr 2 (Spalte mit Index 3), die Zyklenzahl in Jahr 2 (Spalte mit Index 4).\n\n\nohne Wirkungsgradmit Wirkungsgrad\n\n\n\n# Kappung berechnen: Wie viel EE wird verworfen, wenn die Speichergröße begrenzt wird?\n## Eingabe: Restlastkurve data = pd.Series(data, dtype = 'float', neue_speichergrößen = [0.9, 0.8, 0.7, 0.6, 0.5], output = False)\n## Verarbeitung: Für data werden mit der Funktion jahresgang_speicher_berechnen() die Speichergröße und die Jahresgänge Jahr 1 und Jahr 2 ohne zusätzliche Kappung bestimmt\n## Verarbeitung: Für data wird mit der Funktion zyklenzahl_berechnen() die Zyklenzahl in Jahr 1 und Jahr 2 ohne zusätzliche Kappung bestimmt\n## Verarbeitung: Anhand der Jahresgänge wird die eingespeicherte Strommenge ohne zusätzliche Kappung bestimmt\n## Verarbeitung: Die Verarbeitungsschritte werden für alle übergebenen Elemente in der Variablen neue_speichergrößen wiederholt\n## Verarbeitung: Die Speichergröße der Basisrestlastkurve data wird dafür mit den in neue_speichergrößen übergebenen Werten multipliziert\n## Verarbeitung: Aus der Differenz der eingespeicherten Strommengen für jede neue Speichergröße zum Basisjahr wird die gekappte Strommenge bestimmt\n## Ausgabe: Wenn output = False wird ein DataFrame mit drei Spalten zurückgegeben. Die Spalte mit Index 0 enthält die relative Speichergröße, Die Spalten 1 und 2 die gekappten Strommengen in Jahr 1 und Jahr 2.\n## Ausgabe: Wenn output = True wird der dreispaltige DataFrame mit print() ausgegeben.\n## Ausgabe: Zusätzlich wird ein fünfspaltiger DataFrame mit den Zwischenergebnissen (inklusive Basisjahr) mit print() ausgegeben.\n## Ausgabe: (Indexangaben): 0 = absolute Speichergröße, 1 = eingespeicherte Strommenge Jahr 1, 2 = Zyklenzahl Jahr 1, 3 = eingespeicherte Strommenge Jahr 2, 4 = Zyklenzahl Jahr 2\n\ndef effekt_kappung_berechnen(data, neue_speichergrößen = [0.9, 0.8, 0.7, 0.6, 0.5], output = False):\n\n  # Speichergröße im Basisjahr bestimmen\n  ergebnis = jahresgang_speicher_berechnen(data, speichergröße = -1, output = False)\n  speichergröße0 = ergebnis[0]\n  jahresgang_speicher_jahr1 = ergebnis[1]\n  jahresgang_speicher_jahr2 = ergebnis[2]\n\n  # Zyklenzahl im Basisjahr bestimmen, Tupel übergeben\n  zyklen = zyklenzahl_berechnen(ergebnis, output = False)\n  zyklen_jahr1 = zyklen[0]\n  zyklen_jahr2 = zyklen[1]\n  \n  # Jahresgang Jahr 1 eine Null voranstellen, Jahresgang Jahr 2 den letzten Wert aus Jahr 1\n  jahresgang_speicher_jahr1 = pd.concat([pd.Series([0]), jahresgang_speicher_jahr1])\n  jahresgang_speicher_jahr2 = pd.concat([jahresgang_speicher_jahr1[ - 1: ], jahresgang_speicher_jahr2])\n\n  # eingespeicherte Strommenge im Basisjahr bestimmen\n  einspeicherung_jahr1 = jahresgang_speicher_jahr1.diff().clip(lower = 0).sum()\n  einspeicherung_jahr2 = jahresgang_speicher_jahr2.diff().clip(lower = 0).sum()\n\n  # Ergebnisse in DataFrame speichern\n  dataframe = pd.DataFrame({'Speichergröße': [speichergröße0], 'Einspeicherung Jahr1': [einspeicherung_jahr1], 'Zyklen Jahr1': zyklen_jahr1, 'Einspeicherung Jahr2': [einspeicherung_jahr2], 'Zyklen Jahr2': zyklen_jahr2})\n  \n  # eingespeicherte Strommenge bei alternativen Speichergrößen bestimmen\n  count = 1\n\n  for i in range(len(neue_speichergrößen)):\n\n    speichergröße_neu = speichergröße0 * neue_speichergrößen[i]\n    \n    ergebnis = jahresgang_speicher_berechnen(data, speichergröße = speichergröße_neu, output = False)\n    jahresgang_speicher_jahr1 = ergebnis[1]\n    jahresgang_speicher_jahr2 = ergebnis[2]\n\n    # Zyklenzahl im Basisjahr bestimmen, Tupel übergeben\n    zyklen = zyklenzahl_berechnen(ergebnis, output = False)\n    zyklen_jahr1 = zyklen[0]\n    zyklen_jahr2 = zyklen[1]\n\n    # Jahresgang Jahr 1 eine Null voranstellen, Jahresgang Jahr 2 den letzten Wert aus Jahr 1\n    jahresgang_speicher_jahr1 = pd.concat([pd.Series([0]), jahresgang_speicher_jahr1])\n    jahresgang_speicher_jahr2 = pd.concat([jahresgang_speicher_jahr1[ - 1: ], jahresgang_speicher_jahr2])\n\n    # eingespeicherte Strommenge mit neuer Speichergröße bestimmen\n    einspeicherung_jahr1 = jahresgang_speicher_jahr1.diff().clip(lower = 0).sum()\n    einspeicherung_jahr2 = jahresgang_speicher_jahr2.diff().clip(lower = 0).sum()\n\n    neue_Zeile = [speichergröße_neu, einspeicherung_jahr1, zyklen_jahr1, einspeicherung_jahr2, zyklen_jahr2]\n    dataframe.loc[count] = neue_Zeile\n  \n    count += 1\n  \n  # gekappte Menge berechnen data.sub(data[0]).drop(0)\n  gekappte_einspeicherung_jahr1 = dataframe['Einspeicherung Jahr1'].sub(dataframe['Einspeicherung Jahr1'][0]).abs().drop(0).reset_index(drop = True)\n  gekappte_einspeicherung_jahr2 = dataframe['Einspeicherung Jahr2'].sub(dataframe['Einspeicherung Jahr2'][0]).abs().drop(0).reset_index(drop = True)\n  dataset = pd.DataFrame({'relative Speichergröße': pd.Series(neue_speichergrößen), 'gekappte Einspeicherung Jahr1': gekappte_einspeicherung_jahr1, 'gekappte Einspeicherung Jahr2': gekappte_einspeicherung_jahr2})\n  \n  if output:\n\n    print(dataframe)\n    print(\"\\n\")\n    print(dataset)\n\n  else:\n    return dataset\n\neffekt_kappung_berechnen(restlast, output = True)\n\n   Speichergröße  Einspeicherung Jahr1  Zyklen Jahr1  Einspeicherung Jahr2  \\\n0       119667.0              1.00e+06          8.38              1.00e+06   \n1       107700.3              9.91e+05          9.20              9.91e+05   \n2        95733.6              9.79e+05         10.23              9.79e+05   \n3        83766.9              9.63e+05         11.49              9.63e+05   \n4        71800.2              9.39e+05         13.07              9.39e+05   \n5        59833.5              8.99e+05         15.03              8.99e+05   \n\n   Zyklen Jahr2  \n0          8.38  \n1          9.20  \n2         10.23  \n3         11.49  \n4         13.07  \n5         15.03  \n\n\n   relative Speichergröße  gekappte Einspeicherung Jahr1  \\\n0                     0.9                        11966.7   \n1                     0.8                        23933.4   \n2                     0.7                        40443.7   \n3                     0.6                        64377.1   \n4                     0.5                       103619.5   \n\n   gekappte Einspeicherung Jahr2  \n0                        11966.7  \n1                        23933.4  \n2                        40443.7  \n3                        64377.1  \n4                       103619.5  \n\n\n\n\n\n# Kappung berechnen: Wie viel EE wird verworfen, wenn die Speichergröße begrenzt wird?\n## Eingabe: Restlastkurve data = pd.Series(data, dtype = 'float', einspeicherwirkungsgrad = 1, ausspeicherwirkungsgrad = 1, neue_speichergrößen = [0.9, 0.8, 0.7, 0.6, 0.5], output = False)\n## Verarbeitung: Für data werden mit der Funktion jahresgang_speicher_berechnen() die Speichergröße und die Jahresgänge Jahr 1 und Jahr 2 ohne zusätzliche Kappung bestimmt\n## Verarbeitung: Für data wird mit der Funktion zyklenzahl_berechnen() die Zyklenzahl in Jahr 1 und Jahr 2 ohne zusätzliche Kappung bestimmt\n## Verarbeitung: Anhand der Jahresgänge wird die eingespeicherte Strommenge ohne zusätzliche Kappung bestimmt\n## Verarbeitung: Die Verarbeitungsschritte werden für alle übergebenen Elemente in der Variablen neue_speichergrößen wiederholt\n## Verarbeitung: Die Speichergröße der Basisrestlastkurve data wird dafür mit den in neue_speichergrößen übergebenen Werten multipliziert\n## Verarbeitung: Aus der Differenz der eingespeicherten Strommengen für jede neue Speichergröße zum Basisjahr wird die gekappte Strommenge bestimmt\n## Ausgabe: Wenn output = False wird ein DataFrame mit drei Spalten zurückgegeben. Die Spalte mit Index 0 enthält die relative Speichergröße, Die Spalten 1 und 2 die gekappten Strommengen in Jahr 1 und Jahr 2.\n## Ausgabe: Wenn output = True wird der dreispaltige DataFrame mit print() ausgegeben.\n## Ausgabe: Zusätzlich wird ein fünfspaltiger DataFrame mit den Zwischenergebnissen (inklusive Basisjahr) mit print() ausgegeben.\n## Ausgabe: (Indexangaben): 0 = absolute Speichergröße, 1 = eingespeicherte Strommenge Jahr 1, 2 = Zyklenzahl Jahr 1, 3 = eingespeicherte Strommenge Jahr 2, 4 = Zyklenzahl Jahr 2\n\ndef effekt_kappung_berechnen(data, einspeicherwirkungsgrad = 1, ausspeicherwirkungsgrad = 1, neue_speichergrößen = [0.9, 0.8, 0.7, 0.6, 0.5], output = False):\n\n  # Speichergröße im Basisjahr bestimmen\n  ergebnis = jahresgang_speicher_berechnen(data, speichergröße = -1, einspeicherwirkungsgrad = einspeicherwirkungsgrad, ausspeicherwirkungsgrad = ausspeicherwirkungsgrad, output = False)\n  speichergröße0 = ergebnis[0]\n  jahresgang_speicher_jahr1 = ergebnis[1]\n  jahresgang_speicher_jahr2 = ergebnis[2]\n\n  # Zyklenzahl im Basisjahr bestimmen, Tupel übergeben\n  zyklen = zyklenzahl_berechnen(ergebnis, einspeicherwirkungsgrad = einspeicherwirkungsgrad, ausspeicherwirkungsgrad = ausspeicherwirkungsgrad, output = False)\n  zyklen_jahr1 = zyklen[0]\n  zyklen_jahr2 = zyklen[1]\n  \n  # Jahresgang Jahr 1 eine Null voranstellen, Jahresgang Jahr 2 den letzten Wert aus Jahr 1\n  jahresgang_speicher_jahr1 = pd.concat([pd.Series([0]), jahresgang_speicher_jahr1])\n  jahresgang_speicher_jahr2 = pd.concat([jahresgang_speicher_jahr1[ - 1: ], jahresgang_speicher_jahr2])\n\n  # eingespeicherte Strommenge im Basisjahr bestimmen\n  einspeicherung_jahr1 = jahresgang_speicher_jahr1.diff().clip(lower = 0).sum()\n  einspeicherung_jahr2 = jahresgang_speicher_jahr2.diff().clip(lower = 0).sum()\n\n  # Ergebnisse in DataFrame speichern\n  dataframe = pd.DataFrame({'Speichergröße': [speichergröße0], 'Einspeicherung Jahr1': [einspeicherung_jahr1], 'Zyklen Jahr1': zyklen_jahr1, 'Einspeicherung Jahr2': [einspeicherung_jahr2], 'Zyklen Jahr2': zyklen_jahr2})\n  \n  # eingespeicherte Strommenge bei alternativen Speichergrößen bestimmen\n  count = 1\n\n  for i in range(len(neue_speichergrößen)):\n\n    speichergröße_neu = speichergröße0 * neue_speichergrößen[i]\n    \n    ergebnis = jahresgang_speicher_berechnen(data, speichergröße = speichergröße_neu, einspeicherwirkungsgrad = einspeicherwirkungsgrad, ausspeicherwirkungsgrad = ausspeicherwirkungsgrad, output = False)\n    jahresgang_speicher_jahr1 = ergebnis[1]\n    jahresgang_speicher_jahr2 = ergebnis[2]\n\n    # Zyklenzahl im Basisjahr bestimmen, Tupel übergeben\n    zyklen = zyklenzahl_berechnen(ergebnis, einspeicherwirkungsgrad = einspeicherwirkungsgrad, ausspeicherwirkungsgrad = ausspeicherwirkungsgrad, output = False)\n    zyklen_jahr1 = zyklen[0]\n    zyklen_jahr2 = zyklen[1]\n\n    # Jahresgang Jahr 1 eine Null voranstellen, Jahresgang Jahr 2 den letzten Wert aus Jahr 1\n    jahresgang_speicher_jahr1 = pd.concat([pd.Series([0]), jahresgang_speicher_jahr1])\n    jahresgang_speicher_jahr2 = pd.concat([jahresgang_speicher_jahr1[ - 1: ], jahresgang_speicher_jahr2])\n\n    # eingespeicherte Strommenge mit neuer Speichergröße bestimmen\n    einspeicherung_jahr1 = jahresgang_speicher_jahr1.diff().clip(lower = 0).sum()\n    einspeicherung_jahr2 = jahresgang_speicher_jahr2.diff().clip(lower = 0).sum()\n\n    neue_Zeile = [speichergröße_neu, einspeicherung_jahr1, zyklen_jahr1, einspeicherung_jahr2, zyklen_jahr2]\n    dataframe.loc[count] = neue_Zeile\n  \n    count += 1\n  \n  # gekappte Menge berechnen data.sub(data[0]).drop(0)\n  gekappte_einspeicherung_jahr1 = dataframe['Einspeicherung Jahr1'].sub(dataframe['Einspeicherung Jahr1'][0]).abs().drop(0).reset_index(drop = True)\n  gekappte_einspeicherung_jahr2 = dataframe['Einspeicherung Jahr2'].sub(dataframe['Einspeicherung Jahr2'][0]).abs().drop(0).reset_index(drop = True)\n  dataset = pd.DataFrame({'relative Speichergröße': pd.Series(neue_speichergrößen), 'gekappte Einspeicherung Jahr1': gekappte_einspeicherung_jahr1, 'gekappte Einspeicherung Jahr2': gekappte_einspeicherung_jahr2})\n  \n  if output:\n\n    print(dataframe)\n    print(\"\\n\")\n    print(dataset)\n\n  else:\n    return dataset\n\neffekt_kappung_berechnen(restlast, einspeicherwirkungsgrad = 0.9, ausspeicherwirkungsgrad = 0.9, output = True)\n\n   Speichergröße  Einspeicherung Jahr1  Zyklen Jahr1  Einspeicherung Jahr2  \\\n0      102674.54             902678.40          8.79             902678.40   \n1       92407.08             892410.95          9.66             892410.95   \n2       82139.63             882143.49         10.74             882143.49   \n3       71872.18             864601.21         12.03             864601.21   \n4       61604.72             844066.30         13.70             844066.30   \n5       51337.27             799701.77         15.58             799701.77   \n\n   Zyklen Jahr2  \n0          8.79  \n1          9.66  \n2         10.74  \n3         12.03  \n4         13.70  \n5         15.58  \n\n\n   relative Speichergröße  gekappte Einspeicherung Jahr1  \\\n0                     0.9                       10267.45   \n1                     0.8                       20534.91   \n2                     0.7                       38077.19   \n3                     0.6                       58612.10   \n4                     0.5                      102976.63   \n\n   gekappte Einspeicherung Jahr2  \n0                       10267.45  \n1                       20534.91  \n2                       38077.19  \n3                       58612.10  \n4                      102976.63",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Energiedatenanalyse</span>"
    ]
  },
  {
    "objectID": "skript/energiedatenanalyse.html#anteil-erneuerbarer-stromerzeugung-bestimmen",
    "href": "skript/energiedatenanalyse.html#anteil-erneuerbarer-stromerzeugung-bestimmen",
    "title": "1  Energiedatenanalyse",
    "section": "7.4 Anteil erneuerbarer Stromerzeugung bestimmen",
    "text": "7.4 Anteil erneuerbarer Stromerzeugung bestimmen\nDurch die Integration eines Stromspeichers in das Stromsystem kann erneuerbare Überschussproduktion in Phasen mit einer positiven Restlast verschoben werden, die andernfalls durch Lastfolgekraftwerke zu decken wäre. Dadurch sinkt der Anteil konventioneller Stromerzeugung und steigt der Anteil erneuerbarer Stromerzeugung.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nAnteil erneuerbarer Stromproduktion bestimmen\n\nDie Ausspeicherung von Strom vermindert die positive Restlast\n\n\nWird der ausgespeicherte Strom von der positiven Restlast abgezogen (in Summe oder im Jahresgang), entspricht der Anteil konventionell zu deckender Last dem Quotienten aus der summierten positiven Restlast und der summierten Netzlast bzw. aus der summierten positiven Restlast und der summierten Stromerzeugung.\n\n\nDer Anteil erneuerbarer Stromproduktion entspricht 1 - Anteil konventionell zu deckender Last.\n\n\n\n\n\nDer Anteil erneuerbarer Stromproduktion kann deshalb wie folgt berechnet werden:\n\nrestlast.clip(lower = 0).sum() / verbrauch['Gesamt (Netzlast) [MWh]'].sum()\n\nprint(f\"Summe positive Restlast [MWh]: {restlast.clip(lower = 0).sum()}\\n\"\n      f\"Summe Netzlast: {verbrauch['Gesamt (Netzlast) [MWh]'].sum()}\\n\"\n      f\"Quotient positive Restlast / Netzlast: {restlast.clip(lower = 0).sum() / verbrauch['Gesamt (Netzlast) [MWh]'].sum():,.2f}\\n\"\n      f\"Anteil erneuerbarer Erzeugung: { ( anteil_ee := 1 - (restlast.clip(lower = 0).sum() / verbrauch['Gesamt (Netzlast) [MWh]'].sum()) ) :,.2f}\\n\\n\"\n\n      f\"Summe Erzeugung: {erzeugung.sum(numeric_only = True).sum()}\\n\"\n      f\"Quotient positive Restlast / Erzeugung: {restlast.clip(lower = 0).sum() / erzeugung.sum(numeric_only = True).sum():,.2f}\\n\"\n      f\"Anteil erneuerbarer Erzeugung: {1 - (restlast.clip(lower = 0).sum() / erzeugung.sum(numeric_only = True).sum()):,.2f}\")\n\nSumme positive Restlast [MWh]: 207842228.25\nSumme Netzlast: 458271100.75\nQuotient positive Restlast / Netzlast: 0.45\nAnteil erneuerbarer Erzeugung: 0.55\n\nSumme Erzeugung: 448650448.25\nQuotient positive Restlast / Erzeugung: 0.46\nAnteil erneuerbarer Erzeugung: 0.54\n\n\nDie Netzlast aus dem Datensatz verbrauch weicht mit 458 TWh geringfügig von der summierten Stromerzeugung aus dem Datensatz erzeugung in Höhe von 448 TWh ab. Dadurch unterscheiden sich die berechneten Anteile leicht.\n\nBerechnung\nGrundlage für die Berechnung des Anteils erneuerbarer Stromerzeugung nach Ausspeicherung erneuerbarer Überschussproduktion ist der Jahresgang des Speichers. Die Ausspeicherung von Strom bedeutet eine Verminderung des Ladestands zwischen zwei Zeitpunkten. Der ausgespeicherte Strom vermindert die positive Restlast zu diesem Zeitpunkt. Dadurch nimmt der Quotient aus der positiven Restlast und der Netzlast ab und der Anteil erneuerbarer Stromerzeugung steigt. Dies ist in der folgenden Funktion umgesetzt.\n\nEingabe: Der Funktion wird eine Restlastdatenreihe übergeben. Optional kann zusätzlich eine Netzlastdatenreihe übergeben werden. Ebenso kann optional eine Liste reduzierter Speichergrößen, ausgedrückt als relative Bruchteile von 1, übergeben werden. Wird keine Liste übergeben, erfolgt die Berechnung für die relativen Speichergrößen [0.9, 0.8, 0.7, 0.6, 0.5].\nVerarbeitung: Durch Aufruf der Funktion jahresgang_speicher_berechnen() werden für die Restlastdatenreihe die Jahresgänge des Stromspeichers mit relativer Größe 1 berechnet. Mit den Jahresgängen wird die ausgespeicherte Strommenge im Jahresgang mit der Methode pd.Series.diff().clip(upper = 0) bestimmt. Auch für diese gleitende Differenzberechnung wird dem Jahresgang in Jahr 1 eine Null vorangestellt, dem Jahresgang in Jahr 2 der letzte Wert aus Jahr 1. Der erste Wert im Jahresgang der ausgespeicherten Strommenge ist NaN, weshalb dieser Wert entfällt und der Index zurückgesetzt wird. Der vollständige Befehl lautet: pd.Series.diff().clip(upper = 0)[1: ].reset_index(drop = True). Die Jahresgang der ausgespeicherten Strommenge wird von der Restlastkurve abgezogen und so die Restlastkurve nach Ausspeicherung bestimmt. Da die Ausspeicherung im Jahresgang durch negative Werte angezeigt wird, erfolgt die Differenzbildung durch Addition.\nWenn eine Netzlastdatenreihe übergeben wurde, wird auf der Grundlage der Restlastkurve nach Ausspeicherung der realisierte Anteil erneuerbarer Erzeugung berechnet: 1 - (Summe positive Restlast / Summe Netzlast). Die Berechnungen werden für kleiner dimensionerte Speicher wiederholt.\nAusgabe: Wenn output = False, werden die Restlastkurven nach Ausspeicherung als DataFrame zurückgeben. Der DataFrame besteht aus je einer Spalte für die relative Speichergröße 1 sowie für alle übergebenen relativ reduzierten Speichergrößen. Die Restlastkurven in Jahr 1 und Jahr 2 sind in Zeile 0 bzw. 1 gespeichert. Wenn output = True, werden die summierte Netzlast, die summierte positive & negative Restlast, der Anteil erneuerbarer Erzeugung ohne Speicher sowie der realisierter Anteil erneuerbarer Erzeugung mit der Speichergröße im Basisjahr und für alle übergebenen Speichergrößen jeweils für Jahr 1 und Jahr 2 mittels print() ausgegeben.\n\n\nohne Wirkungsgradmit Wirkungsgrad\n\n\n\n# Anteil EE berechnen\n## Eingabe: data = pd.Series(data, dtype = 'float'), netzlast = -1, neue_speichergrößen = [0.9, 0.8, 0.7, 0.6, 0.5], output = False\n## Verarbeitung: Aufruf der Funktion jahresgang_speicher_berechnen(data) zur Bestimmung von Speichergröße und Jahrsgang des Speichers in Jahr 1 und Jahr 2\n## Verarbeitung: Im Jahresgang des Stromspeichers wird die ausgespeicherte Strommenge bestimmt, diese wird von der Restlast abgezogen --&gt; neue Restlastkurve nach Ausspeicherung\n## Verarbeitung: Wenn netzlast = pd.Series(netzlast, dtype = 'float') übergeben wurde, wird anhand der Restlastkurve nach Ausspeicherung der Anteil erneuerbarer Energie bestimmt\n## Verarbeitung: Die Berechnungen werden für kleiner dimensionerte Speicher wiederholt, default = [0.9, 0.8, 0.7, 0.6, 0.5]\n## Ausgabe: output = False: DataFrame der Restlastkurve(n) nach Ausspeichern wird zurückgeben. In Spalte 0 ist Speichergröße = 1, in den folgenden Spalten die neuen Speichergrößen gespeichert. Zeile 0 enthält die Restlastkurve in Jahr 1, Zeile 1 die Restlastkurve in Jahr 2\n## Ausgabe: output = True, Ausgabe Summe Netzlast, positive / negative Restlast, Anteil EE ohne Speicher sowie realisierter Anteil EE für Speichergröße Basisjahr und neue_speichergrößen jeweils für Jahr 1 und Jahr2 mittels print()\n\ndef anteil_ee_berechnen(data, netzlast = -1, neue_speichergrößen = [0.9, 0.8, 0.7, 0.6, 0.5], output = False):\n\n  # Jahresgang im Basisjahr bestimmen\n  ergebnis = jahresgang_speicher_berechnen(data, speichergröße = -1, output = False)\n  speichergröße0 = ergebnis[0]\n  jahresgang_speicher_jahr1 = ergebnis[1]\n  jahresgang_speicher_jahr2 = ergebnis[2]\n  \n  # Jahresgang Jahr 1 eine Null voranstellen, Jahresgang Jahr 2 den letzten Wert aus Jahr 1\n  jahresgang_speicher_jahr1 = pd.concat([pd.Series([0]), jahresgang_speicher_jahr1])\n  jahresgang_speicher_jahr2 = pd.concat([jahresgang_speicher_jahr1[ - 1: ], jahresgang_speicher_jahr2])\n\n  # Jahresgang der ausgespeicherten Strommenge, erster Wert ist NaN und entfällt\n  ausspeicherung_jahr1 = jahresgang_speicher_jahr1.diff().clip(upper = 0)[1: ].reset_index(drop = True)\n  ausspeicherung_jahr2 = jahresgang_speicher_jahr2.diff().clip(upper = 0)[1: ].reset_index(drop = True)\n\n  # Restlast nach Ausspeicherung berechnen, Werte in ausspeicherung_jahr1 und ausspeicherung_jahr2 sind negativ\n  restlast_jahr1 = data + ausspeicherung_jahr1\n  restlast_jahr2 = data + ausspeicherung_jahr2\n\n  # Restlast in DataFrame speichern\n  restlast_nach_ausspeichern = pd.DataFrame({'Speichergröße 1': [ list(restlast_jahr1), list(restlast_jahr2) ]})\n\n  if type(netzlast) is int: # Anteil EE kann nicht ermittelt werden\n    if output:\n      print(\"Netzlast wurde nicht übergeben. Anteil erneuerbarer Energien kann nicht ermittelt werden.\")\n\n    output = False\n  \n  else: # Anteil EE berechnen\n  \n    # Anteil Anteil EE berechnen = 1 - Summe positive Restlast / Summe Netzlast \n    ## Jahr1\n    anteil_ee_jahr1 = 1 - (restlast_jahr1.clip(lower = 0).sum() / netzlast.sum() )\n\n    ## Jahr2\n    anteil_ee_jahr2 = 1 - (restlast_jahr2.clip(lower = 0).sum() / netzlast.sum() )\n\n    # Anteil EE in DataFrame speichern\n    dataframe_anteil_ee = pd.DataFrame({'relative Speichergröße': pd.concat([ pd.Series([1]), pd.Series(neue_speichergrößen) ], ignore_index = True), 'Anteil EE Jahr1': pd.Series([ anteil_ee_jahr1 ] ), 'Anteil EE Jahr2': pd.Series([ anteil_ee_jahr2 ])})\n\n  # Jahresgang der ausgespeicherten Strommenge und Anteil EE bei alternativen Speichergrößen berechnen\n  count = 1\n\n  for i in range(len(neue_speichergrößen)):\n\n    speichergröße_neu = speichergröße0 * neue_speichergrößen[i]\n    \n    ergebnis = jahresgang_speicher_berechnen(data, speichergröße = speichergröße_neu, output = False)\n    jahresgang_speicher_jahr1 = ergebnis[1]\n    jahresgang_speicher_jahr2 = ergebnis[2]\n\n    # Jahresgang Jahr 1 eine Null voranstellen, Jahresgang Jahr 2 den letzten Wert aus Jahr 1\n    jahresgang_speicher_jahr1 = pd.concat([pd.Series([0]), jahresgang_speicher_jahr1])\n    jahresgang_speicher_jahr2 = pd.concat([jahresgang_speicher_jahr1[ - 1: ], jahresgang_speicher_jahr2])\n\n    # Jahresgang der ausgespeicherten Strommenge, erster Wert ist NaN und entfällt\n    ausspeicherung_jahr1 = jahresgang_speicher_jahr1.diff().clip(upper = 0)[1: ].reset_index(drop = True)\n    ausspeicherung_jahr2 = jahresgang_speicher_jahr2.diff().clip(upper = 0)[1: ].reset_index(drop = True)\n\n    # Restlast nach Ausspeicherung berechnen, Werte in ausspeicherung_jahr1 und ausspeicherung_jahr2 sind negativ\n    restlast_jahr1 = data + ausspeicherung_jahr1\n    restlast_jahr2 = data + ausspeicherung_jahr2\n\n    # Spalte in DataFrame restlast_nach_ausspeichern einfügen\n    restlast_nach_ausspeichern['Speichergröße ' + str(speichergröße_neu)] = [ list(restlast_jahr1), list(restlast_jahr2) ]\n\n    # Anteil EE berechnen = 1 - Summe positive Restlast / Summe Netzlast \n    if type(netzlast) is not int:\n    \n       ## Jahr1\n      anteil_ee_jahr1 = 1 - (restlast_jahr1.clip(lower = 0).sum() / netzlast.sum() )\n\n      ## Jahr2\n      anteil_ee_jahr2 = 1 - (restlast_jahr2.clip(lower = 0).sum() / netzlast.sum() )\n\n      # Anteil EE in DataFrame speichern, value assignment: df.loc[row_indexer, \"col\"] = values\n      dataframe_anteil_ee.loc[count, 'Anteil EE Jahr1'] = anteil_ee_jahr1\n      dataframe_anteil_ee.loc[count, 'Anteil EE Jahr2'] = anteil_ee_jahr2\n    \n    count += 1\n                          \n  if output: # Anteil EE ausgeben\n\n    print(f\"Summe Netzlast: {netzlast.sum():,.2f}\\nSumme positive Restlast: {data.clip(lower = 0).sum():,.2f}\\tSumme negative Restlast: {data.clip(upper = 0).sum():,.2f}\\nSpeichergröße 1: {speichergröße0:,.2f}\\tAnteil EE ohne Speicher: {1 - ( data.clip(lower = 0).sum() / netzlast.sum() ) if len(netzlast) &gt; 1 else '--':,.2f}\\n\")\n    print(dataframe_anteil_ee)\n    \n  else: # Restlastkurven zurückgeben\n    return restlast_nach_ausspeichern\n\nanteil_ee_berechnen(restlast, netzlast = verbrauch['Gesamt (Netzlast) [MWh]'], neue_speichergrößen = [0.9, 0.8, 0.7, 0.6, 0.5], output = True)\n\nSumme Netzlast: 458,271,100.75\nSumme positive Restlast: 207,842,228.25 Summe negative Restlast: -1,002,976.00\nSpeichergröße 1: 119,667.00 Anteil EE ohne Speicher: 0.55\n\n   relative Speichergröße  Anteil EE Jahr1  Anteil EE Jahr2\n0                     1.0             0.55             0.55\n1                     0.9             0.55             0.55\n2                     0.8             0.55             0.55\n3                     0.7             0.55             0.55\n4                     0.6             0.55             0.55\n5                     0.5             0.55             0.55\n\n\n\n\n\n# Anteil EE berechnen\n## Eingabe: data = pd.Series(data, dtype = 'float'), netzlast = -1, einspeicherwirkungsgrad = 1, ausspeicherwirkungsgrad = 1, neue_speichergrößen = [0.9, 0.8, 0.7, 0.6, 0.5], output = False\n## Verarbeitung: Aufruf der Funktion jahresgang_speicher_berechnen(data) zur Bestimmung von Speichergröße und Jahrsgang des Speichers in Jahr 1 und Jahr 2\n## Verarbeitung: Im Jahresgang des Stromspeichers wird die ausgespeicherte Strommenge bestimmt, diese wird von der Restlast abgezogen --&gt; neue Restlastkurve nach Ausspeicherung\n## Verarbeitung: Wenn netzlast = pd.Series(netzlast, dtype = 'float') übergeben wurde, wird anhand der Restlastkurve nach Ausspeicherung der Anteil erneuerbarer Energie bestimmt\n## Verarbeitung: Die Berechnungen werden für kleiner dimensionerte Speicher wiederholt, default = [0.9, 0.8, 0.7, 0.6, 0.5]\n## Ausgabe: output = False: DataFrame der Restlastkurve(n) nach Ausspeichern wird zurückgeben. In Spalte 0 ist Speichergröße = 1, in den folgenden Spalten die neuen Speichergrößen gespeichert. Zeile 0 enthält die Restlastkurve in Jahr 1, Zeile 1 die Restlastkurve in Jahr 2\n## Ausgabe: output = True, Ausgabe Summe Netzlast, positive / negative Restlast, Anteil EE ohne Speicher sowie realisierter Anteil EE für Speichergröße Basisjahr und neue_speichergrößen jeweils für Jahr 1 und Jahr2 mittels print()\n\ndef anteil_ee_berechnen(data, netzlast = -1, einspeicherwirkungsgrad = 1, ausspeicherwirkungsgrad = 1, neue_speichergrößen = [0.9, 0.8, 0.7, 0.6, 0.5], output = False):\n\n  # Jahresgang im Basisjahr bestimmen\n  ergebnis = jahresgang_speicher_berechnen(data, speichergröße = -1, einspeicherwirkungsgrad = einspeicherwirkungsgrad, ausspeicherwirkungsgrad = ausspeicherwirkungsgrad, output = False)\n  speichergröße0 = ergebnis[0]\n  jahresgang_speicher_jahr1 = ergebnis[1]\n  jahresgang_speicher_jahr2 = ergebnis[2]\n  \n  # Jahresgang Jahr 1 eine Null voranstellen, Jahresgang Jahr 2 den letzten Wert aus Jahr 1\n  jahresgang_speicher_jahr1 = pd.concat([pd.Series([0]), jahresgang_speicher_jahr1])\n  jahresgang_speicher_jahr2 = pd.concat([jahresgang_speicher_jahr1[ - 1: ], jahresgang_speicher_jahr2])\n\n  # Jahresgang der ausgespeicherten Strommenge, erster Wert ist NaN und entfällt\n  ausspeicherung_jahr1 = jahresgang_speicher_jahr1.diff().clip(upper = 0)[1: ].reset_index(drop = True)\n  ausspeicherung_jahr2 = jahresgang_speicher_jahr2.diff().clip(upper = 0)[1: ].reset_index(drop = True)\n\n  # Restlast nach Ausspeicherung berechnen, Werte in ausspeicherung_jahr1 und ausspeicherung_jahr2 sind negativ\n  restlast_jahr1 = data + ausspeicherung_jahr1\n  restlast_jahr2 = data + ausspeicherung_jahr2\n\n  # Restlast in DataFrame speichern\n  restlast_nach_ausspeichern = pd.DataFrame({'Speichergröße 1': [ list(restlast_jahr1), list(restlast_jahr2) ]})\n\n  if type(netzlast) is int: # Anteil EE kann nicht ermittelt werden\n    if output:\n      print(\"Netzlast wurde nicht übergeben. Anteil erneuerbarer Energien kann nicht ermittelt werden.\")\n\n    output = False\n  \n  else: # Anteil EE berechnen\n  \n    # Anteil Anteil EE berechnen = 1 - Summe positive Restlast / Summe Netzlast \n    ## Jahr1\n    anteil_ee_jahr1 = 1 - (restlast_jahr1.clip(lower = 0).sum() / netzlast.sum() )\n\n    ## Jahr2\n    anteil_ee_jahr2 = 1 - (restlast_jahr2.clip(lower = 0).sum() / netzlast.sum() )\n\n    # Anteil EE in DataFrame speichern\n    dataframe_anteil_ee = pd.DataFrame({'relative Speichergröße': pd.concat([ pd.Series([1]), pd.Series(neue_speichergrößen) ], ignore_index = True), 'Anteil EE Jahr1': pd.Series([ anteil_ee_jahr1 ] ), 'Anteil EE Jahr2': pd.Series([ anteil_ee_jahr2 ])})\n\n  # Jahresgang der ausgespeicherten Strommenge und Anteil EE bei alternativen Speichergrößen berechnen\n  count = 1\n\n  for i in range(len(neue_speichergrößen)):\n\n    speichergröße_neu = speichergröße0 * neue_speichergrößen[i]\n    \n    ergebnis = jahresgang_speicher_berechnen(data, speichergröße = speichergröße_neu, einspeicherwirkungsgrad = einspeicherwirkungsgrad, ausspeicherwirkungsgrad = ausspeicherwirkungsgrad, output = False)\n    jahresgang_speicher_jahr1 = ergebnis[1]\n    jahresgang_speicher_jahr2 = ergebnis[2]\n\n    # Jahresgang Jahr 1 eine Null voranstellen, Jahresgang Jahr 2 den letzten Wert aus Jahr 1\n    jahresgang_speicher_jahr1 = pd.concat([pd.Series([0]), jahresgang_speicher_jahr1])\n    jahresgang_speicher_jahr2 = pd.concat([jahresgang_speicher_jahr1[ - 1: ], jahresgang_speicher_jahr2])\n\n    # Jahresgang der ausgespeicherten Strommenge, erster Wert ist NaN und entfällt\n    ausspeicherung_jahr1 = jahresgang_speicher_jahr1.diff().clip(upper = 0)[1: ].reset_index(drop = True)\n    ausspeicherung_jahr2 = jahresgang_speicher_jahr2.diff().clip(upper = 0)[1: ].reset_index(drop = True)\n\n    # Restlast nach Ausspeicherung berechnen, Werte in ausspeicherung_jahr1 und ausspeicherung_jahr2 sind negativ\n    restlast_jahr1 = data + ausspeicherung_jahr1\n    restlast_jahr2 = data + ausspeicherung_jahr2\n\n    # Spalte in DataFrame restlast_nach_ausspeichern einfügen\n    restlast_nach_ausspeichern['Speichergröße ' + str(speichergröße_neu)] = [ list(restlast_jahr1), list(restlast_jahr2) ]\n\n    # Anteil EE berechnen = 1 - Summe positive Restlast / Summe Netzlast \n    if type(netzlast) is not int:\n    \n       ## Jahr1\n      anteil_ee_jahr1 = 1 - (restlast_jahr1.clip(lower = 0).sum() / netzlast.sum() )\n\n      ## Jahr2\n      anteil_ee_jahr2 = 1 - (restlast_jahr2.clip(lower = 0).sum() / netzlast.sum() )\n\n      # Anteil EE in DataFrame speichern, value assignment: df.loc[row_indexer, \"col\"] = values\n      dataframe_anteil_ee.loc[count, 'Anteil EE Jahr1'] = anteil_ee_jahr1\n      dataframe_anteil_ee.loc[count, 'Anteil EE Jahr2'] = anteil_ee_jahr2\n    \n    count += 1\n                          \n  if output: # Anteil EE ausgeben\n\n    print(f\"Summe Netzlast: {netzlast.sum():,.2f}\\nSumme positive Restlast: {data.clip(lower = 0).sum():,.2f}\\tSumme negative Restlast: {data.clip(upper = 0).sum():,.2f}\\nSpeichergröße 1: {speichergröße0:,.2f}\\tAnteil EE ohne Speicher: {1 - ( data.clip(lower = 0).sum() / netzlast.sum() ) if len(netzlast) &gt; 1 else '--':,.2f}\\n\")\n    print(dataframe_anteil_ee)\n    \n  else: # Restlastkurven zurückgeben\n    return restlast_nach_ausspeichern\n\nanteil_ee_berechnen(restlast, netzlast = verbrauch['Gesamt (Netzlast) [MWh]'], einspeicherwirkungsgrad = 0.9, ausspeicherwirkungsgrad = 0.9, neue_speichergrößen = [0.9, 0.8, 0.7, 0.6, 0.5], output = True)\n\nSumme Netzlast: 458,271,100.75\nSumme positive Restlast: 207,842,228.25 Summe negative Restlast: -1,002,976.00\nSpeichergröße 1: 102,674.54 Anteil EE ohne Speicher: 0.55\n\n   relative Speichergröße  Anteil EE Jahr1  Anteil EE Jahr2\n0                     1.0             0.55             0.55\n1                     0.9             0.55             0.55\n2                     0.8             0.55             0.55\n3                     0.7             0.55             0.55\n4                     0.6             0.55             0.55\n5                     0.5             0.55             0.55\n\n\n\n\n\nFür das Jahr 2023 ergäbe sich durch die Netzintegration eines Stromspeichers zur (teilweisen) Deckung der Restlast aus erneuerbarer Überschussproduktion eine nur unmerkliche Erhöhung des Anteils erneuerbarer Energien am Strommix. Das liegt daran, dass die einzuspeichernden erneuerbaren Überschüsse mit 1.002.976 MWh, also rund 1 TWh, erheblich kleiner als die zu deckende positive Restlast mit 207.842.228 MWh, also rund 208 TWh, sind. Die durch den Stromspeicher verschiebbare erneuerbare Überschussproduktion entspricht weniger als einem halben Prozent der zu deckenden Restlast.\nMit steigendem Anteil erneuerbarer Erzeugung wird die Speicherung überschüssiger Stromerzeugung jedoch immer relevanter werden. Die Dimension der erforderlichen Stromspeicher können mit den entwickelten Funktionen für den Ausbaupfad erneuerbarer Energien abgeschätzt werden.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Energiedatenanalyse</span>"
    ]
  },
  {
    "objectID": "skript/energiedatenanalyse.html#aufgabe-schließende-datenanalyse",
    "href": "skript/energiedatenanalyse.html#aufgabe-schließende-datenanalyse",
    "title": "1  Energiedatenanalyse",
    "section": "7.5 Aufgabe schließende Datenanalyse",
    "text": "7.5 Aufgabe schließende Datenanalyse\nBerechnen Sie entsprechend des von der Bundesregierung vorgegebenen Ausbaupfads den Anteil erneuerbarer Stromerzeugung für das Jahr 2030 und für das Jahr 2035 (siehe Code-Block 7.1).\n\nWie groß ist der maximal benötigte Speicher?\nWelcher Anteil erneuerbarer Stromerzeugung wird erreicht, wenn der Speicher halb so groß, ein Zehntel so groß oder ein Hundertstel so groß dimensioniert wird?\nAls Netzlast verwenden Sie die Projektionen des Stromverbrauchs für das Jahr 2030 und 2035 (siehe untenstehender Hinweis).\nFür den Wirkungsgrad können die bestehenden Pumpspeicherkraftwerke als Orientierung dienen. Der Gesamtwirkungsgrad wurde mit 79.10 Prozent berechnet. Diesem Wirkungsgrad entspricht näherungsweise eine Aufteilung von Einspeicherwirkungsgrad = 0.9, Ausspeicherwirkungsgrad = 0.88.\n\n\n\n\n\n\n\nProjektionen des Stromverbrauchs\n\n\n\nDer künftige Stromverbrauch wird wahrscheinlich nicht dem des Jahres 2023 entsprechen. Projektionen lassen einen Stromverbrauch von 658 TWh (Kemmler, Wünsch, und Burret 2021, S. 4) für das Jahr 2030 und von 670,4 TWh im Jahr 2035 (Szenario B nach Nahmmacher et al. 2021, S. 54) erwarten. Die Steigerung des Stromverbrauchs gegenüber 2023 kann leicht berechnet werden:\n\nlastfaktor_2030_MWh = (658 * 1000 * 1000) / verbrauch[\"Gesamt (Netzlast) [MWh]\"].sum()\nlastfaktor_2035_MWh = (670.4 * 1000 * 1000) / verbrauch[\"Gesamt (Netzlast) [MWh]\"].sum()\n\nprint(f\"Steigerung des Stromverbrauchs 2030 gegenüber 2023 Faktor: {lastfaktor_2030_MWh:,.2f}\\n\"\n      f\"Steigerung des Stromverbrauchs 2035 gegenüber 2023 Faktor: {lastfaktor_2035_MWh:,.2f}\")\n\nSteigerung des Stromverbrauchs 2030 gegenüber 2023 Faktor: 1.44\nSteigerung des Stromverbrauchs 2035 gegenüber 2023 Faktor: 1.46\n\n\nKemmler, Andreas, Aurel Wünsch, und Heiko Burret. 2021. “Entwicklung des Bruttostromverbrauchs bis 2030. Kurzstudie.” https://www.bmwk.de/Redaktion/DE/Downloads/E/prognos-bruttostromverbrauch-2018-2030.pdf?__blob=publicationFile&v=2\nNahmmacher, Paul, Christian Paris, Martin Ruge, Sebastian Spieker, Thomas Anderski, Sebastian Bohlen, Robin Kaiser, Caroline Podewski, Jürgen Apfelbeck, Timo Kahl, Fabian Lukas, Sven Schäfer, Paul-Steven Ganer, Max Muller und Daniel Stützle. 2021. “Szenariorahmen zum Netzentwicklungsplan Strom 2035, Version 2021. Entwurf der Übertragungsnetzbetreiber.” https://www.netzausbau.de/SharedDocs/Downloads/DE/Bedarfsermittlung/2035/SR/Szenariorahmen_2035_Entwurf.pdf?__blob=publicationFile\n\n\n \n\n\n\n\n\n\nTipp 7.2: Musterlösung Aufgabe schließende Datenanalyse\n\n\n\n\n\n\nvollständige MusterlösungReferenz 2030Referenz 2035\n\n\n\n\nimport pandas as pd\n\n# Deklarieren der Anzahl der Nachkommastellen\npd.set_option(\"display.precision\", 2)\n\n# Datensätze werden eingelesen\n# !\n# Für die eigene Anwendung muss der Dateipfad an den korrekten Speicherort der runtergeladenen .csv Datei angepasst werden. \n# !\n\ninstallierte_leistung_ms = pd.read_csv(\"01-daten/Installierte_Erzeugungsleistung_202301010000_202401010000_Jahr.csv\", \\\nsep = \";\", thousands = \".\", decimal = \",\", parse_dates =  [0, 1], date_format = \"%d.%m.%Y\")\n\nerzeugung_ms = pd.read_csv(\"01-daten/Realisierte_Erzeugung_202301010000_202401010000_Viertelstunde.csv\", \\\nsep = \";\", thousands = \".\", decimal = \",\", parse_dates =  [0, 1], date_format = \"%d.%m.%Y %H:%M\")\n\nverbrauch_ms = pd.read_csv(\"01-daten/Realisierter_Stromverbrauch_202301010000_202401010000_Viertelstunde.csv\", \\\nsep = \";\", thousands = \".\", decimal = \",\", parse_dates =  [0, 1], date_format = \"%d.%m.%Y %H:%M\")\n\n# Zeichenkette \" Originalauflösungen\" entfernen\nerzeugung_ms.columns = erzeugung_ms.columns.str.replace(pat = \" Originalauflösungen\", repl = \"\")\ninstallierte_leistung_ms.columns = installierte_leistung_ms.columns.str.replace(pat = \" Originalauflösungen\", repl = \"\")\nverbrauch_ms.columns = verbrauch_ms.columns.str.replace(pat = \" Originalauflösungen\", repl = \"\")\n\n# Zusammenfassen der erneuerbaren Erzeugung in einer Liste\nerneuerbare_ms = ['Biomasse [MWh]', 'Wasserkraft [MWh]', 'Wind Offshore [MWh]', 'Wind Onshore [MWh]', 'Photovoltaik [MWh]', 'Sonstige Erneuerbare [MWh]']\n\npumpspeicherkapazität_MWh_ms = 37.4 * 1000\n\n# Projizierte Erzeugung und Stromverbrauch 2030 & 2035:\nprint(f\"Wind an Land 2030:\\t{( zubaufaktor_windonshore_2030_ms := 115 / (installierte_leistung_ms['Wind Onshore [MW]'].sum() / 1000) ):,.2f}\\n\"\n      f\"Wind auf See 2030:\\t{( zubaufaktor_windoffshore_2030_ms := 30 / (installierte_leistung_ms['Wind Offshore [MW]'].sum() / 1000) ):,.2f}\\n\"\n      f\"Solar 2030:\\t\\t\\t{( zubaufaktor_solar_2030_ms := 215 / (installierte_leistung_ms['Photovoltaik [MW]'].sum() / 1000) ):,.2f}\\n\"\n      f\"Biomasse 2030:\\t\\t{8.4 / (installierte_leistung_ms['Biomasse [MW]'].sum() / 1000):,.2f}\")\n\nprint(f\"\\n\\nWind an Land 2035:\\t{( zubaufaktor_windonshore_2035_ms := 157 / (installierte_leistung_ms['Wind Onshore [MW]'].sum() / 1000) ):,.2f}\\n\"\n      f\"Wind auf See 2035:\\t{( zubaufaktor_windoffshore_2035_ms := 40 / (installierte_leistung_ms['Wind Offshore [MW]'].sum() / 1000) ):,.2f}\\n\"\n      f\"Solar 2035:\\t\\t\\t{( zubaufaktor_solar_2035_ms := 309 / (installierte_leistung_ms['Photovoltaik [MW]'].sum() / 1000) ):,.2f}\\n\"\n      f\"Biomasse 2035:\\t\\t{8.4 / (installierte_leistung_ms['Biomasse [MW]'].sum() / 1000):,.2f}\")\n\nlastfaktor_2030_MWh_ms = (658 * 1000 * 1000) / verbrauch_ms[\"Gesamt (Netzlast) [MWh]\"].sum()\nlastfaktor_2035_MWh_ms = (670.4 * 1000 * 1000) / verbrauch_ms[\"Gesamt (Netzlast) [MWh]\"].sum()\n\nprint(f\"\\nSteigerung des Stromverbrauchs 2030 gegenüber 2023 Faktor: {lastfaktor_2030_MWh_ms:,.2f}\\n\"\n      f\"Steigerung des Stromverbrauchs 2035 gegenüber 2023 Faktor: {lastfaktor_2035_MWh_ms:,.2f}\")\n\n# Definieren der Restlast\nrestlast_ms = pd.DataFrame()\nrestlast_ms[\"Netzlast [MWh]\"] = verbrauch_ms[\"Gesamt (Netzlast) [MWh]\"].copy() \nrestlast_ms[\"Erneuerbare [MWh]\"] = erzeugung_ms[erneuerbare_ms].sum(axis = \"columns\").copy()\nrestlast_ms[\"Restlast [MWh]\"] = restlast_ms[\"Netzlast [MWh]\"] - restlast_ms[\"Erneuerbare [MWh]\"]\nrestlast_ms = restlast_ms[\"Restlast [MWh]\"]\n\n\nerzeugung_2030_ms = erzeugung_ms.copy()\nerzeugung_2035_ms = erzeugung_ms.copy()\n\nerzeugung_2030_ms[\"Wind Onshore [MWh]\"] = erzeugung_2030_ms[\"Wind Onshore [MWh]\"] * zubaufaktor_windonshore_2030_ms\nerzeugung_2030_ms[\"Wind Offshore [MWh]\"] = erzeugung_2030_ms[\"Wind Offshore [MWh]\"] * zubaufaktor_windoffshore_2030_ms\nerzeugung_2030_ms[\"Photovoltaik [MWh]\"] = erzeugung_2030_ms[\"Photovoltaik [MWh]\"]* zubaufaktor_solar_2030_ms\n# der Wert für Biomasse muss hier nicht geändert werden, da der Faktor 0,99 (also näherungsweise 1) beträgt\nerzeugung_2035_ms[\"Wind Onshore [MWh]\"] = erzeugung_2035_ms[\"Wind Onshore [MWh]\"] * zubaufaktor_windonshore_2035_ms\nerzeugung_2035_ms[\"Wind Offshore [MWh]\"] = erzeugung_2035_ms[\"Wind Offshore [MWh]\"] * zubaufaktor_windoffshore_2035_ms\nerzeugung_2035_ms[\"Photovoltaik [MWh]\"] = erzeugung_2035_ms[\"Photovoltaik [MWh]\"]* zubaufaktor_solar_2035_ms\n\nverbrauch_2030_ms = verbrauch_ms.copy()\nverbrauch_2030_ms[\"Gesamt (Netzlast) [MWh]\"] = verbrauch_2030_ms[\"Gesamt (Netzlast) [MWh]\"]*lastfaktor_2030_MWh_ms\nverbrauch_2035_ms = verbrauch_ms.copy()\nverbrauch_2035_ms[\"Gesamt (Netzlast) [MWh]\"] = verbrauch_2035_ms[\"Gesamt (Netzlast) [MWh]\"]*lastfaktor_2035_MWh_ms\n\nrestlast_2030_ms = pd.DataFrame()\nrestlast_2030_ms[\"Netzlast [MWh]\"] = verbrauch_2030_ms[\"Gesamt (Netzlast) [MWh]\"].copy() \nrestlast_2030_ms[\"Erneuerbare [MWh]\"] = erzeugung_2030_ms[erneuerbare_ms].sum(axis = \"columns\").copy()\nrestlast_2030_ms[\"Restlast [MWh]\"] = restlast_2030_ms[\"Netzlast [MWh]\"] - restlast_2030_ms[\"Erneuerbare [MWh]\"]\nrestlast_2030_ms = restlast_2030_ms[\"Restlast [MWh]\"]\n\nrestlast_2035_ms = pd.DataFrame()\nrestlast_2035_ms[\"Netzlast [MWh]\"] = verbrauch_2035_ms[\"Gesamt (Netzlast) [MWh]\"].copy() \nrestlast_2035_ms[\"Erneuerbare [MWh]\"] = erzeugung_2035_ms[erneuerbare_ms].sum(axis = \"columns\").copy()\nrestlast_2035_ms[\"Restlast [MWh]\"] = restlast_2035_ms[\"Netzlast [MWh]\"] - restlast_2035_ms[\"Erneuerbare [MWh]\"]\nrestlast_2035_ms = restlast_2035_ms[\"Restlast [MWh]\"]\n\nprint(\"\\n2030\\n======================\\n\")\nspeicher_2030_ms = berechne_speichergröße(restlast_2030_ms, einspeicherwirkungsgrad = 0.9, ausspeicherwirkungsgrad = 0.88, output = False)\nprint(f\"erforderliche Speichergröße in 2030: {speicher_2030_ms:,.1f} MWh\")\n\nanteil_EE_2030_ms = anteil_ee_berechnen(restlast_2030_ms, netzlast = verbrauch_2030_ms['Gesamt (Netzlast) [MWh]'],\n                                     einspeicherwirkungsgrad = 0.9, ausspeicherwirkungsgrad = 0.88, neue_speichergrößen = [0.5, 0.1, 0.01], output = True)\n\n# das ganze nochmal für 2035:\nprint(\"\\n2035\\n======================\\n\")\nspeicher_2035_ms = berechne_speichergröße(restlast_2035_ms, einspeicherwirkungsgrad = 0.9, ausspeicherwirkungsgrad = 0.88, output = False)\nprint(f\"erforderliche Speichergröße in 2035: {speicher_2035_ms:,.1f} MWh\")\n\nanteil_EE_2035_ms = anteil_ee_berechnen(restlast_2035_ms, netzlast = verbrauch_2035_ms['Gesamt (Netzlast) [MWh]'],\n                                     einspeicherwirkungsgrad = 0.9, ausspeicherwirkungsgrad = 0.88, neue_speichergrößen = [0.5, 0.1, 0.01], output = True)\n\nWind an Land 2030:  2.00\nWind auf See 2030:  3.69\nSolar 2030:         3.41\nBiomasse 2030:      0.99\n\n\nWind an Land 2035:  2.73\nWind auf See 2035:  4.92\nSolar 2035:         4.90\nBiomasse 2035:      0.99\n\nSteigerung des Stromverbrauchs 2030 gegenüber 2023 Faktor: 1.44\nSteigerung des Stromverbrauchs 2035 gegenüber 2023 Faktor: 1.46\n\n2030\n======================\n\nerforderliche Speichergröße in 2030: 6,170,038.0 MWh\nSumme Netzlast: 658,000,000.00\nSumme positive Restlast: 175,897,072.30 Summe negative Restlast: -85,250,478.82\nSpeichergröße 1: 6,170,038.04   Anteil EE ohne Speicher: 0.73\n\n   relative Speichergröße  Anteil EE Jahr1  Anteil EE Jahr2\n0                    1.00             0.83             0.84\n1                    0.50             0.83             0.83\n2                    0.10             0.81             0.81\n3                    0.01             0.75             0.75\n\n2035\n======================\n\nerforderliche Speichergröße in 2035: 23,829,823.9 MWh\nSumme Netzlast: 670,400,000.00\nSumme positive Restlast: 125,949,558.61 Summe negative Restlast: -221,510,407.41\nSpeichergröße 1: 23,829,823.85  Anteil EE ohne Speicher: 0.81\n\n   relative Speichergröße  Anteil EE Jahr1  Anteil EE Jahr2\n0                    1.00             0.98             1.00\n1                    0.50             0.97             0.97\n2                    0.10             0.94             0.94\n3                    0.01             0.87             0.87\n\n\nMusterlösung von Marc Sönnecken. Für die Kompatibilität mit diesem Skript wurden der Dateipfad und die Objektbezeichnungen angepasst. Die Definition der verwendeten Funktionen wurde ausgeschnitten (identisch zu den im Skript gezeigten). Der Code wurde so ergänzt, dass in der Ausgabe einige zusätzliche Leerzeilen und Markierungen für das Jahr 2030 und das Jahr 2035 erscheinen.\n\n\n\n\nmeine_speichergrößen = [0.9, 0.8, 0.7, 0.6, 0.5, 0.4, 0.3, 0.2, 0.1, 0.08, 0.06, 0.04, 0.02, 0.01]\nmein_einspeicherwirkungsgrad = 0.9\nmein_ausspeicherwirkungsgrad = 0.88\n\n# Datensatz 2030 erzeugen\n## zubaufaktor_windonshore_2030\n## zubaufaktor_windoffshore_2030\n## zubaufaktor_solar_2030\n\nerzeugung_2030 = erzeugung.copy()\nerzeugung_2030['Wind Onshore [MWh]'] *= zubaufaktor_windonshore_2030\nerzeugung_2030['Wind Offshore [MWh]'] *= zubaufaktor_windoffshore_2030\nerzeugung_2030['Photovoltaik [MWh]'] *= zubaufaktor_solar_2030\n\nerneuerbare_2030 = pd.Series()\nerneuerbare = ['Biomasse [MWh]', 'Wasserkraft [MWh]', 'Wind Offshore [MWh]', 'Wind Onshore [MWh]', 'Photovoltaik [MWh]',\n'Sonstige Erneuerbare [MWh]']\nerneuerbare_2030 = erzeugung_2030[erneuerbare].sum(axis = \"columns\").copy()\n\nnetzlast_2023 = pd.Series()\nnetzlast_2023 = verbrauch[\"Gesamt (Netzlast) [MWh]\"].copy()\nnetzlast_2030 = netzlast_2023 * lastfaktor_2030_MWh\n\nrestlast_2030 = pd.Series()\nrestlast_2030 = netzlast_2030 - erneuerbare_2030\n\n# Ausgabe\nspeicher_2030 = berechne_speichergröße(restlast_2030, einspeicherwirkungsgrad = mein_einspeicherwirkungsgrad, ausspeicherwirkungsgrad = mein_ausspeicherwirkungsgrad, output = False)\nprint(f\"maximal erforderliche Speichergröße 2030: {speicher_2030:,.1f} MWh\\nDies entspricht {speicher_2030 / pumpspeicherkapazität_MWh:,.1f} Pumpspeicheräquivalenten.\")\nprint(\"\\n\")\n\neffekt_kappung_berechnen(restlast_2030, einspeicherwirkungsgrad = mein_einspeicherwirkungsgrad, ausspeicherwirkungsgrad = mein_ausspeicherwirkungsgrad, neue_speichergrößen = meine_speichergrößen, output = True)\nprint(\"\\n\")\n\nanteil_ee_berechnen(restlast_2030, netzlast = netzlast_2030, einspeicherwirkungsgrad = mein_einspeicherwirkungsgrad, ausspeicherwirkungsgrad = mein_ausspeicherwirkungsgrad, neue_speichergrößen = meine_speichergrößen, output = True)\n\nmaximal erforderliche Speichergröße 2030: 6,170,038.0 MWh\nDies entspricht 165.0 Pumpspeicheräquivalenten.\n\n\n    Speichergröße  Einspeicherung Jahr1  Zyklen Jahr1  Einspeicherung Jahr2  \\\n0        6.17e+06              7.67e+07         11.99              7.67e+07   \n1        5.55e+06              7.67e+07         13.32              7.61e+07   \n2        4.94e+06              7.61e+07         14.92              7.55e+07   \n3        4.32e+06              7.55e+07         16.98              7.49e+07   \n4        3.70e+06              7.49e+07         19.73              7.43e+07   \n5        3.09e+06              7.43e+07         23.58              7.36e+07   \n6        2.47e+06              7.35e+07         29.29              7.29e+07   \n7        1.85e+06              7.17e+07         38.23              7.12e+07   \n8        1.23e+06              6.79e+07         54.56              6.76e+07   \n9        6.17e+05              5.90e+07         95.05              5.86e+07   \n10       4.94e+05              5.59e+07        112.65              5.55e+07   \n11       3.70e+05              5.13e+07        137.99              5.09e+07   \n12       2.47e+05              4.28e+07        172.79              4.25e+07   \n13       1.23e+05              2.66e+07        215.36              2.65e+07   \n14       6.17e+04              1.51e+07        243.93              1.50e+07   \n\n    Zyklen Jahr2  \n0          12.44  \n1          13.71  \n2          15.29  \n3          17.34  \n4          20.06  \n5          23.87  \n6          29.53  \n7          38.45  \n8          54.76  \n9          94.96  \n10        112.41  \n11        137.51  \n12        172.29  \n13        214.86  \n14        243.43  \n\n\n    relative Speichergröße  gekappte Einspeicherung Jahr1  \\\n0                     0.90                       1.49e-08   \n1                     0.80                       5.95e+05   \n2                     0.70                       1.21e+06   \n3                     0.60                       1.83e+06   \n4                     0.50                       2.45e+06   \n5                     0.40                       3.21e+06   \n6                     0.30                       5.04e+06   \n7                     0.20                       8.78e+06   \n8                     0.10                       1.78e+07   \n9                     0.08                       2.09e+07   \n10                    0.06                       2.55e+07   \n11                    0.04                       3.40e+07   \n12                    0.02                       5.01e+07   \n13                    0.01                       6.16e+07   \n\n    gekappte Einspeicherung Jahr2  \n0                        6.17e+05  \n1                        1.23e+06  \n2                        1.85e+06  \n3                        2.47e+06  \n4                        3.09e+06  \n5                        3.85e+06  \n6                        5.55e+06  \n7                        9.15e+06  \n8                        1.81e+07  \n9                        2.12e+07  \n10                       2.58e+07  \n11                       3.42e+07  \n12                       5.02e+07  \n13                       6.17e+07  \n\n\nSumme Netzlast: 658,000,000.00\nSumme positive Restlast: 175,897,072.30 Summe negative Restlast: -85,250,478.82\nSpeichergröße 1: 6,170,038.04   Anteil EE ohne Speicher: 0.73\n\n    relative Speichergröße  Anteil EE Jahr1  Anteil EE Jahr2\n0                     1.00             0.83             0.84\n1                     0.90             0.83             0.83\n2                     0.80             0.83             0.83\n3                     0.70             0.83             0.83\n4                     0.60             0.83             0.83\n5                     0.50             0.83             0.83\n6                     0.40             0.83             0.83\n7                     0.30             0.83             0.83\n8                     0.20             0.82             0.82\n9                     0.10             0.81             0.81\n10                    0.08             0.81             0.81\n11                    0.06             0.80             0.80\n12                    0.04             0.79             0.79\n13                    0.02             0.77             0.77\n14                    0.01             0.75             0.75\n\n\n\n\n\n# Datensatz 2035 erzeugen\n# ## zubaufaktor_windonshore_2035\n# ## zubaufaktor_windonshore_2035\n# ## zubaufaktor_solar_2035\n\nerzeugung_2035 = erzeugung.copy()\nerzeugung_2035['Wind Onshore [MWh]'] *= zubaufaktor_windonshore_2035\nerzeugung_2035['Wind Offshore [MWh]'] *= zubaufaktor_windoffshore_2035\nerzeugung_2035['Photovoltaik [MWh]'] *= zubaufaktor_solar_2035\n\nerneuerbare_2035 = pd.Series()\nerneuerbare = ['Biomasse [MWh]', 'Wasserkraft [MWh]', 'Wind Offshore [MWh]', 'Wind Onshore [MWh]', 'Photovoltaik [MWh]',\n'Sonstige Erneuerbare [MWh]']\nerneuerbare_2035 = erzeugung_2035[erneuerbare].sum(axis = \"columns\").copy()\n\nnetzlast_2023 = pd.Series()\nnetzlast_2023 = verbrauch[\"Gesamt (Netzlast) [MWh]\"].copy()\nnetzlast_2035 = netzlast_2023 * lastfaktor_2035_MWh\n\nrestlast_2035 = pd.Series()\nrestlast_2035 = netzlast_2035 - erneuerbare_2035\n\n# Ausgabe\nspeicher_2035 = berechne_speichergröße(restlast_2035, einspeicherwirkungsgrad = mein_einspeicherwirkungsgrad, ausspeicherwirkungsgrad = mein_ausspeicherwirkungsgrad, output = False)\nprint(f\"maximal erforderliche Speichergröße 2035: {speicher_2035:,.1f} MWh\\nDies entspricht {speicher_2035 / pumpspeicherkapazität_MWh:,.1f} Pumpspeicheräquivalenten.\")\nprint(\"\\n\")\n\neffekt_kappung_berechnen(restlast_2035, einspeicherwirkungsgrad = mein_einspeicherwirkungsgrad, ausspeicherwirkungsgrad = mein_ausspeicherwirkungsgrad, neue_speichergrößen = meine_speichergrößen, output = True)\nprint(\"\\n\")\n\nanteil_ee_berechnen(restlast_2035, netzlast = netzlast_2035, einspeicherwirkungsgrad = mein_einspeicherwirkungsgrad, ausspeicherwirkungsgrad = mein_ausspeicherwirkungsgrad, neue_speichergrößen = meine_speichergrößen, output = True)\n\nmaximal erforderliche Speichergröße 2035: 23,829,823.9 MWh\nDies entspricht 637.2 Pumpspeicheräquivalenten.\n\n\n    Speichergröße  Einspeicherung Jahr1  Zyklen Jahr1  Einspeicherung Jahr2  \\\n0        2.38e+07              1.49e+08          5.84              1.43e+08   \n1        2.14e+07              1.47e+08          6.44              1.41e+08   \n2        1.91e+07              1.44e+08          7.17              1.38e+08   \n3        1.67e+07              1.42e+08          8.05              1.33e+08   \n4        1.43e+07              1.39e+08          9.19              1.29e+08   \n5        1.19e+07              1.34e+08         10.73              1.24e+08   \n6        9.53e+06              1.29e+08         12.99              1.19e+08   \n7        7.15e+06              1.21e+08         16.49              1.14e+08   \n8        4.77e+06              1.13e+08         23.15              1.08e+08   \n9        2.38e+06              1.01e+08         41.76              9.83e+07   \n10       1.91e+06              9.72e+07         50.47              9.53e+07   \n11       1.43e+06              9.18e+07         63.73              9.04e+07   \n12       9.53e+05              8.23e+07         85.86              8.14e+07   \n13       4.77e+05              6.58e+07        137.54              6.53e+07   \n14       2.38e+05              4.29e+07        179.40              4.26e+07   \n\n    Zyklen Jahr2  \n0           6.01  \n1           6.56  \n2           7.24  \n3           7.99  \n4           8.99  \n5          10.39  \n6          12.49  \n7          15.99  \n8          22.65  \n9          41.26  \n10         49.97  \n11         63.23  \n12         85.36  \n13        137.04  \n14        178.90  \n\n\n    relative Speichergröße  gekappte Einspeicherung Jahr1  \\\n0                     0.90                       2.38e+06   \n1                     0.80                       4.77e+06   \n2                     0.70                       7.15e+06   \n3                     0.60                       1.07e+07   \n4                     0.50                       1.55e+07   \n5                     0.40                       2.07e+07   \n6                     0.30                       2.78e+07   \n7                     0.20                       3.65e+07   \n8                     0.10                       4.86e+07   \n9                     0.08                       5.21e+07   \n10                    0.06                       5.74e+07   \n11                    0.04                       6.69e+07   \n12                    0.02                       8.35e+07   \n13                    0.01                       1.06e+08   \n\n    gekappte Einspeicherung Jahr2  \n0                        2.38e+06  \n1                        5.01e+06  \n2                        9.77e+06  \n3                        1.45e+07  \n4                        1.93e+07  \n5                        2.41e+07  \n6                        2.88e+07  \n7                        3.52e+07  \n8                        4.48e+07  \n9                        4.79e+07  \n10                       5.27e+07  \n11                       6.18e+07  \n12                       7.78e+07  \n13                       1.00e+08  \n\n\nSumme Netzlast: 670,400,000.00\nSumme positive Restlast: 125,949,558.61 Summe negative Restlast: -221,510,407.41\nSpeichergröße 1: 23,829,823.85  Anteil EE ohne Speicher: 0.81\n\n    relative Speichergröße  Anteil EE Jahr1  Anteil EE Jahr2\n0                     1.00             0.98             1.00\n1                     0.90             0.98             1.00\n2                     0.80             0.98             0.99\n3                     0.70             0.98             0.99\n4                     0.60             0.98             0.98\n5                     0.50             0.97             0.97\n6                     0.40             0.97             0.97\n7                     0.30             0.96             0.96\n8                     0.20             0.95             0.95\n9                     0.10             0.94             0.94\n10                    0.08             0.94             0.94\n11                    0.06             0.93             0.93\n12                    0.04             0.92             0.92\n13                    0.02             0.90             0.90\n14                    0.01             0.87             0.87\n\n\n\n\n\n\n\n\n\nGrafische Darstellung ausgewählter Speicherauslegungen\nEine grafische Darstellung des Jahresgangs des Speichers kann für verschiedene Auslegungen relativ zur maximal benötigten Speichergröße (C\\(_{max}\\)) mit Hilfe der Funktion jahresgang_speicher_berechnen(output = False) erzeugt werden. Dazu wird zunächst aus der prognostizierten Netzlast und dem geplanten erneuerbaren Zubau eine Restlastkurve für das Jahr 2030 und das Jahr 2035 berechnet.\n\n# Restlast 2030 berechnen\n## zubaufaktor_windonshore_2030\n## zubaufaktor_windoffshore_2030\n## zubaufaktor_solar_2030\n\nerzeugung_2030 = erzeugung.copy()\nerzeugung_2030['Wind Onshore [MWh]'] *= zubaufaktor_windonshore_2030\nerzeugung_2030['Wind Offshore [MWh]'] *= zubaufaktor_windoffshore_2030\nerzeugung_2030['Photovoltaik [MWh]'] *= zubaufaktor_solar_2030\n\nerneuerbare_2030 = pd.Series()\nerneuerbare = ['Biomasse [MWh]', 'Wasserkraft [MWh]', 'Wind Offshore [MWh]', 'Wind Onshore [MWh]', 'Photovoltaik [MWh]', 'Sonstige Erneuerbare [MWh]']\nerneuerbare_2030 = erzeugung_2030[erneuerbare].sum(axis = \"columns\").copy()\n\nnetzlast_2023 = pd.Series()\nnetzlast_2023 = verbrauch[\"Gesamt (Netzlast) [MWh]\"].copy()\nnetzlast_2030 = netzlast_2023 * lastfaktor_2030_MWh\n\nrestlast_2030 = pd.Series()\nrestlast_2030 = netzlast_2030 - erneuerbare_2030\n\n# Restlast 2035 berechnen\n## zubaufaktor_windonshore_2035\n## zubaufaktor_windonshore_2035\n## zubaufaktor_solar_2035\n\nerzeugung_2035 = erzeugung.copy()\nerzeugung_2035['Wind Onshore [MWh]'] *= zubaufaktor_windonshore_2035\nerzeugung_2035['Wind Offshore [MWh]'] *= zubaufaktor_windoffshore_2035\nerzeugung_2035['Photovoltaik [MWh]'] *= zubaufaktor_solar_2035\n\nerneuerbare_2035 = pd.Series()\nerneuerbare = ['Biomasse [MWh]', 'Wasserkraft [MWh]', 'Wind Offshore [MWh]', 'Wind Onshore [MWh]', 'Photovoltaik [MWh]', 'Sonstige Erneuerbare [MWh]']\nerneuerbare_2035 = erzeugung_2035[erneuerbare].sum(axis = \"columns\").copy()\n\nnetzlast_2023 = pd.Series()\nnetzlast_2023 = verbrauch[\"Gesamt (Netzlast) [MWh]\"].copy()\nnetzlast_2035 = netzlast_2023 * lastfaktor_2035_MWh\n\nrestlast_2035 = pd.Series()\nrestlast_2035 = netzlast_2035 - erneuerbare_2035\n\n \nAuf der Grundlage der berechneten Restlastkurven werden eine 80-prozentige, eine 20-prozentige und eine 4-prozentige Auslegung der maximal benötigten Speicherkapazität berechnet und dargestellt.\n\n80 % 203080 % 203520 % 203020 % 20354 % 20304 % 2035Code-Beispiel\n\n\n\n\n\n\n\n\n\n\n\nZyklenzahl Jahr 1: 14.92\nZyklenzahl Jahr 2: 15.29\nSumme Netzlast: 658,000,000.00\nSumme positive Restlast: 175,897,072.30 Summe negative Restlast: -85,250,478.82\nSpeichergröße 1: 6,170,038.04   Anteil EE ohne Speicher: 0.73\n\n   relative Speichergröße  Anteil EE Jahr1  Anteil EE Jahr2\n0                     1.0             0.83             0.84\n1                     0.8             0.83             0.83\n\nDie Speichergröße beträgt 4,936,030.4 MWh\nDies entspricht 132.0 Pumpspeicheräquivalenten.\n\n\n\n\n\n\n\n\n\n\n\n\n\nZyklenzahl Jahr 1: 7.17\nZyklenzahl Jahr 2: 7.24\nSumme Netzlast: 670,400,000.00\nSumme positive Restlast: 125,949,558.61 Summe negative Restlast: -221,510,407.41\nSpeichergröße 1: 23,829,823.85  Anteil EE ohne Speicher: 0.81\n\n   relative Speichergröße  Anteil EE Jahr1  Anteil EE Jahr2\n0                     1.0             0.98             1.00\n1                     0.8             0.98             0.99\n\nDie Speichergröße beträgt 19,063,859.1 MWh\nDies entspricht 509.7 Pumpspeicheräquivalenten.\n\n\n\n\n\n\n\n\n\n\n\n\n\nZyklenzahl Jahr 1: 54.56\nZyklenzahl Jahr 2: 54.76\nSumme Netzlast: 658,000,000.00\nSumme positive Restlast: 175,897,072.30 Summe negative Restlast: -85,250,478.82\nSpeichergröße 1: 6,170,038.04   Anteil EE ohne Speicher: 0.73\n\n   relative Speichergröße  Anteil EE Jahr1  Anteil EE Jahr2\n0                     1.0             0.83             0.84\n1                     0.2             0.82             0.82\n\nDie Speichergröße beträgt 1,234,007.6 MWh\nDies entspricht 33.0 Pumpspeicheräquivalenten.\n\n\n\n\n\n\n\n\n\n\n\n\n\nZyklenzahl Jahr 1: 23.15\nZyklenzahl Jahr 2: 22.65\nSumme Netzlast: 670,400,000.00\nSumme positive Restlast: 125,949,558.61 Summe negative Restlast: -221,510,407.41\nSpeichergröße 1: 23,829,823.85  Anteil EE ohne Speicher: 0.81\n\n   relative Speichergröße  Anteil EE Jahr1  Anteil EE Jahr2\n0                     1.0             0.98             1.00\n1                     0.2             0.95             0.95\n\nDie Speichergröße beträgt 4,765,964.8 MWh\nDies entspricht 127.4 Pumpspeicheräquivalenten.\n\n\n\n\n\n\n\n\n\n\n\n\n\nZyklenzahl Jahr 1: 172.79\nZyklenzahl Jahr 2: 172.29\nSumme Netzlast: 658,000,000.00\nSumme positive Restlast: 175,897,072.30 Summe negative Restlast: -85,250,478.82\nSpeichergröße 1: 6,170,038.04   Anteil EE ohne Speicher: 0.73\n\n   relative Speichergröße  Anteil EE Jahr1  Anteil EE Jahr2\n0                    1.00             0.83             0.84\n1                    0.04             0.79             0.79\n\nDie Speichergröße beträgt 246,801.5 MWh\nDies entspricht 6.6 Pumpspeicheräquivalenten.\n\n\n\n\n\n\n\n\n\n\n\n\n\nZyklenzahl Jahr 1: 85.86\nZyklenzahl Jahr 2: 85.36\nSumme Netzlast: 670,400,000.00\nSumme positive Restlast: 125,949,558.61 Summe negative Restlast: -221,510,407.41\nSpeichergröße 1: 23,829,823.85  Anteil EE ohne Speicher: 0.81\n\n   relative Speichergröße  Anteil EE Jahr1  Anteil EE Jahr2\n0                    1.00             0.98             1.00\n1                    0.04             0.92             0.92\n\nDie Speichergröße beträgt 953,193.0 MWh\nDies entspricht 25.5 Pumpspeicheräquivalenten.\n\n\n\n\n\n# Daten generieren\n## Speichergröße bestimmen und 80 Prozent berechnen\nspeichergröße_2030_80 = berechne_speichergröße(restlast_2030, einspeicherwirkungsgrad = 0.9, ausspeicherwirkungsgrad = 0.88, output = False) * 0.8\n\n## Jahresgang des Speichers bestimmen\nspeicher_2030_80_wirkungsgrad_90_88 = jahresgang_speicher_berechnen(restlast_2030, speichergröße = speichergröße_2030_80, einspeicherwirkungsgrad = 0.9, ausspeicherwirkungsgrad = 0.88, output = False)\n\njahresgang_speicher_jahr1 = speicher_2030_80_wirkungsgrad_90_88[1]\njahresgang_speicher_jahr2 = speicher_2030_80_wirkungsgrad_90_88[2]\n\n# xticks erzeugen\nmonate_index = erzeugung[~erzeugung[\"Datum von\"].dt.month.duplicated()].index\nmonatsnamen = erzeugung[\"Datum von\"].iloc[monate_index].dt.strftime(\"%B\") \n\n# Grafik mit drei subplots erzeugen\nfig, (ax1, ax2, ax3) = plt.subplots(3, 1, figsize = (7.5, 6), height_ratios = [2, 1, 1], sharex = True, layout = 'tight')\nplt.suptitle('Restlast 2030 und Jahresgang eines Speichers mit\\n C$_{max}$ = 0.8, η$_{ein}$ = 0.9 und η$_{aus}$ = 0.88')\nplt.xticks(monate_index, monatsnamen, rotation = 45);\nplt.minorticks_off()\nplt.setp([ax1, ax2, ax3], xlim = (restlast.index.min() - len(restlast.index) / 100, restlast.index.max() * 1.01))\nplt.setp([ax2, ax3], ylim = (0, max(max(jahresgang_speicher_jahr1), max(jahresgang_speicher_jahr2)) * 1.2))\n\n## plot restlast\nax1.plot(restlast_2030, label = \"Restlast\")\nax1.grid()\nax1.set_ylabel('MWh')\nax1.legend()\n\n## plot jahresgang_speicher_jahr1\nax2.plot(jahresgang_speicher_jahr1, color = 'black', linestyle = '-', label = 'Stromspeicher Jahr 1')\nax2.grid()\nax2.set_ylabel('MWh')\nax2.legend()\n\n## plot jahresgang_speicher_jahr2\nax3.plot(jahresgang_speicher_jahr2, color = 'black', linestyle = '-', label = 'Stromspeicher Jahr 2')\nax3.tick_params(axis = 'x', rotation = 45)\nax3.set_ylabel('MWh')\nax3.grid()\nax3.legend()\n\nplt.show()\n\n# Zyklenzahl berechnen, Übergabe von Tupel = Wirkungsgrade werden nicht benötigt\nzyklenzahl_berechnen(speicher_2030_80_wirkungsgrad_90_88, output = True)\n\n# Anteil EE berechnen\nanteil_ee_berechnen(restlast_2030, netzlast = netzlast_2030, einspeicherwirkungsgrad = 0.9, ausspeicherwirkungsgrad = 0.88, neue_speichergrößen = [0.8], output = True)\n\n# Speichergröße ausgeben\nprint(f\"\\nDie Speichergröße beträgt {speicher_2030_80_wirkungsgrad_90_88[0]:,.1f} MWh\\n\"\n      f\"Dies entspricht {speicher_2030_80_wirkungsgrad_90_88[0] / pumpspeicherkapazität_MWh:,.1f} Pumpspeicheräquivalenten.\")\n\n\n\n\nMit einer 80-prozentigen Auslegung der Speichergröße wirkt der Speicher überdimensioniert. Im Jahr 2030 kann der Speicher seine Kapazität über das Jahr kaum ausschöpfen. Der Speicher erreicht nur selten Ladestände im Bereich von 50 Prozent. Lediglich über den Jahreswechsel wird die maximale Kapazität in Anspruch genommen. Umgekehrt ist der Speicher im Jahr 2035 überwiegend voll geladen und es findet eine nur geringe Ein- und Ausspeicherung statt. Der Speicher erreicht insbesondere im Jahr 2035 nur wenige Vollyzklen.\nDie 2030 erforderliche Speicherkapazität von 4.936 GWh enspricht dem 132-Fachen der bestehenden Pumpspeicherkraftwerke oder 99 Jahresproduktionen der Tesla Gigafactory Berlin-Brandenburg in der ersten Ausbaustufe mit 50 GWh/a (Wikipedia). Die im Jahr 2035 erforderliche Speicherkapazität von 19.064 GWh entspricht dem 510-Fachen der bestehenden Pumpspeicherkraftwerke oder 381 Jahresproduktionen der Tesla Gigafactory Berlin-Brandenburg.\nHinweis: Die Referenz auf die Tesla Gigafactory Berlin-Brandenburg dient lediglich zur Einordnung. Die Fabrik in Grünheide produziert aktuell keine Batteriezellen. Planungen für weitere Batteriefabriken in Deutschland wurden jüngst eingestellt.\nMit einer 20-prozentigen Auslegung werden mehr Vollzyklen und umfangreichere Teilzyklen erreicht. Dennoch sind im Jahr 2035 von April bis Ende August konstant hohe Ladestände zu beobachten. 2030 würden 1.234 GWh Speicherkapazität benötigt, 2035 4.766 GWh. Dies entspricht dem 33- bzw. 127-Fachen der bestehenden Pumpspeicherkapazität oder 25 bzw. 95 Jahresproduktionen der Tesla Gigafactory Berlin-Brandenburg in der ersten Ausbaustufe.\nDie 4-Prozentige Auslegung zeigt ein ständiges Auf und Ab. In dieser Dimension könnte ein Stromspeicher wirtschaftlich zu betreiben sein. Dafür würden 2030 247 GWh und 2035 953 GWh Speicherkapazität benötigt. 247 GWh entsprechen dem 6,6-Fachen der bestehenden Pumpspeicherkapazität oder 5 Jahresproduktionen der Tesla Gigafactory Berlin-Brandenburg in der ersten Ausbaustufe. 953 GWh entsprechen 25,5 Pumpspeicheräquivalenten und 19 Jahresproduktionen der Tesla Gigafactory Berlin-Brandenburg.\nIn allen Szenarien ist auffällig, dass die Zyklenzahl in Jahr 1 und Jahr 2 fast identisch ist. Der Unterschied von einem halben Zyklus ergibt sich dadurch, dass der Speicher im ersten Jahr leer ans Netz geht. Je nach Szenario wird der Speicher dann im Jahresverlauf (Speichergröße 80 %), innerhalb weniger Wochen (Speichergröße 20 %) oder nahezu sofort (Speichergröße 4 %) erstmalig voll geladen.\nErkennbar gilt bei der Speicherauslegung die 80-20-Regel (Paretoprinzip): Mit 20 Prozent des Aufwands werden 80 Prozent des Weges erreicht. Beträgt 2035 der Anteil erneuerbarer Energien ohne Speicher 81 Prozent, so sind 19 Prozent durch Speicher (oder anderweitig) zu decken. Für eine 100-prozentige Bedarfsdeckung aus Stromspeichern würden 23,8 TWh Speicherkapzität benötigt. Ein 20 Prozent so großer Speicher erreicht einen Gesamtanteil erneuerbarer Energien von 95 Prozent. Ein wiederum nur 20 Prozent so großer Speicher erreicht einen Gesamtanteil von 92 Prozent.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Energiedatenanalyse</span>"
    ]
  },
  {
    "objectID": "skript/energiedatenanalyse.html#bonus-benötigte-spitzenleistung-der-reservekraftwerke-abschätzen",
    "href": "skript/energiedatenanalyse.html#bonus-benötigte-spitzenleistung-der-reservekraftwerke-abschätzen",
    "title": "1  Energiedatenanalyse",
    "section": "7.6 Bonus: Benötigte Spitzenleistung der Reservekraftwerke abschätzen",
    "text": "7.6 Bonus: Benötigte Spitzenleistung der Reservekraftwerke abschätzen\nAus der Berechnung verschiedener Speichergrößen wurde erkennbar, dass auch verhältnismäßig kleine Speichergrößen zu einem hohen Anteil erneuerbarer Energien im Strommix führen. Dennoch bedeuten kleiner dimensionierte Speicher, dass punktuell Netzlast durch in Reserve stehende Lastfolgekraftwerke bedient werden muss. In diesem Abschnitt wird die benötigte Erzeugungsleistung der Reservekraftwerke abgeschätzt. Dazu wird das Maximum der positiven Restlast nach Ausspeicherung mal vier multipliziert, da der Datensatz auf Viertelstundenbasis vorliegt.\n\nspitzenleistung_2030 = anteil_ee_berechnen(restlast_2030, netzlast = netzlast_2030, einspeicherwirkungsgrad = 0.9, ausspeicherwirkungsgrad = 0.88, neue_speichergrößen = [0.2, 0.04], output = False)\nspitzenleistung_2035 = anteil_ee_berechnen(restlast_2035, netzlast = netzlast_2035, einspeicherwirkungsgrad = 0.9, ausspeicherwirkungsgrad = 0.88, neue_speichergrößen = [0.2, 0.04], output = False)\n\n## Datenstruktur angucken\n## In Spalte 0 ist Speichergröße = 1, in den folgenden Spalten die neuen Speichergrößen gespeichert. Zeile 0 enthält die Restlastkurve in Jahr 1, Zeile 1 die Restlastkurve in Jahr 2\n# print(spitzenleistung_2030.shape)\n# print(spitzenleistung_2030.head())\n\n# Zeile 1 enthält den Jahresgang in Jahr 2\n# Spalte 0 enthält das Basisszenario Speichergröße = 1\nprint(f\"\\nSpitzenleistung 2030 für Cmax = 0.20: {max(spitzenleistung_2030.iloc[1, 1]) * 4 / 1000:.2f} GW\\n\"\n      f\"Spitzenleistung 2030 für Cmax = 0.04: {max(spitzenleistung_2030.iloc[1, 2]) * 4 / 1000:.2f} GW\\n\"\n      f\"Spitzenleistung 2035 für Cmax = 0.20: {max(spitzenleistung_2035.iloc[1, 1]) * 4 / 1000:.2f} GW\\n\"\n      f\"Spitzenleistung 2035 für Cmax = 0.04: {max(spitzenleistung_2035.iloc[1 , 2]) * 4 / 1000:.2f} GW\")\n\n\nSpitzenleistung 2030 für Cmax = 0.20: 87.64 GW\nSpitzenleistung 2030 für Cmax = 0.04: 87.64 GW\nSpitzenleistung 2035 für Cmax = 0.20: 87.53 GW\nSpitzenleistung 2035 für Cmax = 0.04: 87.53 GW",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Energiedatenanalyse</span>"
    ]
  },
  {
    "objectID": "skript/energiedatenanalyse.html#kompetenzquiz",
    "href": "skript/energiedatenanalyse.html#kompetenzquiz",
    "title": "1  Energiedatenanalyse",
    "section": "9.1 Kompetenzquiz",
    "text": "9.1 Kompetenzquiz\n\n\nWie lautet der vollständige Befehl, um mit dem Python Modul Pandas folgenden String in ein Objekt vom Typ datetime umzuwandeln?\n\n\ndatum = ‘2008-Oct-29’\ndatum_pd = pd.to_datetime(datum, format = \" ... \")\n\n \n\nMit welcher Methode können die Datenreihen a, b und c verkettet werden?\n\npandas.concat(a, b, c)\npandas.append(a, b, ,c)\npandas.concatenate[a, b, c]\npandas.concat([a , b , c])\n\n\n \n\nWas ist der Zweck der beschreibenden Datenanalyse?\n\nFehler im Datensatz identifizieren\nBenötigte Module laden\nVorbereitung der explorativen und schließenden Datenanalyse\nÜberblick über den Datensatz gewinnen\n\n\n \n\nWelche Aussagen sind wahr?\n\nExplorative Datenanalyse ist ein iterativer Prozess, um einen Datensatz zu erkunden und mit den gewonnenen Erkenntnissen neue Fragen an den Datensatz zu stellen.\nDie Methoden der explorativen Datenanalyse sind fest vorgegeben.\nDie explorative Datenanalyse erfolgt rein kennzahlenbasiert.\nDie explorative Datenanalyse bereitet die schließende Datenanalyse vor.\n\n\n \n\nDie Auslegung der Größe eines Stromspeichers ist abhängig von:\n\nDer Zyklik der Einspeicherung\nDem Verhältnis der einspeicherbaren, überschüssigen Stromerzeugung und der durch den Speicher zu bedienenden Last\nDer Kappung von Erzeugungsspitzen\nDem Wirkungsgrad des Speichers\n\n\n\n\n\n\n\n\nTipp 9.1: Lösungen\n\n\n\n\n\nLösung 1: datum_pd = pd.to_datetime(datum, format = “%Y-%b-%d”)\nLösung 2: pandas.concat([a , b , c])\nLösung 3: a, c, d\nLösung 4: a, d\nLösung 5: a, b, c, d",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Energiedatenanalyse</span>"
    ]
  },
  {
    "objectID": "skript/energiedatenanalyse.html#übungen",
    "href": "skript/energiedatenanalyse.html#übungen",
    "title": "1  Energiedatenanalyse",
    "section": "9.2 Übungen",
    "text": "9.2 Übungen\nIm Rahmen der schließenden Datenanalyse wurde festgestellt, dass durch die Kappung von Erzeugungsspitzen in einem von erneuerbarer Überschussproduktion geprägtem Stromsystem der erforderliche Stromspeicher um Größenordnungen kleiner dimensioniert werden kann. Allerdings verbleiben dann wenige Prozent der Jahresstromnachfrage, die nicht erneuerbar aus der laufenden Produktion oder durch Ausspeicherung gedeckt werden können. Eine Option bestünde darin, die Biomassekraftwerke in Lastfolge zu betreiben.\nBerechnen Sie die erforderliche Speichergröße (Einspeicherwirkungsgrad = 0.9, Ausspeicherwirkungsgrad = 0.88), wenn der Anteil erneuerbarer Energien 2035 100 Prozent betragen soll und Biomassekraftwerke in Lastfolge betrieben werden. Dabei wird angenommen, dass Biomassekraftwerke in Zeiten mit einer vollständigen Deckung des Stromverbrauchs durch die übrigen erneuerbaren Energien ihre Gasproduktion einspeichern und dann verstromen, wenn eine positive Restlast besteht. Die Produktion der Biogasanlagen entspreche der Erzeugungskurve des Jahres 2023.\n\nWie groß müsste der Gasspeicher (in MWh elektrischer Energie) sein?\nWie hoch ist die maximal benötigte Stromerzeugungsleistung der Biomassekraftwerke absolut und relativ zur 2023 installierten Leistung?\nWie groß muss der erforderliche Stromspeicher sein, wenn Biomassekraftwerke in Lastfolge betrieben werden?\n\n\n\n\n\nFraunhofer Institut für Solare Energiesysteme ISE. o. J. „Öffentliche Nettostromerzeugung in Deutschland“. Zugegriffen 3. Juni 2024. https://energy-charts.info/charts/energy/chart.htm?l=de&c=DE&chartColumnSorting=default&year=-1&interval=year&legendItems=lz1zb&source=public.\n\n\nHeimerl, Stephan, und Beate Kohler. 2017. „Aktueller Stand der Pumpspeicherkraftwerke in Deutschland“. WasserWirtschaft. 2017. https://www.fwt.fichtner.de/userfiles/fileadmin-fwt/Publikationen/WaWi_2017_10_Heimerl_Kohler_PSKW.pdf.\n\n\nWickham, Hadley, Mine Çetinkaya-Rundel, und Garrett Grolemund. 2023. „R for data science: Import, tidy, transform, visualize, and model data“. Beijing; Boston; Farnham; Sebastopol; Tokyo: O’Reilly. 2023. https://r4ds.hadley.nz/.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Energiedatenanalyse</span>"
    ]
  }
]